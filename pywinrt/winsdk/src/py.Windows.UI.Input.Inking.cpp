// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.3

#include "pybase.h"
#include "py.Windows.UI.Input.Inking.h"

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkModelerAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterRuler>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognitionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStroke>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeInput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkSynchronizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::PenAndInkSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPointFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>::python_type;

namespace py::cpp::Windows::UI::Input::Inking
{
    // ----- InkDrawingAttributes class --------------------
    constexpr const char* const _type_name_InkDrawingAttributes = "InkDrawingAttributes";

    static PyObject* _new_InkDrawingAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkDrawingAttributes instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkDrawingAttributes_CreateForPencil(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::Inking::InkDrawingAttributes::CreateForPencil());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_Size(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_Size(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_PenTip(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenTip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_PenTip(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::PenTipShape>(arg);

            self->obj.PenTip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_IgnorePressure(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorePressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_IgnorePressure(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnorePressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_FitToCurve(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FitToCurve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_FitToCurve(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.FitToCurve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_Color(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_Color(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_PenTipTransform(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenTipTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_PenTipTransform(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.PenTipTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_DrawAsHighlighter(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DrawAsHighlighter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_DrawAsHighlighter(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DrawAsHighlighter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_PencilProperties(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PencilProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkDrawingAttributes_get_IgnoreTilt(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnoreTilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributes_put_IgnoreTilt(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTilt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkDrawingAttributes_get_ModelerAttributes(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelerAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkDrawingAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkDrawingAttributes[] = {
        { "create_for_pencil", reinterpret_cast<PyCFunction>(InkDrawingAttributes_CreateForPencil), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkDrawingAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkDrawingAttributes[] = {
        { "size", reinterpret_cast<getter>(InkDrawingAttributes_get_Size), reinterpret_cast<setter>(InkDrawingAttributes_put_Size), nullptr, nullptr },
        { "pen_tip", reinterpret_cast<getter>(InkDrawingAttributes_get_PenTip), reinterpret_cast<setter>(InkDrawingAttributes_put_PenTip), nullptr, nullptr },
        { "ignore_pressure", reinterpret_cast<getter>(InkDrawingAttributes_get_IgnorePressure), reinterpret_cast<setter>(InkDrawingAttributes_put_IgnorePressure), nullptr, nullptr },
        { "fit_to_curve", reinterpret_cast<getter>(InkDrawingAttributes_get_FitToCurve), reinterpret_cast<setter>(InkDrawingAttributes_put_FitToCurve), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(InkDrawingAttributes_get_Color), reinterpret_cast<setter>(InkDrawingAttributes_put_Color), nullptr, nullptr },
        { "pen_tip_transform", reinterpret_cast<getter>(InkDrawingAttributes_get_PenTipTransform), reinterpret_cast<setter>(InkDrawingAttributes_put_PenTipTransform), nullptr, nullptr },
        { "draw_as_highlighter", reinterpret_cast<getter>(InkDrawingAttributes_get_DrawAsHighlighter), reinterpret_cast<setter>(InkDrawingAttributes_put_DrawAsHighlighter), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(InkDrawingAttributes_get_Kind), nullptr, nullptr, nullptr },
        { "pencil_properties", reinterpret_cast<getter>(InkDrawingAttributes_get_PencilProperties), nullptr, nullptr, nullptr },
        { "ignore_tilt", reinterpret_cast<getter>(InkDrawingAttributes_get_IgnoreTilt), reinterpret_cast<setter>(InkDrawingAttributes_put_IgnoreTilt), nullptr, nullptr },
        { "modeler_attributes", reinterpret_cast<getter>(InkDrawingAttributes_get_ModelerAttributes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkDrawingAttributes[] = 
    {
        { Py_tp_new, _new_InkDrawingAttributes },
        { Py_tp_dealloc, _dealloc_InkDrawingAttributes },
        { Py_tp_methods, _methods_InkDrawingAttributes },
        { Py_tp_getset, _getset_InkDrawingAttributes },
        { },
    };

    static PyType_Spec _type_spec_InkDrawingAttributes =
    {
        "_winsdk_Windows_UI_Input_Inking.InkDrawingAttributes",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkDrawingAttributes
    };

    // ----- InkDrawingAttributesPencilProperties class --------------------
    constexpr const char* const _type_name_InkDrawingAttributesPencilProperties = "InkDrawingAttributesPencilProperties";

    static PyObject* _new_InkDrawingAttributesPencilProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkDrawingAttributesPencilProperties);
        return nullptr;
    }

    static void _dealloc_InkDrawingAttributesPencilProperties(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkDrawingAttributesPencilProperties_get_Opacity(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkDrawingAttributesPencilProperties_put_Opacity(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkDrawingAttributesPencilProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkDrawingAttributesPencilProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkDrawingAttributesPencilProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkDrawingAttributesPencilProperties[] = {
        { "opacity", reinterpret_cast<getter>(InkDrawingAttributesPencilProperties_get_Opacity), reinterpret_cast<setter>(InkDrawingAttributesPencilProperties_put_Opacity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkDrawingAttributesPencilProperties[] = 
    {
        { Py_tp_new, _new_InkDrawingAttributesPencilProperties },
        { Py_tp_dealloc, _dealloc_InkDrawingAttributesPencilProperties },
        { Py_tp_methods, _methods_InkDrawingAttributesPencilProperties },
        { Py_tp_getset, _getset_InkDrawingAttributesPencilProperties },
        { },
    };

    static PyType_Spec _type_spec_InkDrawingAttributesPencilProperties =
    {
        "_winsdk_Windows_UI_Input_Inking.InkDrawingAttributesPencilProperties",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkDrawingAttributesPencilProperties
    };

    // ----- InkInputConfiguration class --------------------
    constexpr const char* const _type_name_InkInputConfiguration = "InkInputConfiguration";

    static PyObject* _new_InkInputConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkInputConfiguration);
        return nullptr;
    }

    static void _dealloc_InkInputConfiguration(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkInputConfiguration_get_IsPrimaryBarrelButtonInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrimaryBarrelButtonInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsPrimaryBarrelButtonInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPrimaryBarrelButtonInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputConfiguration_get_IsEraserInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEraserInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsEraserInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEraserInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputConfiguration_get_IsPenHapticFeedbackEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPenHapticFeedbackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputConfiguration_put_IsPenHapticFeedbackEnabled(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPenHapticFeedbackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkInputConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkInputConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkInputConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkInputConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkInputConfiguration[] = {
        { "is_primary_barrel_button_input_enabled", reinterpret_cast<getter>(InkInputConfiguration_get_IsPrimaryBarrelButtonInputEnabled), reinterpret_cast<setter>(InkInputConfiguration_put_IsPrimaryBarrelButtonInputEnabled), nullptr, nullptr },
        { "is_eraser_input_enabled", reinterpret_cast<getter>(InkInputConfiguration_get_IsEraserInputEnabled), reinterpret_cast<setter>(InkInputConfiguration_put_IsEraserInputEnabled), nullptr, nullptr },
        { "is_pen_haptic_feedback_enabled", reinterpret_cast<getter>(InkInputConfiguration_get_IsPenHapticFeedbackEnabled), reinterpret_cast<setter>(InkInputConfiguration_put_IsPenHapticFeedbackEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkInputConfiguration[] = 
    {
        { Py_tp_new, _new_InkInputConfiguration },
        { Py_tp_dealloc, _dealloc_InkInputConfiguration },
        { Py_tp_methods, _methods_InkInputConfiguration },
        { Py_tp_getset, _getset_InkInputConfiguration },
        { },
    };

    static PyType_Spec _type_spec_InkInputConfiguration =
    {
        "_winsdk_Windows_UI_Input_Inking.InkInputConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkInputConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkInputConfiguration
    };

    // ----- InkInputProcessingConfiguration class --------------------
    constexpr const char* const _type_name_InkInputProcessingConfiguration = "InkInputProcessingConfiguration";

    static PyObject* _new_InkInputProcessingConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkInputProcessingConfiguration);
        return nullptr;
    }

    static void _dealloc_InkInputProcessingConfiguration(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkInputProcessingConfiguration_get_RightDragAction(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightDragAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputProcessingConfiguration_put_RightDragAction(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkInputRightDragAction>(arg);

            self->obj.RightDragAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkInputProcessingConfiguration_get_Mode(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkInputProcessingConfiguration_put_Mode(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkInputProcessingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkInputProcessingConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkInputProcessingConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkInputProcessingConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkInputProcessingConfiguration[] = {
        { "right_drag_action", reinterpret_cast<getter>(InkInputProcessingConfiguration_get_RightDragAction), reinterpret_cast<setter>(InkInputProcessingConfiguration_put_RightDragAction), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(InkInputProcessingConfiguration_get_Mode), reinterpret_cast<setter>(InkInputProcessingConfiguration_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkInputProcessingConfiguration[] = 
    {
        { Py_tp_new, _new_InkInputProcessingConfiguration },
        { Py_tp_dealloc, _dealloc_InkInputProcessingConfiguration },
        { Py_tp_methods, _methods_InkInputProcessingConfiguration },
        { Py_tp_getset, _getset_InkInputProcessingConfiguration },
        { },
    };

    static PyType_Spec _type_spec_InkInputProcessingConfiguration =
    {
        "_winsdk_Windows_UI_Input_Inking.InkInputProcessingConfiguration",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkInputProcessingConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkInputProcessingConfiguration
    };

    // ----- InkManager class --------------------
    constexpr const char* const _type_name_InkManager = "InkManager";

    static PyObject* _new_InkManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkManager(py::wrapper::Windows::UI::Input::Inking::InkManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkManager_AddStroke(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_LoadAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_MoveSelected(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerDown(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.ProcessPointerDown(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerUp(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.ProcessPointerUp(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_ProcessPointerUpdate(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.ProcessPointerUpdate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 0);

                return py::convert(self->obj.RecognizeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SaveAsync(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SetDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.SetDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkManager_get_Mode(py::wrapper::Windows::UI::Input::Inking::InkManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkManager_put_Mode(py::wrapper::Windows::UI::Input::Inking::InkManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkManipulationMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkManager_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkManager[] = {
        { "add_stroke", reinterpret_cast<PyCFunction>(InkManager_AddStroke), METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", reinterpret_cast<PyCFunction>(InkManager_CanPasteFromClipboard), METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", reinterpret_cast<PyCFunction>(InkManager_CopySelectedToClipboard), METH_VARARGS, nullptr },
        { "delete_selected", reinterpret_cast<PyCFunction>(InkManager_DeleteSelected), METH_VARARGS, nullptr },
        { "get_recognition_results", reinterpret_cast<PyCFunction>(InkManager_GetRecognitionResults), METH_VARARGS, nullptr },
        { "get_recognizers", reinterpret_cast<PyCFunction>(InkManager_GetRecognizers), METH_VARARGS, nullptr },
        { "get_strokes", reinterpret_cast<PyCFunction>(InkManager_GetStrokes), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(InkManager_LoadAsync), METH_VARARGS, nullptr },
        { "move_selected", reinterpret_cast<PyCFunction>(InkManager_MoveSelected), METH_VARARGS, nullptr },
        { "paste_from_clipboard", reinterpret_cast<PyCFunction>(InkManager_PasteFromClipboard), METH_VARARGS, nullptr },
        { "process_pointer_down", reinterpret_cast<PyCFunction>(InkManager_ProcessPointerDown), METH_VARARGS, nullptr },
        { "process_pointer_up", reinterpret_cast<PyCFunction>(InkManager_ProcessPointerUp), METH_VARARGS, nullptr },
        { "process_pointer_update", reinterpret_cast<PyCFunction>(InkManager_ProcessPointerUpdate), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(InkManager_RecognizeAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(InkManager_SaveAsync), METH_VARARGS, nullptr },
        { "select_with_line", reinterpret_cast<PyCFunction>(InkManager_SelectWithLine), METH_VARARGS, nullptr },
        { "select_with_poly_line", reinterpret_cast<PyCFunction>(InkManager_SelectWithPolyLine), METH_VARARGS, nullptr },
        { "set_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkManager_SetDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "set_default_recognizer", reinterpret_cast<PyCFunction>(InkManager_SetDefaultRecognizer), METH_VARARGS, nullptr },
        { "update_recognition_results", reinterpret_cast<PyCFunction>(InkManager_UpdateRecognitionResults), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkManager[] = {
        { "mode", reinterpret_cast<getter>(InkManager_get_Mode), reinterpret_cast<setter>(InkManager_put_Mode), nullptr, nullptr },
        { "bounding_rect", reinterpret_cast<getter>(InkManager_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkManager[] = 
    {
        { Py_tp_new, _new_InkManager },
        { Py_tp_dealloc, _dealloc_InkManager },
        { Py_tp_methods, _methods_InkManager },
        { Py_tp_getset, _getset_InkManager },
        { },
    };

    static PyType_Spec _type_spec_InkManager =
    {
        "_winsdk_Windows_UI_Input_Inking.InkManager",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkManager
    };

    // ----- InkModelerAttributes class --------------------
    constexpr const char* const _type_name_InkModelerAttributes = "InkModelerAttributes";

    static PyObject* _new_InkModelerAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkModelerAttributes);
        return nullptr;
    }

    static void _dealloc_InkModelerAttributes(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkModelerAttributes_get_ScalingFactor(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScalingFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_ScalingFactor(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.ScalingFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkModelerAttributes_get_PredictionTime(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PredictionTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_PredictionTime(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.PredictionTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkModelerAttributes_get_UseVelocityBasedPressure(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseVelocityBasedPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkModelerAttributes_put_UseVelocityBasedPressure(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseVelocityBasedPressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InkModelerAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkModelerAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkModelerAttributes[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkModelerAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkModelerAttributes[] = {
        { "scaling_factor", reinterpret_cast<getter>(InkModelerAttributes_get_ScalingFactor), reinterpret_cast<setter>(InkModelerAttributes_put_ScalingFactor), nullptr, nullptr },
        { "prediction_time", reinterpret_cast<getter>(InkModelerAttributes_get_PredictionTime), reinterpret_cast<setter>(InkModelerAttributes_put_PredictionTime), nullptr, nullptr },
        { "use_velocity_based_pressure", reinterpret_cast<getter>(InkModelerAttributes_get_UseVelocityBasedPressure), reinterpret_cast<setter>(InkModelerAttributes_put_UseVelocityBasedPressure), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkModelerAttributes[] = 
    {
        { Py_tp_new, _new_InkModelerAttributes },
        { Py_tp_dealloc, _dealloc_InkModelerAttributes },
        { Py_tp_methods, _methods_InkModelerAttributes },
        { Py_tp_getset, _getset_InkModelerAttributes },
        { },
    };

    static PyType_Spec _type_spec_InkModelerAttributes =
    {
        "_winsdk_Windows_UI_Input_Inking.InkModelerAttributes",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkModelerAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkModelerAttributes
    };

    // ----- InkPoint class --------------------
    constexpr const char* const _type_name_InkPoint = "InkPoint";

    static PyObject* _new_InkPoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<float>(args, 2);
                auto param3 = py::convert_to<float>(args, 3);
                auto param4 = py::convert_to<uint64_t>(args, 4);

                winrt::Windows::UI::Input::Inking::InkPoint instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                winrt::Windows::UI::Input::Inking::InkPoint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPoint(py::wrapper::Windows::UI::Input::Inking::InkPoint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPoint_get_Position(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_Pressure(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_TiltX(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_TiltY(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPoint_get_Timestamp(py::wrapper::Windows::UI::Input::Inking::InkPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPoint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPoint[] = {
        { "position", reinterpret_cast<getter>(InkPoint_get_Position), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InkPoint_get_Pressure), nullptr, nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InkPoint_get_TiltX), nullptr, nullptr, nullptr },
        { "tilt_y", reinterpret_cast<getter>(InkPoint_get_TiltY), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(InkPoint_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPoint[] = 
    {
        { Py_tp_new, _new_InkPoint },
        { Py_tp_dealloc, _dealloc_InkPoint },
        { Py_tp_methods, _methods_InkPoint },
        { Py_tp_getset, _getset_InkPoint },
        { },
    };

    static PyType_Spec _type_spec_InkPoint =
    {
        "_winsdk_Windows_UI_Input_Inking.InkPoint",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPoint
    };

    // ----- InkPresenter class --------------------
    constexpr const char* const _type_name_InkPresenter = "InkPresenter";

    static PyObject* _new_InkPresenter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkPresenter);
        return nullptr;
    }

    static void _dealloc_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPresenter_ActivateCustomDrying(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ActivateCustomDrying());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_CopyDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CopyDefaultDrawingAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_SetPredefinedConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenterPredefinedConfiguration>(args, 0);

                self->obj.SetPredefinedConfiguration(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_UpdateDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.UpdateDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_StrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_StrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(arg);

            self->obj.StrokeContainer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_IsInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInputEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_IsInputEnabled(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInputEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputDeviceTypes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputDeviceTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_InputDeviceTypes(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreInputDeviceTypes>(arg);

            self->obj.InputDeviceTypes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputProcessingConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputProcessingConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_StrokeInput(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_UnprocessedInput(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnprocessedInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_get_HighContrastAdjustment(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighContrastAdjustment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenter_put_HighContrastAdjustment(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkHighContrastAdjustment>(arg);

            self->obj.HighContrastAdjustment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenter_get_InputConfiguration(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_add_StrokesCollected(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkPresenter, winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>>(arg);

            return py::convert(self->obj.StrokesCollected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_remove_StrokesCollected(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokesCollected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_add_StrokesErased(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkPresenter, winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>>(arg);

            return py::convert(self->obj.StrokesErased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkPresenter_remove_StrokesErased(py::wrapper::Windows::UI::Input::Inking::InkPresenter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokesErased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPresenter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenter[] = {
        { "activate_custom_drying", reinterpret_cast<PyCFunction>(InkPresenter_ActivateCustomDrying), METH_VARARGS, nullptr },
        { "copy_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkPresenter_CopyDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "set_predefined_configuration", reinterpret_cast<PyCFunction>(InkPresenter_SetPredefinedConfiguration), METH_VARARGS, nullptr },
        { "update_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkPresenter_UpdateDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "add_strokes_collected", reinterpret_cast<PyCFunction>(InkPresenter_add_StrokesCollected), METH_O, nullptr },
        { "remove_strokes_collected", reinterpret_cast<PyCFunction>(InkPresenter_remove_StrokesCollected), METH_O, nullptr },
        { "add_strokes_erased", reinterpret_cast<PyCFunction>(InkPresenter_add_StrokesErased), METH_O, nullptr },
        { "remove_strokes_erased", reinterpret_cast<PyCFunction>(InkPresenter_remove_StrokesErased), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPresenter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPresenter[] = {
        { "stroke_container", reinterpret_cast<getter>(InkPresenter_get_StrokeContainer), reinterpret_cast<setter>(InkPresenter_put_StrokeContainer), nullptr, nullptr },
        { "is_input_enabled", reinterpret_cast<getter>(InkPresenter_get_IsInputEnabled), reinterpret_cast<setter>(InkPresenter_put_IsInputEnabled), nullptr, nullptr },
        { "input_device_types", reinterpret_cast<getter>(InkPresenter_get_InputDeviceTypes), reinterpret_cast<setter>(InkPresenter_put_InputDeviceTypes), nullptr, nullptr },
        { "input_processing_configuration", reinterpret_cast<getter>(InkPresenter_get_InputProcessingConfiguration), nullptr, nullptr, nullptr },
        { "stroke_input", reinterpret_cast<getter>(InkPresenter_get_StrokeInput), nullptr, nullptr, nullptr },
        { "unprocessed_input", reinterpret_cast<getter>(InkPresenter_get_UnprocessedInput), nullptr, nullptr, nullptr },
        { "high_contrast_adjustment", reinterpret_cast<getter>(InkPresenter_get_HighContrastAdjustment), reinterpret_cast<setter>(InkPresenter_put_HighContrastAdjustment), nullptr, nullptr },
        { "input_configuration", reinterpret_cast<getter>(InkPresenter_get_InputConfiguration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPresenter[] = 
    {
        { Py_tp_new, _new_InkPresenter },
        { Py_tp_dealloc, _dealloc_InkPresenter },
        { Py_tp_methods, _methods_InkPresenter },
        { Py_tp_getset, _getset_InkPresenter },
        { },
    };

    static PyType_Spec _type_spec_InkPresenter =
    {
        "_winsdk_Windows_UI_Input_Inking.InkPresenter",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenter
    };

    // ----- InkPresenterProtractor class --------------------
    constexpr const char* const _type_name_InkPresenterProtractor = "InkPresenterProtractor";

    static PyObject* _new_InkPresenterProtractor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                winrt::Windows::UI::Input::Inking::InkPresenterProtractor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPresenterProtractor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPresenterProtractor_get_Radius(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Radius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_Radius(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Radius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsResizable(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsResizable(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResizable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsCenterMarkerVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCenterMarkerVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsCenterMarkerVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCenterMarkerVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsAngleReadoutVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAngleReadoutVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsAngleReadoutVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAngleReadoutVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreTickMarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreTickMarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AreRaysVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreRaysVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AreRaysVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreRaysVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_AccentColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccentColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_AccentColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.AccentColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterProtractor_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterProtractor_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPresenterProtractor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenterProtractor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPresenterProtractor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPresenterProtractor[] = {
        { "radius", reinterpret_cast<getter>(InkPresenterProtractor_get_Radius), reinterpret_cast<setter>(InkPresenterProtractor_put_Radius), nullptr, nullptr },
        { "is_resizable", reinterpret_cast<getter>(InkPresenterProtractor_get_IsResizable), reinterpret_cast<setter>(InkPresenterProtractor_put_IsResizable), nullptr, nullptr },
        { "is_center_marker_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_IsCenterMarkerVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_IsCenterMarkerVisible), nullptr, nullptr },
        { "is_angle_readout_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_IsAngleReadoutVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_IsAngleReadoutVisible), nullptr, nullptr },
        { "are_tick_marks_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_AreTickMarksVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_AreTickMarksVisible), nullptr, nullptr },
        { "are_rays_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_AreRaysVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_AreRaysVisible), nullptr, nullptr },
        { "accent_color", reinterpret_cast<getter>(InkPresenterProtractor_get_AccentColor), reinterpret_cast<setter>(InkPresenterProtractor_put_AccentColor), nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(InkPresenterProtractor_get_Transform), reinterpret_cast<setter>(InkPresenterProtractor_put_Transform), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(InkPresenterProtractor_get_IsVisible), reinterpret_cast<setter>(InkPresenterProtractor_put_IsVisible), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(InkPresenterProtractor_get_ForegroundColor), reinterpret_cast<setter>(InkPresenterProtractor_put_ForegroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(InkPresenterProtractor_get_BackgroundColor), reinterpret_cast<setter>(InkPresenterProtractor_put_BackgroundColor), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(InkPresenterProtractor_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPresenterProtractor[] = 
    {
        { Py_tp_new, _new_InkPresenterProtractor },
        { Py_tp_dealloc, _dealloc_InkPresenterProtractor },
        { Py_tp_methods, _methods_InkPresenterProtractor },
        { Py_tp_getset, _getset_InkPresenterProtractor },
        { },
    };

    static PyType_Spec _type_spec_InkPresenterProtractor =
    {
        "_winsdk_Windows_UI_Input_Inking.InkPresenterProtractor",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenterProtractor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenterProtractor
    };

    // ----- InkPresenterRuler class --------------------
    constexpr const char* const _type_name_InkPresenterRuler = "InkPresenterRuler";

    static PyObject* _new_InkPresenterRuler(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                winrt::Windows::UI::Input::Inking::InkPresenterRuler instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkPresenterRuler(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkPresenterRuler_get_Width(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Width(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Length(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Length(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_IsCompassVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCompassVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_IsCompassVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompassVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreTickMarksVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_AreTickMarksVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreTickMarksVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_Transform(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkPresenterRuler_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkPresenterRuler_get_Kind(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkPresenterRuler(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkPresenterRuler>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkPresenterRuler[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkPresenterRuler), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkPresenterRuler[] = {
        { "width", reinterpret_cast<getter>(InkPresenterRuler_get_Width), reinterpret_cast<setter>(InkPresenterRuler_put_Width), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(InkPresenterRuler_get_Length), reinterpret_cast<setter>(InkPresenterRuler_put_Length), nullptr, nullptr },
        { "is_compass_visible", reinterpret_cast<getter>(InkPresenterRuler_get_IsCompassVisible), reinterpret_cast<setter>(InkPresenterRuler_put_IsCompassVisible), nullptr, nullptr },
        { "are_tick_marks_visible", reinterpret_cast<getter>(InkPresenterRuler_get_AreTickMarksVisible), reinterpret_cast<setter>(InkPresenterRuler_put_AreTickMarksVisible), nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(InkPresenterRuler_get_Transform), reinterpret_cast<setter>(InkPresenterRuler_put_Transform), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(InkPresenterRuler_get_IsVisible), reinterpret_cast<setter>(InkPresenterRuler_put_IsVisible), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(InkPresenterRuler_get_ForegroundColor), reinterpret_cast<setter>(InkPresenterRuler_put_ForegroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(InkPresenterRuler_get_BackgroundColor), reinterpret_cast<setter>(InkPresenterRuler_put_BackgroundColor), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(InkPresenterRuler_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkPresenterRuler[] = 
    {
        { Py_tp_new, _new_InkPresenterRuler },
        { Py_tp_dealloc, _dealloc_InkPresenterRuler },
        { Py_tp_methods, _methods_InkPresenterRuler },
        { Py_tp_getset, _getset_InkPresenterRuler },
        { },
    };

    static PyType_Spec _type_spec_InkPresenterRuler =
    {
        "_winsdk_Windows_UI_Input_Inking.InkPresenterRuler",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkPresenterRuler),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkPresenterRuler
    };

    // ----- InkRecognitionResult class --------------------
    constexpr const char* const _type_name_InkRecognitionResult = "InkRecognitionResult";

    static PyObject* _new_InkRecognitionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkRecognitionResult);
        return nullptr;
    }

    static void _dealloc_InkRecognitionResult(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkRecognitionResult_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognitionResult_GetTextCandidates(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTextCandidates());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognitionResult_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognitionResult[] = {
        { "get_strokes", reinterpret_cast<PyCFunction>(InkRecognitionResult_GetStrokes), METH_VARARGS, nullptr },
        { "get_text_candidates", reinterpret_cast<PyCFunction>(InkRecognitionResult_GetTextCandidates), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkRecognitionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkRecognitionResult[] = {
        { "bounding_rect", reinterpret_cast<getter>(InkRecognitionResult_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkRecognitionResult[] = 
    {
        { Py_tp_new, _new_InkRecognitionResult },
        { Py_tp_dealloc, _dealloc_InkRecognitionResult },
        { Py_tp_methods, _methods_InkRecognitionResult },
        { Py_tp_getset, _getset_InkRecognitionResult },
        { },
    };

    static PyType_Spec _type_spec_InkRecognitionResult =
    {
        "_winsdk_Windows_UI_Input_Inking.InkRecognitionResult",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognitionResult
    };

    // ----- InkRecognizer class --------------------
    constexpr const char* const _type_name_InkRecognizer = "InkRecognizer";

    static PyObject* _new_InkRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkRecognizer);
        return nullptr;
    }

    static void _dealloc_InkRecognizer(py::wrapper::Windows::UI::Input::Inking::InkRecognizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkRecognizer_get_Name(py::wrapper::Windows::UI::Input::Inking::InkRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognizer[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkRecognizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkRecognizer[] = {
        { "name", reinterpret_cast<getter>(InkRecognizer_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkRecognizer[] = 
    {
        { Py_tp_new, _new_InkRecognizer },
        { Py_tp_dealloc, _dealloc_InkRecognizer },
        { Py_tp_methods, _methods_InkRecognizer },
        { Py_tp_getset, _getset_InkRecognizer },
        { },
    };

    static PyType_Spec _type_spec_InkRecognizer =
    {
        "_winsdk_Windows_UI_Input_Inking.InkRecognizer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognizer
    };

    // ----- InkRecognizerContainer class --------------------
    constexpr const char* const _type_name_InkRecognizerContainer = "InkRecognizerContainer";

    static PyObject* _new_InkRecognizerContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkRecognizerContainer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkRecognizerContainer(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkRecognizerContainer_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognizerContainer_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkRecognizerContainer_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkRecognizerContainer[] = {
        { "get_recognizers", reinterpret_cast<PyCFunction>(InkRecognizerContainer_GetRecognizers), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(InkRecognizerContainer_RecognizeAsync), METH_VARARGS, nullptr },
        { "set_default_recognizer", reinterpret_cast<PyCFunction>(InkRecognizerContainer_SetDefaultRecognizer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkRecognizerContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkRecognizerContainer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkRecognizerContainer[] = 
    {
        { Py_tp_new, _new_InkRecognizerContainer },
        { Py_tp_dealloc, _dealloc_InkRecognizerContainer },
        { Py_tp_methods, _methods_InkRecognizerContainer },
        { Py_tp_getset, _getset_InkRecognizerContainer },
        { },
    };

    static PyType_Spec _type_spec_InkRecognizerContainer =
    {
        "_winsdk_Windows_UI_Input_Inking.InkRecognizerContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkRecognizerContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkRecognizerContainer
    };

    // ----- InkStroke class --------------------
    constexpr const char* const _type_name_InkStroke = "InkStroke";

    static PyObject* _new_InkStroke(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStroke);
        return nullptr;
    }

    static void _dealloc_InkStroke(py::wrapper::Windows::UI::Input::Inking::InkStroke* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStroke_Clone(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_GetInkPoints(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetInkPoints());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_GetRenderingSegments(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRenderingSegments());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_Selected(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_Selected(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Selected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_DrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DrawingAttributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_DrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(arg);

            self->obj.DrawingAttributes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_Recognized(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recognized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_PointTransform(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_PointTransform(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.PointTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_StrokeStartedTime(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeStartedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_StrokeStartedTime(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.StrokeStartedTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_StrokeDuration(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StrokeDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InkStroke_put_StrokeDuration(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StrokeDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InkStroke_get_Id(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStroke_get_PointerId(py::wrapper::Windows::UI::Input::Inking::InkStroke* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStroke(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStroke>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStroke[] = {
        { "clone", reinterpret_cast<PyCFunction>(InkStroke_Clone), METH_VARARGS, nullptr },
        { "get_ink_points", reinterpret_cast<PyCFunction>(InkStroke_GetInkPoints), METH_VARARGS, nullptr },
        { "get_rendering_segments", reinterpret_cast<PyCFunction>(InkStroke_GetRenderingSegments), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStroke), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStroke[] = {
        { "selected", reinterpret_cast<getter>(InkStroke_get_Selected), reinterpret_cast<setter>(InkStroke_put_Selected), nullptr, nullptr },
        { "drawing_attributes", reinterpret_cast<getter>(InkStroke_get_DrawingAttributes), reinterpret_cast<setter>(InkStroke_put_DrawingAttributes), nullptr, nullptr },
        { "bounding_rect", reinterpret_cast<getter>(InkStroke_get_BoundingRect), nullptr, nullptr, nullptr },
        { "recognized", reinterpret_cast<getter>(InkStroke_get_Recognized), nullptr, nullptr, nullptr },
        { "point_transform", reinterpret_cast<getter>(InkStroke_get_PointTransform), reinterpret_cast<setter>(InkStroke_put_PointTransform), nullptr, nullptr },
        { "stroke_started_time", reinterpret_cast<getter>(InkStroke_get_StrokeStartedTime), reinterpret_cast<setter>(InkStroke_put_StrokeStartedTime), nullptr, nullptr },
        { "stroke_duration", reinterpret_cast<getter>(InkStroke_get_StrokeDuration), reinterpret_cast<setter>(InkStroke_put_StrokeDuration), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(InkStroke_get_Id), nullptr, nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(InkStroke_get_PointerId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStroke[] = 
    {
        { Py_tp_new, _new_InkStroke },
        { Py_tp_dealloc, _dealloc_InkStroke },
        { Py_tp_methods, _methods_InkStroke },
        { Py_tp_getset, _getset_InkStroke },
        { },
    };

    static PyType_Spec _type_spec_InkStroke =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStroke",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStroke),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStroke
    };

    // ----- InkStrokeBuilder class --------------------
    constexpr const char* const _type_name_InkStrokeBuilder = "InkStrokeBuilder";

    static PyObject* _new_InkStrokeBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkStrokeBuilder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkStrokeBuilder(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeBuilder_AppendToStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.AppendToStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_BeginStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                self->obj.BeginStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_CreateStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.CreateStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_CreateStrokeFromInkPoints(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkPoint>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);

                return py::convert(self->obj.CreateStrokeFromInkPoints(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkPoint>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 3);

                return py::convert(self->obj.CreateStrokeFromInkPoints(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_EndStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::PointerPoint>(args, 0);

                return py::convert(self->obj.EndStroke(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeBuilder_SetDefaultDrawingAttributes(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>(args, 0);

                self->obj.SetDefaultDrawingAttributes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeBuilder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeBuilder[] = {
        { "append_to_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_AppendToStroke), METH_VARARGS, nullptr },
        { "begin_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_BeginStroke), METH_VARARGS, nullptr },
        { "create_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_CreateStroke), METH_VARARGS, nullptr },
        { "create_stroke_from_ink_points", reinterpret_cast<PyCFunction>(InkStrokeBuilder_CreateStrokeFromInkPoints), METH_VARARGS, nullptr },
        { "end_stroke", reinterpret_cast<PyCFunction>(InkStrokeBuilder_EndStroke), METH_VARARGS, nullptr },
        { "set_default_drawing_attributes", reinterpret_cast<PyCFunction>(InkStrokeBuilder_SetDefaultDrawingAttributes), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeBuilder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeBuilder[] = {
        { }
    };

    static PyType_Slot _type_slots_InkStrokeBuilder[] = 
    {
        { Py_tp_new, _new_InkStrokeBuilder },
        { Py_tp_dealloc, _dealloc_InkStrokeBuilder },
        { Py_tp_methods, _methods_InkStrokeBuilder },
        { Py_tp_getset, _getset_InkStrokeBuilder },
        { },
    };

    static PyType_Spec _type_spec_InkStrokeBuilder =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStrokeBuilder",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeBuilder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeBuilder
    };

    // ----- InkStrokeContainer class --------------------
    constexpr const char* const _type_name_InkStrokeContainer = "InkStrokeContainer";

    static PyObject* _new_InkStrokeContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Inking::InkStrokeContainer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InkStrokeContainer(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeContainer_AddStroke(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_AddStrokes(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Inking::InkStroke>>(args, 0);

                self->obj.AddStrokes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_Clear(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetStrokeById(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetStrokeById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_GetStrokes(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_LoadAsync(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_MoveSelected(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SaveAsync(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPersistenceFormat>(args, 1);

                return py::convert(self->obj.SaveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkStrokeContainer_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeContainer[] = {
        { "add_stroke", reinterpret_cast<PyCFunction>(InkStrokeContainer_AddStroke), METH_VARARGS, nullptr },
        { "add_strokes", reinterpret_cast<PyCFunction>(InkStrokeContainer_AddStrokes), METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", reinterpret_cast<PyCFunction>(InkStrokeContainer_CanPasteFromClipboard), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(InkStrokeContainer_Clear), METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", reinterpret_cast<PyCFunction>(InkStrokeContainer_CopySelectedToClipboard), METH_VARARGS, nullptr },
        { "delete_selected", reinterpret_cast<PyCFunction>(InkStrokeContainer_DeleteSelected), METH_VARARGS, nullptr },
        { "get_recognition_results", reinterpret_cast<PyCFunction>(InkStrokeContainer_GetRecognitionResults), METH_VARARGS, nullptr },
        { "get_stroke_by_id", reinterpret_cast<PyCFunction>(InkStrokeContainer_GetStrokeById), METH_VARARGS, nullptr },
        { "get_strokes", reinterpret_cast<PyCFunction>(InkStrokeContainer_GetStrokes), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(InkStrokeContainer_LoadAsync), METH_VARARGS, nullptr },
        { "move_selected", reinterpret_cast<PyCFunction>(InkStrokeContainer_MoveSelected), METH_VARARGS, nullptr },
        { "paste_from_clipboard", reinterpret_cast<PyCFunction>(InkStrokeContainer_PasteFromClipboard), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(InkStrokeContainer_SaveAsync), METH_VARARGS, nullptr },
        { "select_with_line", reinterpret_cast<PyCFunction>(InkStrokeContainer_SelectWithLine), METH_VARARGS, nullptr },
        { "select_with_poly_line", reinterpret_cast<PyCFunction>(InkStrokeContainer_SelectWithPolyLine), METH_VARARGS, nullptr },
        { "update_recognition_results", reinterpret_cast<PyCFunction>(InkStrokeContainer_UpdateRecognitionResults), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeContainer[] = {
        { "bounding_rect", reinterpret_cast<getter>(InkStrokeContainer_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokeContainer[] = 
    {
        { Py_tp_new, _new_InkStrokeContainer },
        { Py_tp_dealloc, _dealloc_InkStrokeContainer },
        { Py_tp_methods, _methods_InkStrokeContainer },
        { Py_tp_getset, _getset_InkStrokeContainer },
        { },
    };

    static PyType_Spec _type_spec_InkStrokeContainer =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStrokeContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeContainer
    };

    // ----- InkStrokeInput class --------------------
    constexpr const char* const _type_name_InkStrokeInput = "InkStrokeInput";

    static PyObject* _new_InkStrokeInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokeInput);
        return nullptr;
    }

    static void _dealloc_InkStrokeInput(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeInput_get_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InkPresenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeCanceled(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeCanceled(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeContinued(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeContinued(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeContinued(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeContinued(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeEnded(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeEnded(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_add_StrokeStarted(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkStrokeInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.StrokeStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeInput_remove_StrokeStarted(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StrokeStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeInput[] = {
        { "add_stroke_canceled", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeCanceled), METH_O, nullptr },
        { "remove_stroke_canceled", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeCanceled), METH_O, nullptr },
        { "add_stroke_continued", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeContinued), METH_O, nullptr },
        { "remove_stroke_continued", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeContinued), METH_O, nullptr },
        { "add_stroke_ended", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeEnded), METH_O, nullptr },
        { "remove_stroke_ended", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeEnded), METH_O, nullptr },
        { "add_stroke_started", reinterpret_cast<PyCFunction>(InkStrokeInput_add_StrokeStarted), METH_O, nullptr },
        { "remove_stroke_started", reinterpret_cast<PyCFunction>(InkStrokeInput_remove_StrokeStarted), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeInput[] = {
        { "ink_presenter", reinterpret_cast<getter>(InkStrokeInput_get_InkPresenter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokeInput[] = 
    {
        { Py_tp_new, _new_InkStrokeInput },
        { Py_tp_dealloc, _dealloc_InkStrokeInput },
        { Py_tp_methods, _methods_InkStrokeInput },
        { Py_tp_getset, _getset_InkStrokeInput },
        { },
    };

    static PyType_Spec _type_spec_InkStrokeInput =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStrokeInput",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeInput
    };

    // ----- InkStrokeRenderingSegment class --------------------
    constexpr const char* const _type_name_InkStrokeRenderingSegment = "InkStrokeRenderingSegment";

    static PyObject* _new_InkStrokeRenderingSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokeRenderingSegment);
        return nullptr;
    }

    static void _dealloc_InkStrokeRenderingSegment(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokeRenderingSegment_get_BezierControlPoint1(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BezierControlPoint1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_BezierControlPoint2(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BezierControlPoint2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Position(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Pressure(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_TiltX(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_TiltY(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkStrokeRenderingSegment_get_Twist(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Twist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokeRenderingSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokeRenderingSegment[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokeRenderingSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokeRenderingSegment[] = {
        { "bezier_control_point1", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_BezierControlPoint1), nullptr, nullptr, nullptr },
        { "bezier_control_point2", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_BezierControlPoint2), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_Position), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_Pressure), nullptr, nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_TiltX), nullptr, nullptr, nullptr },
        { "tilt_y", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_TiltY), nullptr, nullptr, nullptr },
        { "twist", reinterpret_cast<getter>(InkStrokeRenderingSegment_get_Twist), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokeRenderingSegment[] = 
    {
        { Py_tp_new, _new_InkStrokeRenderingSegment },
        { Py_tp_dealloc, _dealloc_InkStrokeRenderingSegment },
        { Py_tp_methods, _methods_InkStrokeRenderingSegment },
        { Py_tp_getset, _getset_InkStrokeRenderingSegment },
        { },
    };

    static PyType_Spec _type_spec_InkStrokeRenderingSegment =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStrokeRenderingSegment",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokeRenderingSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokeRenderingSegment
    };

    // ----- InkStrokesCollectedEventArgs class --------------------
    constexpr const char* const _type_name_InkStrokesCollectedEventArgs = "InkStrokesCollectedEventArgs";

    static PyObject* _new_InkStrokesCollectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokesCollectedEventArgs);
        return nullptr;
    }

    static void _dealloc_InkStrokesCollectedEventArgs(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokesCollectedEventArgs_get_Strokes(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strokes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokesCollectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokesCollectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokesCollectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokesCollectedEventArgs[] = {
        { "strokes", reinterpret_cast<getter>(InkStrokesCollectedEventArgs_get_Strokes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokesCollectedEventArgs[] = 
    {
        { Py_tp_new, _new_InkStrokesCollectedEventArgs },
        { Py_tp_dealloc, _dealloc_InkStrokesCollectedEventArgs },
        { Py_tp_methods, _methods_InkStrokesCollectedEventArgs },
        { Py_tp_getset, _getset_InkStrokesCollectedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_InkStrokesCollectedEventArgs =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStrokesCollectedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokesCollectedEventArgs
    };

    // ----- InkStrokesErasedEventArgs class --------------------
    constexpr const char* const _type_name_InkStrokesErasedEventArgs = "InkStrokesErasedEventArgs";

    static PyObject* _new_InkStrokesErasedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkStrokesErasedEventArgs);
        return nullptr;
    }

    static void _dealloc_InkStrokesErasedEventArgs(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkStrokesErasedEventArgs_get_Strokes(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strokes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkStrokesErasedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkStrokesErasedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InkStrokesErasedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkStrokesErasedEventArgs[] = {
        { "strokes", reinterpret_cast<getter>(InkStrokesErasedEventArgs_get_Strokes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkStrokesErasedEventArgs[] = 
    {
        { Py_tp_new, _new_InkStrokesErasedEventArgs },
        { Py_tp_dealloc, _dealloc_InkStrokesErasedEventArgs },
        { Py_tp_methods, _methods_InkStrokesErasedEventArgs },
        { Py_tp_getset, _getset_InkStrokesErasedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_InkStrokesErasedEventArgs =
    {
        "_winsdk_Windows_UI_Input_Inking.InkStrokesErasedEventArgs",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkStrokesErasedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkStrokesErasedEventArgs
    };

    // ----- InkSynchronizer class --------------------
    constexpr const char* const _type_name_InkSynchronizer = "InkSynchronizer";

    static PyObject* _new_InkSynchronizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkSynchronizer);
        return nullptr;
    }

    static void _dealloc_InkSynchronizer(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkSynchronizer_BeginDry(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.BeginDry());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InkSynchronizer_EndDry(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndDry();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InkSynchronizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkSynchronizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkSynchronizer[] = {
        { "begin_dry", reinterpret_cast<PyCFunction>(InkSynchronizer_BeginDry), METH_VARARGS, nullptr },
        { "end_dry", reinterpret_cast<PyCFunction>(InkSynchronizer_EndDry), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkSynchronizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkSynchronizer[] = {
        { }
    };

    static PyType_Slot _type_slots_InkSynchronizer[] = 
    {
        { Py_tp_new, _new_InkSynchronizer },
        { Py_tp_dealloc, _dealloc_InkSynchronizer },
        { Py_tp_methods, _methods_InkSynchronizer },
        { Py_tp_getset, _getset_InkSynchronizer },
        { },
    };

    static PyType_Spec _type_spec_InkSynchronizer =
    {
        "_winsdk_Windows_UI_Input_Inking.InkSynchronizer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkSynchronizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkSynchronizer
    };

    // ----- InkUnprocessedInput class --------------------
    constexpr const char* const _type_name_InkUnprocessedInput = "InkUnprocessedInput";

    static PyObject* _new_InkUnprocessedInput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InkUnprocessedInput);
        return nullptr;
    }

    static void _dealloc_InkUnprocessedInput(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InkUnprocessedInput_get_InkPresenter(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InkPresenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerEntered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerEntered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerExited(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerExited(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerHovered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerHovered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerHovered(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerHovered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerLost(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerLost(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerMoved(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerMoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerMoved(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerMoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerPressed(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerPressed(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_add_PointerReleased(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Input::Inking::InkUnprocessedInput, winrt::Windows::UI::Core::PointerEventArgs>>(arg);

            return py::convert(self->obj.PointerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InkUnprocessedInput_remove_PointerReleased(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PointerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InkUnprocessedInput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InkUnprocessedInput[] = {
        { "add_pointer_entered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerEntered), METH_O, nullptr },
        { "remove_pointer_entered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerEntered), METH_O, nullptr },
        { "add_pointer_exited", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerExited), METH_O, nullptr },
        { "remove_pointer_exited", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerExited), METH_O, nullptr },
        { "add_pointer_hovered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerHovered), METH_O, nullptr },
        { "remove_pointer_hovered", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerHovered), METH_O, nullptr },
        { "add_pointer_lost", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerLost), METH_O, nullptr },
        { "remove_pointer_lost", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerLost), METH_O, nullptr },
        { "add_pointer_moved", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerMoved), METH_O, nullptr },
        { "remove_pointer_moved", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerMoved), METH_O, nullptr },
        { "add_pointer_pressed", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerPressed), METH_O, nullptr },
        { "remove_pointer_pressed", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerPressed), METH_O, nullptr },
        { "add_pointer_released", reinterpret_cast<PyCFunction>(InkUnprocessedInput_add_PointerReleased), METH_O, nullptr },
        { "remove_pointer_released", reinterpret_cast<PyCFunction>(InkUnprocessedInput_remove_PointerReleased), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InkUnprocessedInput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InkUnprocessedInput[] = {
        { "ink_presenter", reinterpret_cast<getter>(InkUnprocessedInput_get_InkPresenter), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InkUnprocessedInput[] = 
    {
        { Py_tp_new, _new_InkUnprocessedInput },
        { Py_tp_dealloc, _dealloc_InkUnprocessedInput },
        { Py_tp_methods, _methods_InkUnprocessedInput },
        { Py_tp_getset, _getset_InkUnprocessedInput },
        { },
    };

    static PyType_Spec _type_spec_InkUnprocessedInput =
    {
        "_winsdk_Windows_UI_Input_Inking.InkUnprocessedInput",
        sizeof(py::wrapper::Windows::UI::Input::Inking::InkUnprocessedInput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InkUnprocessedInput
    };

    // ----- PenAndInkSettings class --------------------
    constexpr const char* const _type_name_PenAndInkSettings = "PenAndInkSettings";

    static PyObject* _new_PenAndInkSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PenAndInkSettings);
        return nullptr;
    }

    static void _dealloc_PenAndInkSettings(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PenAndInkSettings_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::Inking::PenAndInkSettings::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_SetPenHandedness(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::PenHandedness>(args, 0);

                self->obj.SetPenHandedness(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_FontFamilyName(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_HandwritingLineHeight(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HandwritingLineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_IsHandwritingDirectlyIntoTextFieldEnabled(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHandwritingDirectlyIntoTextFieldEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_IsTouchHandwritingEnabled(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTouchHandwritingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_PenHandedness(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenHandedness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PenAndInkSettings_get_UserConsentsToHandwritingTelemetryCollection(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserConsentsToHandwritingTelemetryCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PenAndInkSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::PenAndInkSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PenAndInkSettings[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PenAndInkSettings_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "set_pen_handedness", reinterpret_cast<PyCFunction>(PenAndInkSettings_SetPenHandedness), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PenAndInkSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PenAndInkSettings[] = {
        { "font_family_name", reinterpret_cast<getter>(PenAndInkSettings_get_FontFamilyName), nullptr, nullptr, nullptr },
        { "handwriting_line_height", reinterpret_cast<getter>(PenAndInkSettings_get_HandwritingLineHeight), nullptr, nullptr, nullptr },
        { "is_handwriting_directly_into_text_field_enabled", reinterpret_cast<getter>(PenAndInkSettings_get_IsHandwritingDirectlyIntoTextFieldEnabled), nullptr, nullptr, nullptr },
        { "is_touch_handwriting_enabled", reinterpret_cast<getter>(PenAndInkSettings_get_IsTouchHandwritingEnabled), nullptr, nullptr, nullptr },
        { "pen_handedness", reinterpret_cast<getter>(PenAndInkSettings_get_PenHandedness), nullptr, nullptr, nullptr },
        { "user_consents_to_handwriting_telemetry_collection", reinterpret_cast<getter>(PenAndInkSettings_get_UserConsentsToHandwritingTelemetryCollection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PenAndInkSettings[] = 
    {
        { Py_tp_new, _new_PenAndInkSettings },
        { Py_tp_dealloc, _dealloc_PenAndInkSettings },
        { Py_tp_methods, _methods_PenAndInkSettings },
        { Py_tp_getset, _getset_PenAndInkSettings },
        { },
    };

    static PyType_Spec _type_spec_PenAndInkSettings =
    {
        "_winsdk_Windows_UI_Input_Inking.PenAndInkSettings",
        sizeof(py::wrapper::Windows::UI::Input::Inking::PenAndInkSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PenAndInkSettings
    };

    // ----- IInkPointFactory interface --------------------
    constexpr const char* const _type_name_IInkPointFactory = "IInkPointFactory";

    static PyObject* _new_IInkPointFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkPointFactory);
        return nullptr;
    }

    static void _dealloc_IInkPointFactory(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkPointFactory_CreateInkPoint(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                return py::convert(self->obj.CreateInkPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInkPointFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPointFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPointFactory[] = {
        { "create_ink_point", reinterpret_cast<PyCFunction>(IInkPointFactory_CreateInkPoint), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkPointFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkPointFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IInkPointFactory[] = 
    {
        { Py_tp_new, _new_IInkPointFactory },
        { Py_tp_dealloc, _dealloc_IInkPointFactory },
        { Py_tp_methods, _methods_IInkPointFactory },
        { Py_tp_getset, _getset_IInkPointFactory },
        { },
    };

    static PyType_Spec _type_spec_IInkPointFactory =
    {
        "_winsdk_Windows_UI_Input_Inking.IInkPointFactory",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPointFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPointFactory
    };

    // ----- IInkPresenterRulerFactory interface --------------------
    constexpr const char* const _type_name_IInkPresenterRulerFactory = "IInkPresenterRulerFactory";

    static PyObject* _new_IInkPresenterRulerFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkPresenterRulerFactory);
        return nullptr;
    }

    static void _dealloc_IInkPresenterRulerFactory(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkPresenterRulerFactory_Create(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkPresenter>(args, 0);

                return py::convert(self->obj.Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInkPresenterRulerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPresenterRulerFactory[] = {
        { "create", reinterpret_cast<PyCFunction>(IInkPresenterRulerFactory_Create), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkPresenterRulerFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkPresenterRulerFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IInkPresenterRulerFactory[] = 
    {
        { Py_tp_new, _new_IInkPresenterRulerFactory },
        { Py_tp_dealloc, _dealloc_IInkPresenterRulerFactory },
        { Py_tp_methods, _methods_IInkPresenterRulerFactory },
        { Py_tp_getset, _getset_IInkPresenterRulerFactory },
        { },
    };

    static PyType_Spec _type_spec_IInkPresenterRulerFactory =
    {
        "_winsdk_Windows_UI_Input_Inking.IInkPresenterRulerFactory",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPresenterRulerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPresenterRulerFactory
    };

    // ----- IInkPresenterStencil interface --------------------
    constexpr const char* const _type_name_IInkPresenterStencil = "IInkPresenterStencil";

    static PyObject* _new_IInkPresenterStencil(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkPresenterStencil);
        return nullptr;
    }

    static void _dealloc_IInkPresenterStencil(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkPresenterStencil_get_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_BackgroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_ForegroundColor(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_IsVisible(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_IsVisible(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IInkPresenterStencil_get_Kind(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IInkPresenterStencil_get_Transform(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IInkPresenterStencil_put_Transform(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3x2>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IInkPresenterStencil(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkPresenterStencil[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkPresenterStencil), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkPresenterStencil[] = {
        { "background_color", reinterpret_cast<getter>(IInkPresenterStencil_get_BackgroundColor), reinterpret_cast<setter>(IInkPresenterStencil_put_BackgroundColor), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(IInkPresenterStencil_get_ForegroundColor), reinterpret_cast<setter>(IInkPresenterStencil_put_ForegroundColor), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(IInkPresenterStencil_get_IsVisible), reinterpret_cast<setter>(IInkPresenterStencil_put_IsVisible), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IInkPresenterStencil_get_Kind), nullptr, nullptr, nullptr },
        { "transform", reinterpret_cast<getter>(IInkPresenterStencil_get_Transform), reinterpret_cast<setter>(IInkPresenterStencil_put_Transform), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IInkPresenterStencil[] = 
    {
        { Py_tp_new, _new_IInkPresenterStencil },
        { Py_tp_dealloc, _dealloc_IInkPresenterStencil },
        { Py_tp_methods, _methods_IInkPresenterStencil },
        { Py_tp_getset, _getset_IInkPresenterStencil },
        { },
    };

    static PyType_Spec _type_spec_IInkPresenterStencil =
    {
        "_winsdk_Windows_UI_Input_Inking.IInkPresenterStencil",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkPresenterStencil),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkPresenterStencil
    };

    // ----- IInkRecognizerContainer interface --------------------
    constexpr const char* const _type_name_IInkRecognizerContainer = "IInkRecognizerContainer";

    static PyObject* _new_IInkRecognizerContainer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkRecognizerContainer);
        return nullptr;
    }

    static void _dealloc_IInkRecognizerContainer(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkRecognizerContainer_GetRecognizers(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognizers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkRecognizerContainer_RecognizeAsync(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStrokeContainer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognitionTarget>(args, 1);

                return py::convert(self->obj.RecognizeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkRecognizerContainer_SetDefaultRecognizer(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkRecognizer>(args, 0);

                self->obj.SetDefaultRecognizer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IInkRecognizerContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkRecognizerContainer[] = {
        { "get_recognizers", reinterpret_cast<PyCFunction>(IInkRecognizerContainer_GetRecognizers), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(IInkRecognizerContainer_RecognizeAsync), METH_VARARGS, nullptr },
        { "set_default_recognizer", reinterpret_cast<PyCFunction>(IInkRecognizerContainer_SetDefaultRecognizer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkRecognizerContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkRecognizerContainer[] = {
        { }
    };

    static PyType_Slot _type_slots_IInkRecognizerContainer[] = 
    {
        { Py_tp_new, _new_IInkRecognizerContainer },
        { Py_tp_dealloc, _dealloc_IInkRecognizerContainer },
        { Py_tp_methods, _methods_IInkRecognizerContainer },
        { Py_tp_getset, _getset_IInkRecognizerContainer },
        { },
    };

    static PyType_Spec _type_spec_IInkRecognizerContainer =
    {
        "_winsdk_Windows_UI_Input_Inking.IInkRecognizerContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkRecognizerContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkRecognizerContainer
    };

    // ----- IInkStrokeContainer interface --------------------
    constexpr const char* const _type_name_IInkStrokeContainer = "IInkStrokeContainer";

    static PyObject* _new_IInkStrokeContainer(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IInkStrokeContainer);
        return nullptr;
    }

    static void _dealloc_IInkStrokeContainer(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IInkStrokeContainer_AddStroke(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Inking::InkStroke>(args, 0);

                self->obj.AddStroke(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_CanPasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CanPasteFromClipboard());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_CopySelectedToClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CopySelectedToClipboard();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_DeleteSelected(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteSelected());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_GetRecognitionResults(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecognitionResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_GetStrokes(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStrokes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_LoadAsync(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_MoveSelected(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.MoveSelected(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_PasteFromClipboard(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.PasteFromClipboard(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SaveAsync(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                return py::convert(self->obj.SaveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SelectWithLine(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.SelectWithLine(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_SelectWithPolyLine(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Point>>(args, 0);

                return py::convert(self->obj.SelectWithPolyLine(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_UpdateRecognitionResults(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::Windows::UI::Input::Inking::InkRecognitionResult>>(args, 0);

                self->obj.UpdateRecognitionResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInkStrokeContainer_get_BoundingRect(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundingRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IInkStrokeContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInkStrokeContainer[] = {
        { "add_stroke", reinterpret_cast<PyCFunction>(IInkStrokeContainer_AddStroke), METH_VARARGS, nullptr },
        { "can_paste_from_clipboard", reinterpret_cast<PyCFunction>(IInkStrokeContainer_CanPasteFromClipboard), METH_VARARGS, nullptr },
        { "copy_selected_to_clipboard", reinterpret_cast<PyCFunction>(IInkStrokeContainer_CopySelectedToClipboard), METH_VARARGS, nullptr },
        { "delete_selected", reinterpret_cast<PyCFunction>(IInkStrokeContainer_DeleteSelected), METH_VARARGS, nullptr },
        { "get_recognition_results", reinterpret_cast<PyCFunction>(IInkStrokeContainer_GetRecognitionResults), METH_VARARGS, nullptr },
        { "get_strokes", reinterpret_cast<PyCFunction>(IInkStrokeContainer_GetStrokes), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(IInkStrokeContainer_LoadAsync), METH_VARARGS, nullptr },
        { "move_selected", reinterpret_cast<PyCFunction>(IInkStrokeContainer_MoveSelected), METH_VARARGS, nullptr },
        { "paste_from_clipboard", reinterpret_cast<PyCFunction>(IInkStrokeContainer_PasteFromClipboard), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(IInkStrokeContainer_SaveAsync), METH_VARARGS, nullptr },
        { "select_with_line", reinterpret_cast<PyCFunction>(IInkStrokeContainer_SelectWithLine), METH_VARARGS, nullptr },
        { "select_with_poly_line", reinterpret_cast<PyCFunction>(IInkStrokeContainer_SelectWithPolyLine), METH_VARARGS, nullptr },
        { "update_recognition_results", reinterpret_cast<PyCFunction>(IInkStrokeContainer_UpdateRecognitionResults), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInkStrokeContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInkStrokeContainer[] = {
        { "bounding_rect", reinterpret_cast<getter>(IInkStrokeContainer_get_BoundingRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IInkStrokeContainer[] = 
    {
        { Py_tp_new, _new_IInkStrokeContainer },
        { Py_tp_dealloc, _dealloc_IInkStrokeContainer },
        { Py_tp_methods, _methods_IInkStrokeContainer },
        { Py_tp_getset, _getset_IInkStrokeContainer },
        { },
    };

    static PyType_Spec _type_spec_IInkStrokeContainer =
    {
        "_winsdk_Windows_UI_Input_Inking.IInkStrokeContainer",
        sizeof(py::wrapper::Windows::UI::Input::Inking::IInkStrokeContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInkStrokeContainer
    };

    // ----- Windows.UI.Input.Inking Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributes>::python_type = py::register_python_type(module, _type_name_InkDrawingAttributes, &_type_spec_InkDrawingAttributes, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkDrawingAttributesPencilProperties>::python_type = py::register_python_type(module, _type_name_InkDrawingAttributesPencilProperties, &_type_spec_InkDrawingAttributesPencilProperties, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputConfiguration>::python_type = py::register_python_type(module, _type_name_InkInputConfiguration, &_type_spec_InkInputConfiguration, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkInputProcessingConfiguration>::python_type = py::register_python_type(module, _type_name_InkInputProcessingConfiguration, &_type_spec_InkInputProcessingConfiguration, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkManager>::python_type = py::register_python_type(module, _type_name_InkManager, &_type_spec_InkManager, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkModelerAttributes>::python_type = py::register_python_type(module, _type_name_InkModelerAttributes, &_type_spec_InkModelerAttributes, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPoint>::python_type = py::register_python_type(module, _type_name_InkPoint, &_type_spec_InkPoint, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenter>::python_type = py::register_python_type(module, _type_name_InkPresenter, &_type_spec_InkPresenter, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterProtractor>::python_type = py::register_python_type(module, _type_name_InkPresenterProtractor, &_type_spec_InkPresenterProtractor, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkPresenterRuler>::python_type = py::register_python_type(module, _type_name_InkPresenterRuler, &_type_spec_InkPresenterRuler, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognitionResult>::python_type = py::register_python_type(module, _type_name_InkRecognitionResult, &_type_spec_InkRecognitionResult, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizer>::python_type = py::register_python_type(module, _type_name_InkRecognizer, &_type_spec_InkRecognizer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkRecognizerContainer>::python_type = py::register_python_type(module, _type_name_InkRecognizerContainer, &_type_spec_InkRecognizerContainer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStroke>::python_type = py::register_python_type(module, _type_name_InkStroke, &_type_spec_InkStroke, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeBuilder>::python_type = py::register_python_type(module, _type_name_InkStrokeBuilder, &_type_spec_InkStrokeBuilder, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeContainer>::python_type = py::register_python_type(module, _type_name_InkStrokeContainer, &_type_spec_InkStrokeContainer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeInput>::python_type = py::register_python_type(module, _type_name_InkStrokeInput, &_type_spec_InkStrokeInput, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokeRenderingSegment>::python_type = py::register_python_type(module, _type_name_InkStrokeRenderingSegment, &_type_spec_InkStrokeRenderingSegment, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesCollectedEventArgs>::python_type = py::register_python_type(module, _type_name_InkStrokesCollectedEventArgs, &_type_spec_InkStrokesCollectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkStrokesErasedEventArgs>::python_type = py::register_python_type(module, _type_name_InkStrokesErasedEventArgs, &_type_spec_InkStrokesErasedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkSynchronizer>::python_type = py::register_python_type(module, _type_name_InkSynchronizer, &_type_spec_InkSynchronizer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::InkUnprocessedInput>::python_type = py::register_python_type(module, _type_name_InkUnprocessedInput, &_type_spec_InkUnprocessedInput, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::PenAndInkSettings>::python_type = py::register_python_type(module, _type_name_PenAndInkSettings, &_type_spec_PenAndInkSettings, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPointFactory>::python_type = py::register_python_type(module, _type_name_IInkPointFactory, &_type_spec_IInkPointFactory, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterRulerFactory>::python_type = py::register_python_type(module, _type_name_IInkPresenterRulerFactory, &_type_spec_IInkPresenterRulerFactory, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkPresenterStencil>::python_type = py::register_python_type(module, _type_name_IInkPresenterStencil, &_type_spec_IInkPresenterStencil, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkRecognizerContainer>::python_type = py::register_python_type(module, _type_name_IInkRecognizerContainer, &_type_spec_IInkRecognizerContainer, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Inking::IInkStrokeContainer>::python_type = py::register_python_type(module, _type_name_IInkStrokeContainer, &_type_spec_IInkStrokeContainer, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.UI.Input.Inking");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Input_Inking",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::UI::Input::Inking

PyMODINIT_FUNC
PyInit__winsdk_Windows_UI_Input_Inking (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::UI::Input::Inking::module_def);
}
