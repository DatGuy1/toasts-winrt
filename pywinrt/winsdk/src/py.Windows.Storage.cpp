// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

#include "pybase.h"
#include "py.Windows.Storage.h"

PyTypeObject* py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::FileIO>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::PathIO>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type;

namespace py::cpp::Windows::Storage
{
    // ----- AppDataPaths class --------------------
    constexpr const char* const _type_name_AppDataPaths = "AppDataPaths";

    static PyObject* _new_AppDataPaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDataPaths);
        return nullptr;
    }

    static void _dealloc_AppDataPaths(py::wrapper::Windows::Storage::AppDataPaths* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::AppDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::AppDataPaths::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Cookies(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cookies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Desktop(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Documents(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Documents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_Favorites(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Favorites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_History(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_InternetCache(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InternetCache());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_ProgramData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgramData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::AppDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::AppDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDataPaths[] = {
        { "get_default", reinterpret_cast<PyCFunction>(AppDataPaths_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(AppDataPaths_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDataPaths), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDataPaths[] = {
        { "cookies", reinterpret_cast<getter>(AppDataPaths_get_Cookies), nullptr, nullptr, nullptr },
        { "desktop", reinterpret_cast<getter>(AppDataPaths_get_Desktop), nullptr, nullptr, nullptr },
        { "documents", reinterpret_cast<getter>(AppDataPaths_get_Documents), nullptr, nullptr, nullptr },
        { "favorites", reinterpret_cast<getter>(AppDataPaths_get_Favorites), nullptr, nullptr, nullptr },
        { "history", reinterpret_cast<getter>(AppDataPaths_get_History), nullptr, nullptr, nullptr },
        { "internet_cache", reinterpret_cast<getter>(AppDataPaths_get_InternetCache), nullptr, nullptr, nullptr },
        { "local_app_data", reinterpret_cast<getter>(AppDataPaths_get_LocalAppData), nullptr, nullptr, nullptr },
        { "program_data", reinterpret_cast<getter>(AppDataPaths_get_ProgramData), nullptr, nullptr, nullptr },
        { "roaming_app_data", reinterpret_cast<getter>(AppDataPaths_get_RoamingAppData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDataPaths[] = 
    {
        { Py_tp_new, _new_AppDataPaths },
        { Py_tp_dealloc, _dealloc_AppDataPaths },
        { Py_tp_methods, _methods_AppDataPaths },
        { Py_tp_getset, _getset_AppDataPaths },
        { },
    };

    static PyType_Spec _type_spec_AppDataPaths =
    {
        "_winsdk_Windows_Storage.AppDataPaths",
        sizeof(py::wrapper::Windows::Storage::AppDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDataPaths
    };

    // ----- ApplicationData class --------------------
    constexpr const char* const _type_name_ApplicationData = "ApplicationData";

    static PyObject* _new_ApplicationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationData);
        return nullptr;
    }

    static void _dealloc_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationData_ClearAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::ApplicationDataLocality>(args, 0);

                return py::convert(self->obj.ClearAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_ClearPublisherCacheFolderAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ClearPublisherCacheFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_Close(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::ApplicationData::GetForUserAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_GetPublisherCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPublisherCacheFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SetVersionAsync(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataSetVersionHandler>(args, 1);

                return py::convert(self->obj.SetVersionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_SignalDataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.SignalDataChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingSettings(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_RoamingStorageQuota(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingStorageQuota());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_TemporaryFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TemporaryFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Version(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_LocalCacheFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalCacheFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_SharedLocalFolder(py::wrapper::Windows::Storage::ApplicationData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharedLocalFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::ApplicationData::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_add_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::ApplicationData, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DataChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationData_remove_DataChanged(py::wrapper::Windows::Storage::ApplicationData* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ApplicationData(py::wrapper::Windows::Storage::ApplicationData* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationData[] = {
        { "clear_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearAsync), METH_VARARGS, nullptr },
        { "clear_publisher_cache_folder_async", reinterpret_cast<PyCFunction>(ApplicationData_ClearPublisherCacheFolderAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ApplicationData_Close), METH_VARARGS, nullptr },
        { "get_for_user_async", reinterpret_cast<PyCFunction>(ApplicationData_GetForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_publisher_cache_folder", reinterpret_cast<PyCFunction>(ApplicationData_GetPublisherCacheFolder), METH_VARARGS, nullptr },
        { "set_version_async", reinterpret_cast<PyCFunction>(ApplicationData_SetVersionAsync), METH_VARARGS, nullptr },
        { "signal_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_SignalDataChanged), METH_VARARGS, nullptr },
        { "get_current", reinterpret_cast<PyCFunction>(ApplicationData_get_Current), METH_NOARGS | METH_STATIC, nullptr },
        { "add_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_add_DataChanged), METH_O, nullptr },
        { "remove_data_changed", reinterpret_cast<PyCFunction>(ApplicationData_remove_DataChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationData), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ApplicationData), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ApplicationData), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationData[] = {
        { "local_folder", reinterpret_cast<getter>(ApplicationData_get_LocalFolder), nullptr, nullptr, nullptr },
        { "local_settings", reinterpret_cast<getter>(ApplicationData_get_LocalSettings), nullptr, nullptr, nullptr },
        { "roaming_folder", reinterpret_cast<getter>(ApplicationData_get_RoamingFolder), nullptr, nullptr, nullptr },
        { "roaming_settings", reinterpret_cast<getter>(ApplicationData_get_RoamingSettings), nullptr, nullptr, nullptr },
        { "roaming_storage_quota", reinterpret_cast<getter>(ApplicationData_get_RoamingStorageQuota), nullptr, nullptr, nullptr },
        { "temporary_folder", reinterpret_cast<getter>(ApplicationData_get_TemporaryFolder), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(ApplicationData_get_Version), nullptr, nullptr, nullptr },
        { "local_cache_folder", reinterpret_cast<getter>(ApplicationData_get_LocalCacheFolder), nullptr, nullptr, nullptr },
        { "shared_local_folder", reinterpret_cast<getter>(ApplicationData_get_SharedLocalFolder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationData[] = 
    {
        { Py_tp_new, _new_ApplicationData },
        { Py_tp_dealloc, _dealloc_ApplicationData },
        { Py_tp_methods, _methods_ApplicationData },
        { Py_tp_getset, _getset_ApplicationData },
        { },
    };

    static PyType_Spec _type_spec_ApplicationData =
    {
        "_winsdk_Windows_Storage.ApplicationData",
        sizeof(py::wrapper::Windows::Storage::ApplicationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationData
    };

    // ----- ApplicationDataCompositeValue class --------------------
    constexpr const char* const _type_name_ApplicationDataCompositeValue = "ApplicationDataCompositeValue";

    static PyObject* _new_ApplicationDataCompositeValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::ApplicationDataCompositeValue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationDataCompositeValue_Clear(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_First(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_GetView(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_HasKey(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Insert(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Lookup(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_Remove(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_get_Size(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataCompositeValue_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationDataCompositeValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataCompositeValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataCompositeValue(py::wrapper::Windows::Storage::ApplicationDataCompositeValue* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataCompositeValue[] = {
        { "clear", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_Remove), METH_VARARGS, nullptr },
        { "add_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_add_MapChanged), METH_O, nullptr },
        { "remove_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataCompositeValue_remove_MapChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataCompositeValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationDataCompositeValue[] = {
        { "size", reinterpret_cast<getter>(ApplicationDataCompositeValue_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationDataCompositeValue[] = 
    {
        { Py_tp_new, _new_ApplicationDataCompositeValue },
        { Py_tp_dealloc, _dealloc_ApplicationDataCompositeValue },
        { Py_tp_methods, _methods_ApplicationDataCompositeValue },
        { Py_tp_getset, _getset_ApplicationDataCompositeValue },
        { Py_tp_iter, _iterator_ApplicationDataCompositeValue },
        { Py_sq_contains, _map_contains_ApplicationDataCompositeValue },
        { Py_mp_length, _map_length_ApplicationDataCompositeValue },
        { Py_mp_subscript, _map_subscript_ApplicationDataCompositeValue },
        { Py_mp_ass_subscript, _map_assign_ApplicationDataCompositeValue },
        { },
    };

    static PyType_Spec _type_spec_ApplicationDataCompositeValue =
    {
        "_winsdk_Windows_Storage.ApplicationDataCompositeValue",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataCompositeValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataCompositeValue
    };

    // ----- ApplicationDataContainer class --------------------
    constexpr const char* const _type_name_ApplicationDataContainer = "ApplicationDataContainer";

    static PyObject* _new_ApplicationDataContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationDataContainer);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationDataContainer_Close(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_CreateContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::ApplicationDataCreateDisposition>(args, 1);

                return py::convert(self->obj.CreateContainer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_DeleteContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DeleteContainer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Containers(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Containers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Locality(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Name(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainer_get_Values(py::wrapper::Windows::Storage::ApplicationDataContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationDataContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ApplicationDataContainer(py::wrapper::Windows::Storage::ApplicationDataContainer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainer[] = {
        { "close", reinterpret_cast<PyCFunction>(ApplicationDataContainer_Close), METH_VARARGS, nullptr },
        { "create_container", reinterpret_cast<PyCFunction>(ApplicationDataContainer_CreateContainer), METH_VARARGS, nullptr },
        { "delete_container", reinterpret_cast<PyCFunction>(ApplicationDataContainer_DeleteContainer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataContainer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ApplicationDataContainer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ApplicationDataContainer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationDataContainer[] = {
        { "containers", reinterpret_cast<getter>(ApplicationDataContainer_get_Containers), nullptr, nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ApplicationDataContainer_get_Locality), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ApplicationDataContainer_get_Name), nullptr, nullptr, nullptr },
        { "values", reinterpret_cast<getter>(ApplicationDataContainer_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationDataContainer[] = 
    {
        { Py_tp_new, _new_ApplicationDataContainer },
        { Py_tp_dealloc, _dealloc_ApplicationDataContainer },
        { Py_tp_methods, _methods_ApplicationDataContainer },
        { Py_tp_getset, _getset_ApplicationDataContainer },
        { },
    };

    static PyType_Spec _type_spec_ApplicationDataContainer =
    {
        "_winsdk_Windows_Storage.ApplicationDataContainer",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainer
    };

    // ----- ApplicationDataContainerSettings class --------------------
    constexpr const char* const _type_name_ApplicationDataContainerSettings = "ApplicationDataContainerSettings";

    static PyObject* _new_ApplicationDataContainerSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ApplicationDataContainerSettings);
        return nullptr;
    }

    static void _dealloc_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ApplicationDataContainerSettings_Clear(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_First(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_GetView(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_HasKey(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Insert(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Lookup(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_Remove(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_get_Size(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_add_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::MapChangedEventHandler<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MapChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationDataContainerSettings_remove_MapChanged(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MapChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationDataContainerSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::ApplicationDataContainerSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_ApplicationDataContainerSettings(py::wrapper::Windows::Storage::ApplicationDataContainerSettings* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_ApplicationDataContainerSettings[] = {
        { "clear", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_Remove), METH_VARARGS, nullptr },
        { "add_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_add_MapChanged), METH_O, nullptr },
        { "remove_map_changed", reinterpret_cast<PyCFunction>(ApplicationDataContainerSettings_remove_MapChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationDataContainerSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationDataContainerSettings[] = {
        { "size", reinterpret_cast<getter>(ApplicationDataContainerSettings_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationDataContainerSettings[] = 
    {
        { Py_tp_new, _new_ApplicationDataContainerSettings },
        { Py_tp_dealloc, _dealloc_ApplicationDataContainerSettings },
        { Py_tp_methods, _methods_ApplicationDataContainerSettings },
        { Py_tp_getset, _getset_ApplicationDataContainerSettings },
        { Py_tp_iter, _iterator_ApplicationDataContainerSettings },
        { Py_sq_contains, _map_contains_ApplicationDataContainerSettings },
        { Py_mp_length, _map_length_ApplicationDataContainerSettings },
        { Py_mp_subscript, _map_subscript_ApplicationDataContainerSettings },
        { Py_mp_ass_subscript, _map_assign_ApplicationDataContainerSettings },
        { },
    };

    static PyType_Spec _type_spec_ApplicationDataContainerSettings =
    {
        "_winsdk_Windows_Storage.ApplicationDataContainerSettings",
        sizeof(py::wrapper::Windows::Storage::ApplicationDataContainerSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationDataContainerSettings
    };

    // ----- CachedFileManager class --------------------
    constexpr const char* const _type_name_CachedFileManager = "CachedFileManager";

    static PyObject* _new_CachedFileManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileManager);
        return nullptr;
    }

    static PyObject* CachedFileManager_CompleteUpdatesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::CachedFileManager::CompleteUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileManager_DeferUpdates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                winrt::Windows::Storage::CachedFileManager::DeferUpdates(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileManager[] = {
        { "complete_updates_async", reinterpret_cast<PyCFunction>(CachedFileManager_CompleteUpdatesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "defer_updates", reinterpret_cast<PyCFunction>(CachedFileManager_DeferUpdates), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileManager[] = 
    {
        { Py_tp_new, _new_CachedFileManager },
        { Py_tp_methods, _methods_CachedFileManager },
        { Py_tp_getset, _getset_CachedFileManager },
        { },
    };

    static PyType_Spec _type_spec_CachedFileManager =
    {
        "_winsdk_Windows_Storage.CachedFileManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileManager
    };

    // ----- DownloadsFolder class --------------------
    constexpr const char* const _type_name_DownloadsFolder = "DownloadsFolder";

    static PyObject* _new_DownloadsFolder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DownloadsFolder);
        return nullptr;
    }

    static PyObject* DownloadsFolder_CreateFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFileForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFileForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadsFolder_CreateFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 2);

                return py::convert(winrt::Windows::Storage::DownloadsFolder::CreateFolderForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadsFolder[] = {
        { "create_file_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_file_for_user_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFileForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_folder_for_user_async", reinterpret_cast<PyCFunction>(DownloadsFolder_CreateFolderForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DownloadsFolder[] = {
        { }
    };

    static PyType_Slot _type_slots_DownloadsFolder[] = 
    {
        { Py_tp_new, _new_DownloadsFolder },
        { Py_tp_methods, _methods_DownloadsFolder },
        { Py_tp_getset, _getset_DownloadsFolder },
        { },
    };

    static PyType_Spec _type_spec_DownloadsFolder =
    {
        "_winsdk_Windows_Storage.DownloadsFolder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadsFolder
    };

    // ----- FileIO class --------------------
    constexpr const char* const _type_name_FileIO = "FileIO";

    static PyObject* _new_FileIO(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileIO);
        return nullptr;
    }

    static PyObject* FileIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::AppendLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::AppendTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadLinesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::ReadLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::FileIO::ReadTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::ReadTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteBufferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteBytesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::WriteLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::FileIO::WriteTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileIO[] = {
        { "append_lines_async", reinterpret_cast<PyCFunction>(FileIO_AppendLinesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "append_text_async", reinterpret_cast<PyCFunction>(FileIO_AppendTextAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "read_buffer_async", reinterpret_cast<PyCFunction>(FileIO_ReadBufferAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "read_lines_async", reinterpret_cast<PyCFunction>(FileIO_ReadLinesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "read_text_async", reinterpret_cast<PyCFunction>(FileIO_ReadTextAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_buffer_async", reinterpret_cast<PyCFunction>(FileIO_WriteBufferAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_bytes_async", reinterpret_cast<PyCFunction>(FileIO_WriteBytesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_lines_async", reinterpret_cast<PyCFunction>(FileIO_WriteLinesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_text_async", reinterpret_cast<PyCFunction>(FileIO_WriteTextAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileIO[] = {
        { }
    };

    static PyType_Slot _type_slots_FileIO[] = 
    {
        { Py_tp_new, _new_FileIO },
        { Py_tp_methods, _methods_FileIO },
        { Py_tp_getset, _getset_FileIO },
        { },
    };

    static PyType_Spec _type_spec_FileIO =
    {
        "_winsdk_Windows_Storage.FileIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileIO
    };

    // ----- KnownFolders class --------------------
    constexpr const char* const _type_name_KnownFolders = "KnownFolders";

    static PyObject* _new_KnownFolders(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownFolders);
        return nullptr;
    }

    static PyObject* KnownFolders_GetFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert(winrt::Windows::Storage::KnownFolders::GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_GetFolderForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert(winrt::Windows::Storage::KnownFolders::GetFolderForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 0);

                return py::convert(winrt::Windows::Storage::KnownFolders::RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_RequestAccessForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownFolderId>(args, 1);

                return py::convert(winrt::Windows::Storage::KnownFolders::RequestAccessForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_CameraRoll(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::CameraRoll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Playlists(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::Playlists());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_SavedPictures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::SavedPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_DocumentsLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::DocumentsLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_HomeGroup(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::HomeGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MediaServerDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::MediaServerDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_MusicLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::MusicLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_PicturesLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::PicturesLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RemovableDevices(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::RemovableDevices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_VideosLibrary(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::VideosLibrary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_AppCaptures(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::AppCaptures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_Objects3D(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::Objects3D());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownFolders_get_RecordedCalls(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::KnownFolders::RecordedCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownFolders[] = {
        { "get_folder_async", reinterpret_cast<PyCFunction>(KnownFolders_GetFolderAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_folder_for_user_async", reinterpret_cast<PyCFunction>(KnownFolders_GetFolderForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(KnownFolders_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_for_user_async", reinterpret_cast<PyCFunction>(KnownFolders_RequestAccessForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_camera_roll", reinterpret_cast<PyCFunction>(KnownFolders_get_CameraRoll), METH_NOARGS | METH_STATIC, nullptr },
        { "get_playlists", reinterpret_cast<PyCFunction>(KnownFolders_get_Playlists), METH_NOARGS | METH_STATIC, nullptr },
        { "get_saved_pictures", reinterpret_cast<PyCFunction>(KnownFolders_get_SavedPictures), METH_NOARGS | METH_STATIC, nullptr },
        { "get_documents_library", reinterpret_cast<PyCFunction>(KnownFolders_get_DocumentsLibrary), METH_NOARGS | METH_STATIC, nullptr },
        { "get_home_group", reinterpret_cast<PyCFunction>(KnownFolders_get_HomeGroup), METH_NOARGS | METH_STATIC, nullptr },
        { "get_media_server_devices", reinterpret_cast<PyCFunction>(KnownFolders_get_MediaServerDevices), METH_NOARGS | METH_STATIC, nullptr },
        { "get_music_library", reinterpret_cast<PyCFunction>(KnownFolders_get_MusicLibrary), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pictures_library", reinterpret_cast<PyCFunction>(KnownFolders_get_PicturesLibrary), METH_NOARGS | METH_STATIC, nullptr },
        { "get_removable_devices", reinterpret_cast<PyCFunction>(KnownFolders_get_RemovableDevices), METH_NOARGS | METH_STATIC, nullptr },
        { "get_videos_library", reinterpret_cast<PyCFunction>(KnownFolders_get_VideosLibrary), METH_NOARGS | METH_STATIC, nullptr },
        { "get_app_captures", reinterpret_cast<PyCFunction>(KnownFolders_get_AppCaptures), METH_NOARGS | METH_STATIC, nullptr },
        { "get_objects3_d", reinterpret_cast<PyCFunction>(KnownFolders_get_Objects3D), METH_NOARGS | METH_STATIC, nullptr },
        { "get_recorded_calls", reinterpret_cast<PyCFunction>(KnownFolders_get_RecordedCalls), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownFolders[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownFolders[] = 
    {
        { Py_tp_new, _new_KnownFolders },
        { Py_tp_methods, _methods_KnownFolders },
        { Py_tp_getset, _getset_KnownFolders },
        { },
    };

    static PyType_Spec _type_spec_KnownFolders =
    {
        "_winsdk_Windows_Storage.KnownFolders",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownFolders
    };

    // ----- PathIO class --------------------
    constexpr const char* const _type_name_PathIO = "PathIO";

    static PyObject* _new_PathIO(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PathIO);
        return nullptr;
    }

    static PyObject* PathIO_AppendLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::AppendLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_AppendTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::AppendTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadBufferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadLinesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::ReadLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_ReadTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::PathIO::ReadTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::ReadTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBufferAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteBufferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteBytesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteBytesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteLinesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::WriteLinesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathIO_WriteTextAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(args, 2);

                return py::convert(winrt::Windows::Storage::PathIO::WriteTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathIO[] = {
        { "append_lines_async", reinterpret_cast<PyCFunction>(PathIO_AppendLinesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "append_text_async", reinterpret_cast<PyCFunction>(PathIO_AppendTextAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "read_buffer_async", reinterpret_cast<PyCFunction>(PathIO_ReadBufferAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "read_lines_async", reinterpret_cast<PyCFunction>(PathIO_ReadLinesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "read_text_async", reinterpret_cast<PyCFunction>(PathIO_ReadTextAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_buffer_async", reinterpret_cast<PyCFunction>(PathIO_WriteBufferAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_bytes_async", reinterpret_cast<PyCFunction>(PathIO_WriteBytesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_lines_async", reinterpret_cast<PyCFunction>(PathIO_WriteLinesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "write_text_async", reinterpret_cast<PyCFunction>(PathIO_WriteTextAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathIO[] = {
        { }
    };

    static PyType_Slot _type_slots_PathIO[] = 
    {
        { Py_tp_new, _new_PathIO },
        { Py_tp_methods, _methods_PathIO },
        { Py_tp_getset, _getset_PathIO },
        { },
    };

    static PyType_Spec _type_spec_PathIO =
    {
        "_winsdk_Windows_Storage.PathIO",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathIO
    };

    // ----- SetVersionDeferral class --------------------
    constexpr const char* const _type_name_SetVersionDeferral = "SetVersionDeferral";

    static PyObject* _new_SetVersionDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SetVersionDeferral);
        return nullptr;
    }

    static void _dealloc_SetVersionDeferral(py::wrapper::Windows::Storage::SetVersionDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SetVersionDeferral_Complete(py::wrapper::Windows::Storage::SetVersionDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SetVersionDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SetVersionDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetVersionDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetVersionDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SetVersionDeferral[] = 
    {
        { Py_tp_new, _new_SetVersionDeferral },
        { Py_tp_dealloc, _dealloc_SetVersionDeferral },
        { Py_tp_methods, _methods_SetVersionDeferral },
        { Py_tp_getset, _getset_SetVersionDeferral },
        { },
    };

    static PyType_Spec _type_spec_SetVersionDeferral =
    {
        "_winsdk_Windows_Storage.SetVersionDeferral",
        sizeof(py::wrapper::Windows::Storage::SetVersionDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionDeferral
    };

    // ----- SetVersionRequest class --------------------
    constexpr const char* const _type_name_SetVersionRequest = "SetVersionRequest";

    static PyObject* _new_SetVersionRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SetVersionRequest);
        return nullptr;
    }

    static void _dealloc_SetVersionRequest(py::wrapper::Windows::Storage::SetVersionRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SetVersionRequest_GetDeferral(py::wrapper::Windows::Storage::SetVersionRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_CurrentVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SetVersionRequest_get_DesiredVersion(py::wrapper::Windows::Storage::SetVersionRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SetVersionRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SetVersionRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetVersionRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SetVersionRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetVersionRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetVersionRequest[] = {
        { "current_version", reinterpret_cast<getter>(SetVersionRequest_get_CurrentVersion), nullptr, nullptr, nullptr },
        { "desired_version", reinterpret_cast<getter>(SetVersionRequest_get_DesiredVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetVersionRequest[] = 
    {
        { Py_tp_new, _new_SetVersionRequest },
        { Py_tp_dealloc, _dealloc_SetVersionRequest },
        { Py_tp_methods, _methods_SetVersionRequest },
        { Py_tp_getset, _getset_SetVersionRequest },
        { },
    };

    static PyType_Spec _type_spec_SetVersionRequest =
    {
        "_winsdk_Windows_Storage.SetVersionRequest",
        sizeof(py::wrapper::Windows::Storage::SetVersionRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetVersionRequest
    };

    // ----- StorageFile class --------------------
    constexpr const char* const _type_name_StorageFile = "StorageFile";

    static PyObject* _new_StorageFile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageFile);
        return nullptr;
    }

    static void _dealloc_StorageFile(py::wrapper::Windows::Storage::StorageFile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CopyAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CopyAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.CopyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::CreateStreamedFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_CreateStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::CreateStreamedFileFromUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_DeleteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromApplicationUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromApplicationUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetFileFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageFile::GetFileFromPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetParentAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsEqual(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_IsOfType(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.MoveAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_MoveAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.MoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.MoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.MoveAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert(self->obj.OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenTransactedWriteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert(self->obj.OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_RenameAsync(py::wrapper::Windows::Storage::StorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StreamedFileDataRequestedHandler>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_ReplaceWithStreamedFileFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 2);

                return py::convert(winrt::Windows::Storage::StorageFile::ReplaceWithStreamedFileFromUriAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_ContentType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FileType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_IsAvailable(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Attributes(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DateCreated(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Name(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Path(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayName(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_DisplayType(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Properties(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFile_get_Provider(py::wrapper::Windows::Storage::StorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFile[] = {
        { "copy_and_replace_async", reinterpret_cast<PyCFunction>(StorageFile_CopyAndReplaceAsync), METH_VARARGS, nullptr },
        { "copy_async", reinterpret_cast<PyCFunction>(StorageFile_CopyAsync), METH_VARARGS, nullptr },
        { "create_streamed_file_async", reinterpret_cast<PyCFunction>(StorageFile_CreateStreamedFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_streamed_file_from_uri_async", reinterpret_cast<PyCFunction>(StorageFile_CreateStreamedFileFromUriAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(StorageFile_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(StorageFile_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_file_from_application_uri_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromApplicationUriAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_file_from_path_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromPathAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_file_from_path_for_user_async", reinterpret_cast<PyCFunction>(StorageFile_GetFileFromPathForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(StorageFile_GetParentAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFile_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFile_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(StorageFile_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageFile_IsOfType), METH_VARARGS, nullptr },
        { "move_and_replace_async", reinterpret_cast<PyCFunction>(StorageFile_MoveAndReplaceAsync), METH_VARARGS, nullptr },
        { "move_async", reinterpret_cast<PyCFunction>(StorageFile_MoveAsync), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(StorageFile_OpenAsync), METH_VARARGS, nullptr },
        { "open_read_async", reinterpret_cast<PyCFunction>(StorageFile_OpenReadAsync), METH_VARARGS, nullptr },
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(StorageFile_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(StorageFile_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(StorageFile_RenameAsync), METH_VARARGS, nullptr },
        { "replace_with_streamed_file_async", reinterpret_cast<PyCFunction>(StorageFile_ReplaceWithStreamedFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "replace_with_streamed_file_from_uri_async", reinterpret_cast<PyCFunction>(StorageFile_ReplaceWithStreamedFileFromUriAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageFile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageFile[] = {
        { "content_type", reinterpret_cast<getter>(StorageFile_get_ContentType), nullptr, nullptr, nullptr },
        { "file_type", reinterpret_cast<getter>(StorageFile_get_FileType), nullptr, nullptr, nullptr },
        { "is_available", reinterpret_cast<getter>(StorageFile_get_IsAvailable), nullptr, nullptr, nullptr },
        { "attributes", reinterpret_cast<getter>(StorageFile_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(StorageFile_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(StorageFile_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageFile_get_Path), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StorageFile_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(StorageFile_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(StorageFile_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(StorageFile_get_Properties), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(StorageFile_get_Provider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageFile[] = 
    {
        { Py_tp_new, _new_StorageFile },
        { Py_tp_dealloc, _dealloc_StorageFile },
        { Py_tp_methods, _methods_StorageFile },
        { Py_tp_getset, _getset_StorageFile },
        { },
    };

    static PyType_Spec _type_spec_StorageFile =
    {
        "_winsdk_Windows_Storage.StorageFile",
        sizeof(py::wrapper::Windows::Storage::StorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFile
    };

    // ----- StorageFolder class --------------------
    constexpr const char* const _type_name_StorageFolder = "StorageFolder";

    static PyObject* _new_StorageFolder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageFolder);
        return nullptr;
    }

    static void _dealloc_StorageFolder(py::wrapper::Windows::Storage::StorageFolder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageFolder_AreQueryOptionsSupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.AreQueryOptionsSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFileQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.CreateFileQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFileQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateFileQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFolderQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.CreateFolderQuery(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateFolderQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateFolderQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQuery(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateItemQuery());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_CreateItemQueryWithOptions(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::QueryOptions>(args, 0);

                return py::convert(self->obj.CreateItemQueryWithOptions(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_DeleteAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFileAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.GetFilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.GetFilesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageFolder::GetFolderFromPathAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFolderFromPathForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageFolder::GetFolderFromPathForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.GetFoldersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(self->obj.GetFoldersAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetIndexedStateAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIndexedStateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetItemsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetParentAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_GetThumbnailAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFileQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFileQuery>(args, 0);

                return py::convert(self->obj.IsCommonFileQuerySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsCommonFolderQuerySupported(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Search::CommonFolderQuery>(args, 0);

                return py::convert(self->obj.IsCommonFolderQuerySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsEqual(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_IsOfType(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_RenameAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetChangeTracker(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetChangeTracker());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_TryGetItemAsync(py::wrapper::Windows::Storage::StorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Attributes(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DateCreated(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Name(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Path(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayName(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_DisplayType(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_FolderRelativeId(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Properties(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageFolder_get_Provider(py::wrapper::Windows::Storage::StorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageFolder[] = {
        { "are_query_options_supported", reinterpret_cast<PyCFunction>(StorageFolder_AreQueryOptionsSupported), METH_VARARGS, nullptr },
        { "create_file_async", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_file_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQuery), METH_VARARGS, nullptr },
        { "create_file_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFileQueryWithOptions), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "create_folder_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQuery), METH_VARARGS, nullptr },
        { "create_folder_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateFolderQueryWithOptions), METH_VARARGS, nullptr },
        { "create_item_query", reinterpret_cast<PyCFunction>(StorageFolder_CreateItemQuery), METH_VARARGS, nullptr },
        { "create_item_query_with_options", reinterpret_cast<PyCFunction>(StorageFolder_CreateItemQueryWithOptions), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(StorageFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(StorageFolder_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "get_file_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFileAsync), METH_VARARGS, nullptr },
        { "get_files_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFilesAsync), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folder_from_path_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderFromPathAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_folder_from_path_for_user_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFolderFromPathForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_folders_async", reinterpret_cast<PyCFunction>(StorageFolder_GetFoldersAsync), METH_VARARGS, nullptr },
        { "get_indexed_state_async", reinterpret_cast<PyCFunction>(StorageFolder_GetIndexedStateAsync), METH_VARARGS, nullptr },
        { "get_item_async", reinterpret_cast<PyCFunction>(StorageFolder_GetItemAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(StorageFolder_GetItemsAsync), METH_VARARGS, nullptr },
        { "get_parent_async", reinterpret_cast<PyCFunction>(StorageFolder_GetParentAsync), METH_VARARGS, nullptr },
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFolder_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(StorageFolder_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "is_common_file_query_supported", reinterpret_cast<PyCFunction>(StorageFolder_IsCommonFileQuerySupported), METH_VARARGS, nullptr },
        { "is_common_folder_query_supported", reinterpret_cast<PyCFunction>(StorageFolder_IsCommonFolderQuerySupported), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(StorageFolder_IsEqual), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageFolder_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(StorageFolder_RenameAsync), METH_VARARGS, nullptr },
        { "try_get_change_tracker", reinterpret_cast<PyCFunction>(StorageFolder_TryGetChangeTracker), METH_VARARGS, nullptr },
        { "try_get_item_async", reinterpret_cast<PyCFunction>(StorageFolder_TryGetItemAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageFolder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageFolder[] = {
        { "attributes", reinterpret_cast<getter>(StorageFolder_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(StorageFolder_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(StorageFolder_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageFolder_get_Path), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(StorageFolder_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(StorageFolder_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(StorageFolder_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(StorageFolder_get_Properties), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(StorageFolder_get_Provider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageFolder[] = 
    {
        { Py_tp_new, _new_StorageFolder },
        { Py_tp_dealloc, _dealloc_StorageFolder },
        { Py_tp_methods, _methods_StorageFolder },
        { Py_tp_getset, _getset_StorageFolder },
        { },
    };

    static PyType_Spec _type_spec_StorageFolder =
    {
        "_winsdk_Windows_Storage.StorageFolder",
        sizeof(py::wrapper::Windows::Storage::StorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageFolder
    };

    // ----- StorageLibrary class --------------------
    constexpr const char* const _type_name_StorageLibrary = "StorageLibrary";

    static PyObject* _new_StorageLibrary(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibrary);
        return nullptr;
    }

    static void _dealloc_StorageLibrary(py::wrapper::Windows::Storage::StorageLibrary* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibrary_AreFolderSuggestionsAvailableAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AreFolderSuggestionsAvailableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 0);

                return py::convert(winrt::Windows::Storage::StorageLibrary::GetLibraryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_GetLibraryForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::KnownLibraryId>(args, 1);

                return py::convert(winrt::Windows::Storage::StorageLibrary::GetLibraryForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestAddFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAddFolderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_RequestRemoveFolderAsync(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFolder>(args, 0);

                return py::convert(self->obj.RequestRemoveFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_Folders(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Folders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_SaveFolder(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SaveFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_get_ChangeTracker(py::wrapper::Windows::Storage::StorageLibrary* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_add_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::StorageLibrary, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DefinitionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibrary_remove_DefinitionChanged(py::wrapper::Windows::Storage::StorageLibrary* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DefinitionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibrary(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibrary>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibrary[] = {
        { "are_folder_suggestions_available_async", reinterpret_cast<PyCFunction>(StorageLibrary_AreFolderSuggestionsAvailableAsync), METH_VARARGS, nullptr },
        { "get_library_async", reinterpret_cast<PyCFunction>(StorageLibrary_GetLibraryAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_library_for_user_async", reinterpret_cast<PyCFunction>(StorageLibrary_GetLibraryForUserAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_add_folder_async", reinterpret_cast<PyCFunction>(StorageLibrary_RequestAddFolderAsync), METH_VARARGS, nullptr },
        { "request_remove_folder_async", reinterpret_cast<PyCFunction>(StorageLibrary_RequestRemoveFolderAsync), METH_VARARGS, nullptr },
        { "add_definition_changed", reinterpret_cast<PyCFunction>(StorageLibrary_add_DefinitionChanged), METH_O, nullptr },
        { "remove_definition_changed", reinterpret_cast<PyCFunction>(StorageLibrary_remove_DefinitionChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibrary), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibrary[] = {
        { "folders", reinterpret_cast<getter>(StorageLibrary_get_Folders), nullptr, nullptr, nullptr },
        { "save_folder", reinterpret_cast<getter>(StorageLibrary_get_SaveFolder), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(StorageLibrary_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageLibrary[] = 
    {
        { Py_tp_new, _new_StorageLibrary },
        { Py_tp_dealloc, _dealloc_StorageLibrary },
        { Py_tp_methods, _methods_StorageLibrary },
        { Py_tp_getset, _getset_StorageLibrary },
        { },
    };

    static PyType_Spec _type_spec_StorageLibrary =
    {
        "_winsdk_Windows_Storage.StorageLibrary",
        sizeof(py::wrapper::Windows::Storage::StorageLibrary),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibrary
    };

    // ----- StorageLibraryChange class --------------------
    constexpr const char* const _type_name_StorageLibraryChange = "StorageLibraryChange";

    static PyObject* _new_StorageLibraryChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryChange);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChange(py::wrapper::Windows::Storage::StorageLibraryChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChange_GetStorageItemAsync(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStorageItemAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_IsOfType(py::wrapper::Windows::Storage::StorageLibraryChange* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_ChangeType(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_Path(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChange_get_PreviousPath(py::wrapper::Windows::Storage::StorageLibraryChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChange[] = {
        { "get_storage_item_async", reinterpret_cast<PyCFunction>(StorageLibraryChange_GetStorageItemAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(StorageLibraryChange_IsOfType), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChange[] = {
        { "change_type", reinterpret_cast<getter>(StorageLibraryChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageLibraryChange_get_Path), nullptr, nullptr, nullptr },
        { "previous_path", reinterpret_cast<getter>(StorageLibraryChange_get_PreviousPath), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChange[] = 
    {
        { Py_tp_new, _new_StorageLibraryChange },
        { Py_tp_dealloc, _dealloc_StorageLibraryChange },
        { Py_tp_methods, _methods_StorageLibraryChange },
        { Py_tp_getset, _getset_StorageLibraryChange },
        { },
    };

    static PyType_Spec _type_spec_StorageLibraryChange =
    {
        "_winsdk_Windows_Storage.StorageLibraryChange",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChange
    };

    // ----- StorageLibraryChangeReader class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeReader = "StorageLibraryChangeReader";

    static PyObject* _new_StorageLibraryChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryChangeReader);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChangeReader_AcceptChangesAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcceptChangesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_GetLastChangeId(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetLastChangeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeReader_ReadBatchAsync(py::wrapper::Windows::Storage::StorageLibraryChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeReader[] = {
        { "accept_changes_async", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_AcceptChangesAsync), METH_VARARGS, nullptr },
        { "get_last_change_id", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_GetLastChangeId), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(StorageLibraryChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeReader[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeReader },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeReader },
        { Py_tp_methods, _methods_StorageLibraryChangeReader },
        { Py_tp_getset, _getset_StorageLibraryChangeReader },
        { },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeReader =
    {
        "_winsdk_Windows_Storage.StorageLibraryChangeReader",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeReader
    };

    // ----- StorageLibraryChangeTracker class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeTracker = "StorageLibraryChangeTracker";

    static PyObject* _new_StorageLibraryChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryChangeTracker);
        return nullptr;
    }

    static void _dealloc_StorageLibraryChangeTracker(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChangeTracker_Disable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Enable(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>(args, 0);

                self->obj.Enable(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_GetChangeReader(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageLibraryChangeTracker_Reset(py::wrapper::Windows::Storage::StorageLibraryChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTracker[] = {
        { "disable", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Disable), METH_VARARGS, nullptr },
        { "enable", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(StorageLibraryChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTracker[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTracker[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeTracker },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeTracker },
        { Py_tp_methods, _methods_StorageLibraryChangeTracker },
        { Py_tp_getset, _getset_StorageLibraryChangeTracker },
        { },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeTracker =
    {
        "_winsdk_Windows_Storage.StorageLibraryChangeTracker",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTracker
    };

    // ----- StorageLibraryChangeTrackerOptions class --------------------
    constexpr const char* const _type_name_StorageLibraryChangeTrackerOptions = "StorageLibraryChangeTrackerOptions";

    static PyObject* _new_StorageLibraryChangeTrackerOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::StorageLibraryChangeTrackerOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageLibraryChangeTrackerOptions(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryChangeTrackerOptions_get_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackChangeDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageLibraryChangeTrackerOptions_put_TrackChangeDetails(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.TrackChangeDetails(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageLibraryChangeTrackerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryChangeTrackerOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryChangeTrackerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryChangeTrackerOptions[] = {
        { "track_change_details", reinterpret_cast<getter>(StorageLibraryChangeTrackerOptions_get_TrackChangeDetails), reinterpret_cast<setter>(StorageLibraryChangeTrackerOptions_put_TrackChangeDetails), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryChangeTrackerOptions[] = 
    {
        { Py_tp_new, _new_StorageLibraryChangeTrackerOptions },
        { Py_tp_dealloc, _dealloc_StorageLibraryChangeTrackerOptions },
        { Py_tp_methods, _methods_StorageLibraryChangeTrackerOptions },
        { Py_tp_getset, _getset_StorageLibraryChangeTrackerOptions },
        { },
    };

    static PyType_Spec _type_spec_StorageLibraryChangeTrackerOptions =
    {
        "_winsdk_Windows_Storage.StorageLibraryChangeTrackerOptions",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryChangeTrackerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryChangeTrackerOptions
    };

    // ----- StorageLibraryLastChangeId class --------------------
    constexpr const char* const _type_name_StorageLibraryLastChangeId = "StorageLibraryLastChangeId";

    static PyObject* _new_StorageLibraryLastChangeId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageLibraryLastChangeId);
        return nullptr;
    }

    static void _dealloc_StorageLibraryLastChangeId(py::wrapper::Windows::Storage::StorageLibraryLastChangeId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageLibraryLastChangeId_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::StorageLibraryLastChangeId::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageLibraryLastChangeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageLibraryLastChangeId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageLibraryLastChangeId[] = {
        { "get_unknown", reinterpret_cast<PyCFunction>(StorageLibraryLastChangeId_get_Unknown), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageLibraryLastChangeId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageLibraryLastChangeId[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageLibraryLastChangeId[] = 
    {
        { Py_tp_new, _new_StorageLibraryLastChangeId },
        { Py_tp_dealloc, _dealloc_StorageLibraryLastChangeId },
        { Py_tp_methods, _methods_StorageLibraryLastChangeId },
        { Py_tp_getset, _getset_StorageLibraryLastChangeId },
        { },
    };

    static PyType_Spec _type_spec_StorageLibraryLastChangeId =
    {
        "_winsdk_Windows_Storage.StorageLibraryLastChangeId",
        sizeof(py::wrapper::Windows::Storage::StorageLibraryLastChangeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageLibraryLastChangeId
    };

    // ----- StorageProvider class --------------------
    constexpr const char* const _type_name_StorageProvider = "StorageProvider";

    static PyObject* _new_StorageProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageProvider);
        return nullptr;
    }

    static void _dealloc_StorageProvider(py::wrapper::Windows::Storage::StorageProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProvider_IsPropertySupportedForPartialFileAsync(py::wrapper::Windows::Storage::StorageProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupportedForPartialFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_DisplayName(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProvider_get_Id(py::wrapper::Windows::Storage::StorageProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProvider[] = {
        { "is_property_supported_for_partial_file_async", reinterpret_cast<PyCFunction>(StorageProvider_IsPropertySupportedForPartialFileAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProvider[] = {
        { "display_name", reinterpret_cast<getter>(StorageProvider_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProvider_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProvider[] = 
    {
        { Py_tp_new, _new_StorageProvider },
        { Py_tp_dealloc, _dealloc_StorageProvider },
        { Py_tp_methods, _methods_StorageProvider },
        { Py_tp_getset, _getset_StorageProvider },
        { },
    };

    static PyType_Spec _type_spec_StorageProvider =
    {
        "_winsdk_Windows_Storage.StorageProvider",
        sizeof(py::wrapper::Windows::Storage::StorageProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProvider
    };

    // ----- StorageStreamTransaction class --------------------
    constexpr const char* const _type_name_StorageStreamTransaction = "StorageStreamTransaction";

    static PyObject* _new_StorageStreamTransaction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageStreamTransaction);
        return nullptr;
    }

    static void _dealloc_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageStreamTransaction_Close(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_CommitAsync(py::wrapper::Windows::Storage::StorageStreamTransaction* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CommitAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageStreamTransaction_get_Stream(py::wrapper::Windows::Storage::StorageStreamTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageStreamTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StorageStreamTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StorageStreamTransaction(py::wrapper::Windows::Storage::StorageStreamTransaction* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageStreamTransaction[] = {
        { "close", reinterpret_cast<PyCFunction>(StorageStreamTransaction_Close), METH_VARARGS, nullptr },
        { "commit_async", reinterpret_cast<PyCFunction>(StorageStreamTransaction_CommitAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageStreamTransaction), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorageStreamTransaction), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StorageStreamTransaction), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageStreamTransaction[] = {
        { "stream", reinterpret_cast<getter>(StorageStreamTransaction_get_Stream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageStreamTransaction[] = 
    {
        { Py_tp_new, _new_StorageStreamTransaction },
        { Py_tp_dealloc, _dealloc_StorageStreamTransaction },
        { Py_tp_methods, _methods_StorageStreamTransaction },
        { Py_tp_getset, _getset_StorageStreamTransaction },
        { },
    };

    static PyType_Spec _type_spec_StorageStreamTransaction =
    {
        "_winsdk_Windows_Storage.StorageStreamTransaction",
        sizeof(py::wrapper::Windows::Storage::StorageStreamTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageStreamTransaction
    };

    // ----- StreamedFileDataRequest class --------------------
    constexpr const char* const _type_name_StreamedFileDataRequest = "StreamedFileDataRequest";

    static PyObject* _new_StreamedFileDataRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamedFileDataRequest);
        return nullptr;
    }

    static void _dealloc_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamedFileDataRequest_Close(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                self->obj.FailAndClose(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_FlushAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamedFileDataRequest_WriteAsync(py::wrapper::Windows::Storage::StreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_StreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::StreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamedFileDataRequest(py::wrapper::Windows::Storage::StreamedFileDataRequest* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamedFileDataRequest[] = {
        { "close", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_Close), METH_VARARGS, nullptr },
        { "fail_and_close", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_FailAndClose), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_FlushAsync), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(StreamedFileDataRequest_WriteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamedFileDataRequest), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamedFileDataRequest), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamedFileDataRequest), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamedFileDataRequest[] = {
        { }
    };

    static PyType_Slot _type_slots_StreamedFileDataRequest[] = 
    {
        { Py_tp_new, _new_StreamedFileDataRequest },
        { Py_tp_dealloc, _dealloc_StreamedFileDataRequest },
        { Py_tp_methods, _methods_StreamedFileDataRequest },
        { Py_tp_getset, _getset_StreamedFileDataRequest },
        { },
    };

    static PyType_Spec _type_spec_StreamedFileDataRequest =
    {
        "_winsdk_Windows_Storage.StreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::StreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamedFileDataRequest
    };

    // ----- SystemAudioProperties class --------------------
    constexpr const char* const _type_name_SystemAudioProperties = "SystemAudioProperties";

    static PyObject* _new_SystemAudioProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemAudioProperties);
        return nullptr;
    }

    static void _dealloc_SystemAudioProperties(py::wrapper::Windows::Storage::SystemAudioProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemAudioProperties_get_EncodingBitrate(py::wrapper::Windows::Storage::SystemAudioProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemAudioProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemAudioProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemAudioProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemAudioProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemAudioProperties[] = {
        { "encoding_bitrate", reinterpret_cast<getter>(SystemAudioProperties_get_EncodingBitrate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemAudioProperties[] = 
    {
        { Py_tp_new, _new_SystemAudioProperties },
        { Py_tp_dealloc, _dealloc_SystemAudioProperties },
        { Py_tp_methods, _methods_SystemAudioProperties },
        { Py_tp_getset, _getset_SystemAudioProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemAudioProperties =
    {
        "_winsdk_Windows_Storage.SystemAudioProperties",
        sizeof(py::wrapper::Windows::Storage::SystemAudioProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemAudioProperties
    };

    // ----- SystemDataPaths class --------------------
    constexpr const char* const _type_name_SystemDataPaths = "SystemDataPaths";

    static PyObject* _new_SystemDataPaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemDataPaths);
        return nullptr;
    }

    static void _dealloc_SystemDataPaths(py::wrapper::Windows::Storage::SystemDataPaths* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::SystemDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Fonts(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fonts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_ProgramData(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgramData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Public(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Public());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDesktop(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicDesktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDocuments(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicDocuments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicDownloads(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicDownloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicMusic(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicMusic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicPictures(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_PublicVideos(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublicVideos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_System(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.System());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemArm(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemArm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemHost(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemHost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX64(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemX64());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_SystemX86(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemX86());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_UserProfiles(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDataPaths_get_Windows(py::wrapper::Windows::Storage::SystemDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Windows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDataPaths[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SystemDataPaths_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDataPaths), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemDataPaths[] = {
        { "fonts", reinterpret_cast<getter>(SystemDataPaths_get_Fonts), nullptr, nullptr, nullptr },
        { "program_data", reinterpret_cast<getter>(SystemDataPaths_get_ProgramData), nullptr, nullptr, nullptr },
        { "public", reinterpret_cast<getter>(SystemDataPaths_get_Public), nullptr, nullptr, nullptr },
        { "public_desktop", reinterpret_cast<getter>(SystemDataPaths_get_PublicDesktop), nullptr, nullptr, nullptr },
        { "public_documents", reinterpret_cast<getter>(SystemDataPaths_get_PublicDocuments), nullptr, nullptr, nullptr },
        { "public_downloads", reinterpret_cast<getter>(SystemDataPaths_get_PublicDownloads), nullptr, nullptr, nullptr },
        { "public_music", reinterpret_cast<getter>(SystemDataPaths_get_PublicMusic), nullptr, nullptr, nullptr },
        { "public_pictures", reinterpret_cast<getter>(SystemDataPaths_get_PublicPictures), nullptr, nullptr, nullptr },
        { "public_videos", reinterpret_cast<getter>(SystemDataPaths_get_PublicVideos), nullptr, nullptr, nullptr },
        { "system", reinterpret_cast<getter>(SystemDataPaths_get_System), nullptr, nullptr, nullptr },
        { "system_arm", reinterpret_cast<getter>(SystemDataPaths_get_SystemArm), nullptr, nullptr, nullptr },
        { "system_host", reinterpret_cast<getter>(SystemDataPaths_get_SystemHost), nullptr, nullptr, nullptr },
        { "system_x64", reinterpret_cast<getter>(SystemDataPaths_get_SystemX64), nullptr, nullptr, nullptr },
        { "system_x86", reinterpret_cast<getter>(SystemDataPaths_get_SystemX86), nullptr, nullptr, nullptr },
        { "user_profiles", reinterpret_cast<getter>(SystemDataPaths_get_UserProfiles), nullptr, nullptr, nullptr },
        { "windows", reinterpret_cast<getter>(SystemDataPaths_get_Windows), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemDataPaths[] = 
    {
        { Py_tp_new, _new_SystemDataPaths },
        { Py_tp_dealloc, _dealloc_SystemDataPaths },
        { Py_tp_methods, _methods_SystemDataPaths },
        { Py_tp_getset, _getset_SystemDataPaths },
        { },
    };

    static PyType_Spec _type_spec_SystemDataPaths =
    {
        "_winsdk_Windows_Storage.SystemDataPaths",
        sizeof(py::wrapper::Windows::Storage::SystemDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDataPaths
    };

    // ----- SystemGPSProperties class --------------------
    constexpr const char* const _type_name_SystemGPSProperties = "SystemGPSProperties";

    static PyObject* _new_SystemGPSProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemGPSProperties);
        return nullptr;
    }

    static void _dealloc_SystemGPSProperties(py::wrapper::Windows::Storage::SystemGPSProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemGPSProperties_get_LatitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LatitudeDecimal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemGPSProperties_get_LongitudeDecimal(py::wrapper::Windows::Storage::SystemGPSProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LongitudeDecimal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemGPSProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemGPSProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemGPSProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemGPSProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemGPSProperties[] = {
        { "latitude_decimal", reinterpret_cast<getter>(SystemGPSProperties_get_LatitudeDecimal), nullptr, nullptr, nullptr },
        { "longitude_decimal", reinterpret_cast<getter>(SystemGPSProperties_get_LongitudeDecimal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemGPSProperties[] = 
    {
        { Py_tp_new, _new_SystemGPSProperties },
        { Py_tp_dealloc, _dealloc_SystemGPSProperties },
        { Py_tp_methods, _methods_SystemGPSProperties },
        { Py_tp_getset, _getset_SystemGPSProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemGPSProperties =
    {
        "_winsdk_Windows_Storage.SystemGPSProperties",
        sizeof(py::wrapper::Windows::Storage::SystemGPSProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemGPSProperties
    };

    // ----- SystemImageProperties class --------------------
    constexpr const char* const _type_name_SystemImageProperties = "SystemImageProperties";

    static PyObject* _new_SystemImageProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemImageProperties);
        return nullptr;
    }

    static void _dealloc_SystemImageProperties(py::wrapper::Windows::Storage::SystemImageProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemImageProperties_get_HorizontalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HorizontalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemImageProperties_get_VerticalSize(py::wrapper::Windows::Storage::SystemImageProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemImageProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemImageProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemImageProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemImageProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemImageProperties[] = {
        { "horizontal_size", reinterpret_cast<getter>(SystemImageProperties_get_HorizontalSize), nullptr, nullptr, nullptr },
        { "vertical_size", reinterpret_cast<getter>(SystemImageProperties_get_VerticalSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemImageProperties[] = 
    {
        { Py_tp_new, _new_SystemImageProperties },
        { Py_tp_dealloc, _dealloc_SystemImageProperties },
        { Py_tp_methods, _methods_SystemImageProperties },
        { Py_tp_getset, _getset_SystemImageProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemImageProperties =
    {
        "_winsdk_Windows_Storage.SystemImageProperties",
        sizeof(py::wrapper::Windows::Storage::SystemImageProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemImageProperties
    };

    // ----- SystemMediaProperties class --------------------
    constexpr const char* const _type_name_SystemMediaProperties = "SystemMediaProperties";

    static PyObject* _new_SystemMediaProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMediaProperties);
        return nullptr;
    }

    static void _dealloc_SystemMediaProperties(py::wrapper::Windows::Storage::SystemMediaProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMediaProperties_get_Duration(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Producer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Producer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Publisher(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_SubTitle(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Writer(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Writer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMediaProperties_get_Year(py::wrapper::Windows::Storage::SystemMediaProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMediaProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMediaProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMediaProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMediaProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMediaProperties[] = {
        { "duration", reinterpret_cast<getter>(SystemMediaProperties_get_Duration), nullptr, nullptr, nullptr },
        { "producer", reinterpret_cast<getter>(SystemMediaProperties_get_Producer), nullptr, nullptr, nullptr },
        { "publisher", reinterpret_cast<getter>(SystemMediaProperties_get_Publisher), nullptr, nullptr, nullptr },
        { "sub_title", reinterpret_cast<getter>(SystemMediaProperties_get_SubTitle), nullptr, nullptr, nullptr },
        { "writer", reinterpret_cast<getter>(SystemMediaProperties_get_Writer), nullptr, nullptr, nullptr },
        { "year", reinterpret_cast<getter>(SystemMediaProperties_get_Year), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMediaProperties[] = 
    {
        { Py_tp_new, _new_SystemMediaProperties },
        { Py_tp_dealloc, _dealloc_SystemMediaProperties },
        { Py_tp_methods, _methods_SystemMediaProperties },
        { Py_tp_getset, _getset_SystemMediaProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemMediaProperties =
    {
        "_winsdk_Windows_Storage.SystemMediaProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMediaProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMediaProperties
    };

    // ----- SystemMusicProperties class --------------------
    constexpr const char* const _type_name_SystemMusicProperties = "SystemMusicProperties";

    static PyObject* _new_SystemMusicProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMusicProperties);
        return nullptr;
    }

    static void _dealloc_SystemMusicProperties(py::wrapper::Windows::Storage::SystemMusicProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMusicProperties_get_AlbumArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_AlbumTitle(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlbumTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Artist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Composer(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Composer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Conductor(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Conductor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_DisplayArtist(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayArtist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_Genre(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Genre());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMusicProperties_get_TrackNumber(py::wrapper::Windows::Storage::SystemMusicProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMusicProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemMusicProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMusicProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMusicProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMusicProperties[] = {
        { "album_artist", reinterpret_cast<getter>(SystemMusicProperties_get_AlbumArtist), nullptr, nullptr, nullptr },
        { "album_title", reinterpret_cast<getter>(SystemMusicProperties_get_AlbumTitle), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(SystemMusicProperties_get_Artist), nullptr, nullptr, nullptr },
        { "composer", reinterpret_cast<getter>(SystemMusicProperties_get_Composer), nullptr, nullptr, nullptr },
        { "conductor", reinterpret_cast<getter>(SystemMusicProperties_get_Conductor), nullptr, nullptr, nullptr },
        { "display_artist", reinterpret_cast<getter>(SystemMusicProperties_get_DisplayArtist), nullptr, nullptr, nullptr },
        { "genre", reinterpret_cast<getter>(SystemMusicProperties_get_Genre), nullptr, nullptr, nullptr },
        { "track_number", reinterpret_cast<getter>(SystemMusicProperties_get_TrackNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMusicProperties[] = 
    {
        { Py_tp_new, _new_SystemMusicProperties },
        { Py_tp_dealloc, _dealloc_SystemMusicProperties },
        { Py_tp_methods, _methods_SystemMusicProperties },
        { Py_tp_getset, _getset_SystemMusicProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemMusicProperties =
    {
        "_winsdk_Windows_Storage.SystemMusicProperties",
        sizeof(py::wrapper::Windows::Storage::SystemMusicProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMusicProperties
    };

    // ----- SystemPhotoProperties class --------------------
    constexpr const char* const _type_name_SystemPhotoProperties = "SystemPhotoProperties";

    static PyObject* _new_SystemPhotoProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemPhotoProperties);
        return nullptr;
    }

    static void _dealloc_SystemPhotoProperties(py::wrapper::Windows::Storage::SystemPhotoProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemPhotoProperties_get_CameraManufacturer(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraManufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_CameraModel(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_DateTaken(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateTaken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemPhotoProperties_get_PeopleNames(py::wrapper::Windows::Storage::SystemPhotoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeopleNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemPhotoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemPhotoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemPhotoProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemPhotoProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemPhotoProperties[] = {
        { "camera_manufacturer", reinterpret_cast<getter>(SystemPhotoProperties_get_CameraManufacturer), nullptr, nullptr, nullptr },
        { "camera_model", reinterpret_cast<getter>(SystemPhotoProperties_get_CameraModel), nullptr, nullptr, nullptr },
        { "date_taken", reinterpret_cast<getter>(SystemPhotoProperties_get_DateTaken), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SystemPhotoProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "people_names", reinterpret_cast<getter>(SystemPhotoProperties_get_PeopleNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemPhotoProperties[] = 
    {
        { Py_tp_new, _new_SystemPhotoProperties },
        { Py_tp_dealloc, _dealloc_SystemPhotoProperties },
        { Py_tp_methods, _methods_SystemPhotoProperties },
        { Py_tp_getset, _getset_SystemPhotoProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemPhotoProperties =
    {
        "_winsdk_Windows_Storage.SystemPhotoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemPhotoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemPhotoProperties
    };

    // ----- SystemProperties class --------------------
    constexpr const char* const _type_name_SystemProperties = "SystemProperties";

    static PyObject* _new_SystemProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemProperties);
        return nullptr;
    }

    static PyObject* SystemProperties_get_Audio(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Author(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Comment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Comment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_GPS(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::GPS());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Image(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Image());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_ItemNameDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::ItemNameDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Keywords(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Media(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Music(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Music());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Photo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Photo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Rating(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Rating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemProperties_get_Video(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Storage::SystemProperties::Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemProperties[] = {
        { "get_audio", reinterpret_cast<PyCFunction>(SystemProperties_get_Audio), METH_NOARGS | METH_STATIC, nullptr },
        { "get_author", reinterpret_cast<PyCFunction>(SystemProperties_get_Author), METH_NOARGS | METH_STATIC, nullptr },
        { "get_comment", reinterpret_cast<PyCFunction>(SystemProperties_get_Comment), METH_NOARGS | METH_STATIC, nullptr },
        { "get_g_p_s", reinterpret_cast<PyCFunction>(SystemProperties_get_GPS), METH_NOARGS | METH_STATIC, nullptr },
        { "get_image", reinterpret_cast<PyCFunction>(SystemProperties_get_Image), METH_NOARGS | METH_STATIC, nullptr },
        { "get_item_name_display", reinterpret_cast<PyCFunction>(SystemProperties_get_ItemNameDisplay), METH_NOARGS | METH_STATIC, nullptr },
        { "get_keywords", reinterpret_cast<PyCFunction>(SystemProperties_get_Keywords), METH_NOARGS | METH_STATIC, nullptr },
        { "get_media", reinterpret_cast<PyCFunction>(SystemProperties_get_Media), METH_NOARGS | METH_STATIC, nullptr },
        { "get_music", reinterpret_cast<PyCFunction>(SystemProperties_get_Music), METH_NOARGS | METH_STATIC, nullptr },
        { "get_photo", reinterpret_cast<PyCFunction>(SystemProperties_get_Photo), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rating", reinterpret_cast<PyCFunction>(SystemProperties_get_Rating), METH_NOARGS | METH_STATIC, nullptr },
        { "get_title", reinterpret_cast<PyCFunction>(SystemProperties_get_Title), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video", reinterpret_cast<PyCFunction>(SystemProperties_get_Video), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemProperties[] = 
    {
        { Py_tp_new, _new_SystemProperties },
        { Py_tp_methods, _methods_SystemProperties },
        { Py_tp_getset, _getset_SystemProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemProperties =
    {
        "_winsdk_Windows_Storage.SystemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemProperties
    };

    // ----- SystemVideoProperties class --------------------
    constexpr const char* const _type_name_SystemVideoProperties = "SystemVideoProperties";

    static PyObject* _new_SystemVideoProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemVideoProperties);
        return nullptr;
    }

    static void _dealloc_SystemVideoProperties(py::wrapper::Windows::Storage::SystemVideoProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemVideoProperties_get_Director(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Director());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameHeight(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_FrameWidth(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_Orientation(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemVideoProperties_get_TotalBitrate(py::wrapper::Windows::Storage::SystemVideoProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemVideoProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::SystemVideoProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemVideoProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemVideoProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemVideoProperties[] = {
        { "director", reinterpret_cast<getter>(SystemVideoProperties_get_Director), nullptr, nullptr, nullptr },
        { "frame_height", reinterpret_cast<getter>(SystemVideoProperties_get_FrameHeight), nullptr, nullptr, nullptr },
        { "frame_width", reinterpret_cast<getter>(SystemVideoProperties_get_FrameWidth), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(SystemVideoProperties_get_Orientation), nullptr, nullptr, nullptr },
        { "total_bitrate", reinterpret_cast<getter>(SystemVideoProperties_get_TotalBitrate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemVideoProperties[] = 
    {
        { Py_tp_new, _new_SystemVideoProperties },
        { Py_tp_dealloc, _dealloc_SystemVideoProperties },
        { Py_tp_methods, _methods_SystemVideoProperties },
        { Py_tp_getset, _getset_SystemVideoProperties },
        { },
    };

    static PyType_Spec _type_spec_SystemVideoProperties =
    {
        "_winsdk_Windows_Storage.SystemVideoProperties",
        sizeof(py::wrapper::Windows::Storage::SystemVideoProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemVideoProperties
    };

    // ----- UserDataPaths class --------------------
    constexpr const char* const _type_name_UserDataPaths = "UserDataPaths";

    static PyObject* _new_UserDataPaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserDataPaths);
        return nullptr;
    }

    static void _dealloc_UserDataPaths(py::wrapper::Windows::Storage::UserDataPaths* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserDataPaths_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::UserDataPaths::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Storage::UserDataPaths::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_CameraRoll(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraRoll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Cookies(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cookies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Desktop(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Desktop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Documents(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Documents());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Downloads(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Favorites(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Favorites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_History(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_InternetCache(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InternetCache());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_LocalAppDataLow(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAppDataLow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Music(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Music());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Pictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Profile(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Profile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Recent(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_RoamingAppData(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingAppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_SavedPictures(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SavedPictures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Screenshots(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Screenshots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Templates(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Templates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataPaths_get_Videos(py::wrapper::Windows::Storage::UserDataPaths* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserDataPaths(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::UserDataPaths>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataPaths[] = {
        { "get_default", reinterpret_cast<PyCFunction>(UserDataPaths_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(UserDataPaths_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDataPaths), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDataPaths[] = {
        { "camera_roll", reinterpret_cast<getter>(UserDataPaths_get_CameraRoll), nullptr, nullptr, nullptr },
        { "cookies", reinterpret_cast<getter>(UserDataPaths_get_Cookies), nullptr, nullptr, nullptr },
        { "desktop", reinterpret_cast<getter>(UserDataPaths_get_Desktop), nullptr, nullptr, nullptr },
        { "documents", reinterpret_cast<getter>(UserDataPaths_get_Documents), nullptr, nullptr, nullptr },
        { "downloads", reinterpret_cast<getter>(UserDataPaths_get_Downloads), nullptr, nullptr, nullptr },
        { "favorites", reinterpret_cast<getter>(UserDataPaths_get_Favorites), nullptr, nullptr, nullptr },
        { "history", reinterpret_cast<getter>(UserDataPaths_get_History), nullptr, nullptr, nullptr },
        { "internet_cache", reinterpret_cast<getter>(UserDataPaths_get_InternetCache), nullptr, nullptr, nullptr },
        { "local_app_data", reinterpret_cast<getter>(UserDataPaths_get_LocalAppData), nullptr, nullptr, nullptr },
        { "local_app_data_low", reinterpret_cast<getter>(UserDataPaths_get_LocalAppDataLow), nullptr, nullptr, nullptr },
        { "music", reinterpret_cast<getter>(UserDataPaths_get_Music), nullptr, nullptr, nullptr },
        { "pictures", reinterpret_cast<getter>(UserDataPaths_get_Pictures), nullptr, nullptr, nullptr },
        { "profile", reinterpret_cast<getter>(UserDataPaths_get_Profile), nullptr, nullptr, nullptr },
        { "recent", reinterpret_cast<getter>(UserDataPaths_get_Recent), nullptr, nullptr, nullptr },
        { "roaming_app_data", reinterpret_cast<getter>(UserDataPaths_get_RoamingAppData), nullptr, nullptr, nullptr },
        { "saved_pictures", reinterpret_cast<getter>(UserDataPaths_get_SavedPictures), nullptr, nullptr, nullptr },
        { "screenshots", reinterpret_cast<getter>(UserDataPaths_get_Screenshots), nullptr, nullptr, nullptr },
        { "templates", reinterpret_cast<getter>(UserDataPaths_get_Templates), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(UserDataPaths_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserDataPaths[] = 
    {
        { Py_tp_new, _new_UserDataPaths },
        { Py_tp_dealloc, _dealloc_UserDataPaths },
        { Py_tp_methods, _methods_UserDataPaths },
        { Py_tp_getset, _getset_UserDataPaths },
        { },
    };

    static PyType_Spec _type_spec_UserDataPaths =
    {
        "_winsdk_Windows_Storage.UserDataPaths",
        sizeof(py::wrapper::Windows::Storage::UserDataPaths),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataPaths
    };

    // ----- IStorageFile interface --------------------
    constexpr const char* const _type_name_IStorageFile = "IStorageFile";

    static PyObject* _new_IStorageFile(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFile);
        return nullptr;
    }

    static void _dealloc_IStorageFile(py::wrapper::Windows::Storage::IStorageFile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFile_CopyAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CopyAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_CopyAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.CopyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_DeleteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_IsOfType(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAndReplaceAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.MoveAndReplaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_MoveAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(self->obj.MoveAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.MoveAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 2);

                return py::convert(self->obj.MoveAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);

                return py::convert(self->obj.OpenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenSequentialReadAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenTransactedWriteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_RenameAsync(py::wrapper::Windows::Storage::IStorageFile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_ContentType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_FileType(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Attributes(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_DateCreated(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Name(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFile_get_Path(py::wrapper::Windows::Storage::IStorageFile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile[] = {
        { "copy_and_replace_async", reinterpret_cast<PyCFunction>(IStorageFile_CopyAndReplaceAsync), METH_VARARGS, nullptr },
        { "copy_async", reinterpret_cast<PyCFunction>(IStorageFile_CopyAsync), METH_VARARGS, nullptr },
        { "move_and_replace_async", reinterpret_cast<PyCFunction>(IStorageFile_MoveAndReplaceAsync), METH_VARARGS, nullptr },
        { "move_async", reinterpret_cast<PyCFunction>(IStorageFile_MoveAsync), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageFile_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageFile_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageFile_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageFile_RenameAsync), METH_VARARGS, nullptr },
        { "open_read_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenReadAsync), METH_VARARGS, nullptr },
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(IStorageFile_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFile[] = {
        { "content_type", reinterpret_cast<getter>(IStorageFile_get_ContentType), nullptr, nullptr, nullptr },
        { "file_type", reinterpret_cast<getter>(IStorageFile_get_FileType), nullptr, nullptr, nullptr },
        { "attributes", reinterpret_cast<getter>(IStorageFile_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageFile_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageFile_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageFile_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageFile[] = 
    {
        { Py_tp_new, _new_IStorageFile },
        { Py_tp_dealloc, _dealloc_IStorageFile },
        { Py_tp_methods, _methods_IStorageFile },
        { Py_tp_getset, _getset_IStorageFile },
        { },
    };

    static PyType_Spec _type_spec_IStorageFile =
    {
        "_winsdk_Windows_Storage.IStorageFile",
        sizeof(py::wrapper::Windows::Storage::IStorageFile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFile
    };

    // ----- IStorageFile2 interface --------------------
    constexpr const char* const _type_name_IStorageFile2 = "IStorageFile2";

    static PyObject* _new_IStorageFile2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFile2);
        return nullptr;
    }

    static void _dealloc_IStorageFile2(py::wrapper::Windows::Storage::IStorageFile2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFile2_OpenAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);

                return py::convert(self->obj.OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFile2_OpenTransactedWriteAsync(py::wrapper::Windows::Storage::IStorageFile2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 0);

                return py::convert(self->obj.OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFile2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFile2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFile2[] = {
        { "open_async", reinterpret_cast<PyCFunction>(IStorageFile2_OpenAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(IStorageFile2_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFile2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFile2[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageFile2[] = 
    {
        { Py_tp_new, _new_IStorageFile2 },
        { Py_tp_dealloc, _dealloc_IStorageFile2 },
        { Py_tp_methods, _methods_IStorageFile2 },
        { Py_tp_getset, _getset_IStorageFile2 },
        { },
    };

    static PyType_Spec _type_spec_IStorageFile2 =
    {
        "_winsdk_Windows_Storage.IStorageFile2",
        sizeof(py::wrapper::Windows::Storage::IStorageFile2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFile2
    };

    // ----- IStorageFilePropertiesWithAvailability interface --------------------
    constexpr const char* const _type_name_IStorageFilePropertiesWithAvailability = "IStorageFilePropertiesWithAvailability";

    static PyObject* _new_IStorageFilePropertiesWithAvailability(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFilePropertiesWithAvailability);
        return nullptr;
    }

    static void _dealloc_IStorageFilePropertiesWithAvailability(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFilePropertiesWithAvailability_get_IsAvailable(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFilePropertiesWithAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFilePropertiesWithAvailability[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFilePropertiesWithAvailability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFilePropertiesWithAvailability[] = {
        { "is_available", reinterpret_cast<getter>(IStorageFilePropertiesWithAvailability_get_IsAvailable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageFilePropertiesWithAvailability[] = 
    {
        { Py_tp_new, _new_IStorageFilePropertiesWithAvailability },
        { Py_tp_dealloc, _dealloc_IStorageFilePropertiesWithAvailability },
        { Py_tp_methods, _methods_IStorageFilePropertiesWithAvailability },
        { Py_tp_getset, _getset_IStorageFilePropertiesWithAvailability },
        { },
    };

    static PyType_Spec _type_spec_IStorageFilePropertiesWithAvailability =
    {
        "_winsdk_Windows_Storage.IStorageFilePropertiesWithAvailability",
        sizeof(py::wrapper::Windows::Storage::IStorageFilePropertiesWithAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFilePropertiesWithAvailability
    };

    // ----- IStorageFolder interface --------------------
    constexpr const char* const _type_name_IStorageFolder = "IStorageFolder";

    static PyObject* _new_IStorageFolder(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFolder);
        return nullptr;
    }

    static void _dealloc_IStorageFolder(py::wrapper::Windows::Storage::IStorageFolder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFolder_CreateFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_CreateFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::CreationCollisionOption>(args, 1);

                return py::convert(self->obj.CreateFolderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_DeleteAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFileAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFilesAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFilesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFolderAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetFoldersAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFoldersAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_GetItemsAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_IsOfType(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_RenameAsync(py::wrapper::Windows::Storage::IStorageFolder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Attributes(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_DateCreated(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Name(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageFolder_get_Path(py::wrapper::Windows::Storage::IStorageFolder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFolder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder[] = {
        { "create_file_async", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFileAsync), METH_VARARGS, nullptr },
        { "create_folder_async", reinterpret_cast<PyCFunction>(IStorageFolder_CreateFolderAsync), METH_VARARGS, nullptr },
        { "get_file_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFileAsync), METH_VARARGS, nullptr },
        { "get_files_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFilesAsync), METH_VARARGS, nullptr },
        { "get_folder_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFolderAsync), METH_VARARGS, nullptr },
        { "get_folders_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetFoldersAsync), METH_VARARGS, nullptr },
        { "get_item_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetItemAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetItemsAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageFolder_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageFolder_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageFolder_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageFolder_RenameAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFolder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFolder[] = {
        { "attributes", reinterpret_cast<getter>(IStorageFolder_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageFolder_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageFolder_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageFolder_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageFolder[] = 
    {
        { Py_tp_new, _new_IStorageFolder },
        { Py_tp_dealloc, _dealloc_IStorageFolder },
        { Py_tp_methods, _methods_IStorageFolder },
        { Py_tp_getset, _getset_IStorageFolder },
        { },
    };

    static PyType_Spec _type_spec_IStorageFolder =
    {
        "_winsdk_Windows_Storage.IStorageFolder",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFolder
    };

    // ----- IStorageFolder2 interface --------------------
    constexpr const char* const _type_name_IStorageFolder2 = "IStorageFolder2";

    static PyObject* _new_IStorageFolder2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageFolder2);
        return nullptr;
    }

    static void _dealloc_IStorageFolder2(py::wrapper::Windows::Storage::IStorageFolder2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageFolder2_TryGetItemAsync(py::wrapper::Windows::Storage::IStorageFolder2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryGetItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageFolder2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageFolder2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageFolder2[] = {
        { "try_get_item_async", reinterpret_cast<PyCFunction>(IStorageFolder2_TryGetItemAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageFolder2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageFolder2[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageFolder2[] = 
    {
        { Py_tp_new, _new_IStorageFolder2 },
        { Py_tp_dealloc, _dealloc_IStorageFolder2 },
        { Py_tp_methods, _methods_IStorageFolder2 },
        { Py_tp_getset, _getset_IStorageFolder2 },
        { },
    };

    static PyType_Spec _type_spec_IStorageFolder2 =
    {
        "_winsdk_Windows_Storage.IStorageFolder2",
        sizeof(py::wrapper::Windows::Storage::IStorageFolder2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageFolder2
    };

    // ----- IStorageItem interface --------------------
    constexpr const char* const _type_name_IStorageItem = "IStorageItem";

    static PyObject* _new_IStorageItem(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItem);
        return nullptr;
    }

    static void _dealloc_IStorageItem(py::wrapper::Windows::Storage::IStorageItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItem_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_IsOfType(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_RenameAsync(py::wrapper::Windows::Storage::IStorageItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Attributes(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Name(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem_get_Path(py::wrapper::Windows::Storage::IStorageItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageItem_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageItem_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageItem_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageItem_RenameAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItem[] = {
        { "attributes", reinterpret_cast<getter>(IStorageItem_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageItem_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageItem_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageItem_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItem[] = 
    {
        { Py_tp_new, _new_IStorageItem },
        { Py_tp_dealloc, _dealloc_IStorageItem },
        { Py_tp_methods, _methods_IStorageItem },
        { Py_tp_getset, _getset_IStorageItem },
        { },
    };

    static PyType_Spec _type_spec_IStorageItem =
    {
        "_winsdk_Windows_Storage.IStorageItem",
        sizeof(py::wrapper::Windows::Storage::IStorageItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItem
    };

    // ----- IStorageItem2 interface --------------------
    constexpr const char* const _type_name_IStorageItem2 = "IStorageItem2";

    static PyObject* _new_IStorageItem2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItem2);
        return nullptr;
    }

    static void _dealloc_IStorageItem2(py::wrapper::Windows::Storage::IStorageItem2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItem2_DeleteAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageDeleteOption>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetBasicPropertiesAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBasicPropertiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_GetParentAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetParentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsEqual(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_IsOfType(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageItemTypes>(args, 0);

                return py::convert(self->obj.IsOfType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_RenameAsync(py::wrapper::Windows::Storage::IStorageItem2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RenameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::NameCollisionOption>(args, 1);

                return py::convert(self->obj.RenameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Attributes(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attributes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_DateCreated(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DateCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Name(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItem2_get_Path(py::wrapper::Windows::Storage::IStorageItem2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItem2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItem2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItem2[] = {
        { "get_parent_async", reinterpret_cast<PyCFunction>(IStorageItem2_GetParentAsync), METH_VARARGS, nullptr },
        { "is_equal", reinterpret_cast<PyCFunction>(IStorageItem2_IsEqual), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(IStorageItem2_DeleteAsync), METH_VARARGS, nullptr },
        { "get_basic_properties_async", reinterpret_cast<PyCFunction>(IStorageItem2_GetBasicPropertiesAsync), METH_VARARGS, nullptr },
        { "is_of_type", reinterpret_cast<PyCFunction>(IStorageItem2_IsOfType), METH_VARARGS, nullptr },
        { "rename_async", reinterpret_cast<PyCFunction>(IStorageItem2_RenameAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItem2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItem2[] = {
        { "attributes", reinterpret_cast<getter>(IStorageItem2_get_Attributes), nullptr, nullptr, nullptr },
        { "date_created", reinterpret_cast<getter>(IStorageItem2_get_DateCreated), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IStorageItem2_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(IStorageItem2_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItem2[] = 
    {
        { Py_tp_new, _new_IStorageItem2 },
        { Py_tp_dealloc, _dealloc_IStorageItem2 },
        { Py_tp_methods, _methods_IStorageItem2 },
        { Py_tp_getset, _getset_IStorageItem2 },
        { },
    };

    static PyType_Spec _type_spec_IStorageItem2 =
    {
        "_winsdk_Windows_Storage.IStorageItem2",
        sizeof(py::wrapper::Windows::Storage::IStorageItem2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItem2
    };

    // ----- IStorageItemProperties interface --------------------
    constexpr const char* const _type_name_IStorageItemProperties = "IStorageItemProperties";

    static PyObject* _new_IStorageItemProperties(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItemProperties);
        return nullptr;
    }

    static void _dealloc_IStorageItemProperties(py::wrapper::Windows::Storage::IStorageItemProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItemProperties_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItemProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItemProperties[] = {
        { "display_name", reinterpret_cast<getter>(IStorageItemProperties_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemProperties_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemProperties_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemProperties_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItemProperties[] = 
    {
        { Py_tp_new, _new_IStorageItemProperties },
        { Py_tp_dealloc, _dealloc_IStorageItemProperties },
        { Py_tp_methods, _methods_IStorageItemProperties },
        { Py_tp_getset, _getset_IStorageItemProperties },
        { },
    };

    static PyType_Spec _type_spec_IStorageItemProperties =
    {
        "_winsdk_Windows_Storage.IStorageItemProperties",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemProperties
    };

    // ----- IStorageItemProperties2 interface --------------------
    constexpr const char* const _type_name_IStorageItemProperties2 = "IStorageItemProperties2";

    static PyObject* _new_IStorageItemProperties2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItemProperties2);
        return nullptr;
    }

    static void _dealloc_IStorageItemProperties2(py::wrapper::Windows::Storage::IStorageItemProperties2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItemProperties2_GetScaledImageAsThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetScaledImageAsThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemProperties2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemProperties2_get_Properties(py::wrapper::Windows::Storage::IStorageItemProperties2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItemProperties2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemProperties2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemProperties2[] = {
        { "get_scaled_image_as_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetScaledImageAsThumbnailAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemProperties2_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemProperties2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItemProperties2[] = {
        { "display_name", reinterpret_cast<getter>(IStorageItemProperties2_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemProperties2_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemProperties2_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemProperties2_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItemProperties2[] = 
    {
        { Py_tp_new, _new_IStorageItemProperties2 },
        { Py_tp_dealloc, _dealloc_IStorageItemProperties2 },
        { Py_tp_methods, _methods_IStorageItemProperties2 },
        { Py_tp_getset, _getset_IStorageItemProperties2 },
        { },
    };

    static PyType_Spec _type_spec_IStorageItemProperties2 =
    {
        "_winsdk_Windows_Storage.IStorageItemProperties2",
        sizeof(py::wrapper::Windows::Storage::IStorageItemProperties2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemProperties2
    };

    // ----- IStorageItemPropertiesWithProvider interface --------------------
    constexpr const char* const _type_name_IStorageItemPropertiesWithProvider = "IStorageItemPropertiesWithProvider";

    static PyObject* _new_IStorageItemPropertiesWithProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageItemPropertiesWithProvider);
        return nullptr;
    }

    static void _dealloc_IStorageItemPropertiesWithProvider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageItemPropertiesWithProvider_GetThumbnailAsync(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);

                return py::convert(self->obj.GetThumbnailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailMode>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileProperties::ThumbnailOptions>(args, 2);

                return py::convert(self->obj.GetThumbnailAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Provider(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayName(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_DisplayType(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_FolderRelativeId(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FolderRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageItemPropertiesWithProvider_get_Properties(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageItemPropertiesWithProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageItemPropertiesWithProvider[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IStorageItemPropertiesWithProvider_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageItemPropertiesWithProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageItemPropertiesWithProvider[] = {
        { "provider", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_Provider), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_DisplayName), nullptr, nullptr, nullptr },
        { "display_type", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_DisplayType), nullptr, nullptr, nullptr },
        { "folder_relative_id", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_FolderRelativeId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IStorageItemPropertiesWithProvider_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageItemPropertiesWithProvider[] = 
    {
        { Py_tp_new, _new_IStorageItemPropertiesWithProvider },
        { Py_tp_dealloc, _dealloc_IStorageItemPropertiesWithProvider },
        { Py_tp_methods, _methods_IStorageItemPropertiesWithProvider },
        { Py_tp_getset, _getset_IStorageItemPropertiesWithProvider },
        { },
    };

    static PyType_Spec _type_spec_IStorageItemPropertiesWithProvider =
    {
        "_winsdk_Windows_Storage.IStorageItemPropertiesWithProvider",
        sizeof(py::wrapper::Windows::Storage::IStorageItemPropertiesWithProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageItemPropertiesWithProvider
    };

    // ----- IStreamedFileDataRequest interface --------------------
    constexpr const char* const _type_name_IStreamedFileDataRequest = "IStreamedFileDataRequest";

    static PyObject* _new_IStreamedFileDataRequest(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStreamedFileDataRequest);
        return nullptr;
    }

    static void _dealloc_IStreamedFileDataRequest(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStreamedFileDataRequest_FailAndClose(py::wrapper::Windows::Storage::IStreamedFileDataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StreamedFileFailureMode>(args, 0);

                self->obj.FailAndClose(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStreamedFileDataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::IStreamedFileDataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStreamedFileDataRequest[] = {
        { "fail_and_close", reinterpret_cast<PyCFunction>(IStreamedFileDataRequest_FailAndClose), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStreamedFileDataRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStreamedFileDataRequest[] = {
        { }
    };

    static PyType_Slot _type_slots_IStreamedFileDataRequest[] = 
    {
        { Py_tp_new, _new_IStreamedFileDataRequest },
        { Py_tp_dealloc, _dealloc_IStreamedFileDataRequest },
        { Py_tp_methods, _methods_IStreamedFileDataRequest },
        { Py_tp_getset, _getset_IStreamedFileDataRequest },
        { },
    };

    static PyType_Spec _type_spec_IStreamedFileDataRequest =
    {
        "_winsdk_Windows_Storage.IStreamedFileDataRequest",
        sizeof(py::wrapper::Windows::Storage::IStreamedFileDataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStreamedFileDataRequest
    };

    // ----- Windows.Storage Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Storage::AppDataPaths>::python_type = py::register_python_type(module, _type_name_AppDataPaths, &_type_spec_AppDataPaths, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationData>::python_type = py::register_python_type(module, _type_name_ApplicationData, &_type_spec_ApplicationData, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationDataCompositeValue>::python_type = py::register_python_type(module, _type_name_ApplicationDataCompositeValue, &_type_spec_ApplicationDataCompositeValue, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationDataContainer>::python_type = py::register_python_type(module, _type_name_ApplicationDataContainer, &_type_spec_ApplicationDataContainer, bases.get());
            py::winrt_type<winrt::Windows::Storage::ApplicationDataContainerSettings>::python_type = py::register_python_type(module, _type_name_ApplicationDataContainerSettings, &_type_spec_ApplicationDataContainerSettings, bases.get());
            py::winrt_type<winrt::Windows::Storage::CachedFileManager>::python_type = py::register_python_type(module, _type_name_CachedFileManager, &_type_spec_CachedFileManager, nullptr);
            py::winrt_type<winrt::Windows::Storage::DownloadsFolder>::python_type = py::register_python_type(module, _type_name_DownloadsFolder, &_type_spec_DownloadsFolder, nullptr);
            py::winrt_type<winrt::Windows::Storage::FileIO>::python_type = py::register_python_type(module, _type_name_FileIO, &_type_spec_FileIO, nullptr);
            py::winrt_type<winrt::Windows::Storage::KnownFolders>::python_type = py::register_python_type(module, _type_name_KnownFolders, &_type_spec_KnownFolders, nullptr);
            py::winrt_type<winrt::Windows::Storage::PathIO>::python_type = py::register_python_type(module, _type_name_PathIO, &_type_spec_PathIO, nullptr);
            py::winrt_type<winrt::Windows::Storage::SetVersionDeferral>::python_type = py::register_python_type(module, _type_name_SetVersionDeferral, &_type_spec_SetVersionDeferral, bases.get());
            py::winrt_type<winrt::Windows::Storage::SetVersionRequest>::python_type = py::register_python_type(module, _type_name_SetVersionRequest, &_type_spec_SetVersionRequest, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageFile>::python_type = py::register_python_type(module, _type_name_StorageFile, &_type_spec_StorageFile, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageFolder>::python_type = py::register_python_type(module, _type_name_StorageFolder, &_type_spec_StorageFolder, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibrary>::python_type = py::register_python_type(module, _type_name_StorageLibrary, &_type_spec_StorageLibrary, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChange>::python_type = py::register_python_type(module, _type_name_StorageLibraryChange, &_type_spec_StorageLibraryChange, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeReader>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeReader, &_type_spec_StorageLibraryChangeReader, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTracker>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeTracker, &_type_spec_StorageLibraryChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryChangeTrackerOptions>::python_type = py::register_python_type(module, _type_name_StorageLibraryChangeTrackerOptions, &_type_spec_StorageLibraryChangeTrackerOptions, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageLibraryLastChangeId>::python_type = py::register_python_type(module, _type_name_StorageLibraryLastChangeId, &_type_spec_StorageLibraryLastChangeId, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageProvider>::python_type = py::register_python_type(module, _type_name_StorageProvider, &_type_spec_StorageProvider, bases.get());
            py::winrt_type<winrt::Windows::Storage::StorageStreamTransaction>::python_type = py::register_python_type(module, _type_name_StorageStreamTransaction, &_type_spec_StorageStreamTransaction, bases.get());
            py::winrt_type<winrt::Windows::Storage::StreamedFileDataRequest>::python_type = py::register_python_type(module, _type_name_StreamedFileDataRequest, &_type_spec_StreamedFileDataRequest, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemAudioProperties>::python_type = py::register_python_type(module, _type_name_SystemAudioProperties, &_type_spec_SystemAudioProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemDataPaths>::python_type = py::register_python_type(module, _type_name_SystemDataPaths, &_type_spec_SystemDataPaths, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemGPSProperties>::python_type = py::register_python_type(module, _type_name_SystemGPSProperties, &_type_spec_SystemGPSProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemImageProperties>::python_type = py::register_python_type(module, _type_name_SystemImageProperties, &_type_spec_SystemImageProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemMediaProperties>::python_type = py::register_python_type(module, _type_name_SystemMediaProperties, &_type_spec_SystemMediaProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemMusicProperties>::python_type = py::register_python_type(module, _type_name_SystemMusicProperties, &_type_spec_SystemMusicProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemPhotoProperties>::python_type = py::register_python_type(module, _type_name_SystemPhotoProperties, &_type_spec_SystemPhotoProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::SystemProperties>::python_type = py::register_python_type(module, _type_name_SystemProperties, &_type_spec_SystemProperties, nullptr);
            py::winrt_type<winrt::Windows::Storage::SystemVideoProperties>::python_type = py::register_python_type(module, _type_name_SystemVideoProperties, &_type_spec_SystemVideoProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::UserDataPaths>::python_type = py::register_python_type(module, _type_name_UserDataPaths, &_type_spec_UserDataPaths, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFile>::python_type = py::register_python_type(module, _type_name_IStorageFile, &_type_spec_IStorageFile, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFile2>::python_type = py::register_python_type(module, _type_name_IStorageFile2, &_type_spec_IStorageFile2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFilePropertiesWithAvailability>::python_type = py::register_python_type(module, _type_name_IStorageFilePropertiesWithAvailability, &_type_spec_IStorageFilePropertiesWithAvailability, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFolder>::python_type = py::register_python_type(module, _type_name_IStorageFolder, &_type_spec_IStorageFolder, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageFolder2>::python_type = py::register_python_type(module, _type_name_IStorageFolder2, &_type_spec_IStorageFolder2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItem>::python_type = py::register_python_type(module, _type_name_IStorageItem, &_type_spec_IStorageItem, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItem2>::python_type = py::register_python_type(module, _type_name_IStorageItem2, &_type_spec_IStorageItem2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItemProperties>::python_type = py::register_python_type(module, _type_name_IStorageItemProperties, &_type_spec_IStorageItemProperties, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItemProperties2>::python_type = py::register_python_type(module, _type_name_IStorageItemProperties2, &_type_spec_IStorageItemProperties2, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStorageItemPropertiesWithProvider>::python_type = py::register_python_type(module, _type_name_IStorageItemPropertiesWithProvider, &_type_spec_IStorageItemPropertiesWithProvider, bases.get());
            py::winrt_type<winrt::Windows::Storage::IStreamedFileDataRequest>::python_type = py::register_python_type(module, _type_name_IStreamedFileDataRequest, &_type_spec_IStreamedFileDataRequest, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Storage");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Storage",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Storage

PyMODINIT_FUNC
PyInit__winsdk_Windows_Storage (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Storage::module_def);
}
