// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.4

#include "pybase.h"
#include "py.Windows.AI.MachineLearning.h"

PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type;

namespace py::cpp::Windows::AI::MachineLearning
{
    // ----- ImageFeatureDescriptor class --------------------
    constexpr const char* const _type_name_ImageFeatureDescriptor = "ImageFeatureDescriptor";

    static PyObject* _new_ImageFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ImageFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_ImageFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapAlphaMode(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_BitmapPixelFormat(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Height(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Width(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_PixelRange(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageFeatureDescriptor[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(ImageFeatureDescriptor_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(ImageFeatureDescriptor_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Width), nullptr, nullptr, nullptr },
        { "pixel_range", reinterpret_cast<getter>(ImageFeatureDescriptor_get_PixelRange), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(ImageFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ImageFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_ImageFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_ImageFeatureDescriptor },
        { Py_tp_methods, _methods_ImageFeatureDescriptor },
        { Py_tp_getset, _getset_ImageFeatureDescriptor },
        { },
    };

    static PyType_Spec _type_spec_ImageFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.ImageFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureDescriptor
    };

    // ----- ImageFeatureValue class --------------------
    constexpr const char* const _type_name_ImageFeatureValue = "ImageFeatureValue";

    static PyObject* _new_ImageFeatureValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ImageFeatureValue);
        return nullptr;
    }

    static void _dealloc_ImageFeatureValue(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageFeatureValue_CreateFromVideoFrame(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::ImageFeatureValue::CreateFromVideoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_VideoFrame(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ImageFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageFeatureValue[] = {
        { "create_from_video_frame", reinterpret_cast<PyCFunction>(ImageFeatureValue_CreateFromVideoFrame), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageFeatureValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageFeatureValue[] = {
        { "video_frame", reinterpret_cast<getter>(ImageFeatureValue_get_VideoFrame), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ImageFeatureValue_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageFeatureValue[] = 
    {
        { Py_tp_new, _new_ImageFeatureValue },
        { Py_tp_dealloc, _dealloc_ImageFeatureValue },
        { Py_tp_methods, _methods_ImageFeatureValue },
        { Py_tp_getset, _getset_ImageFeatureValue },
        { },
    };

    static PyType_Spec _type_spec_ImageFeatureValue =
    {
        "_winsdk_Windows_AI_MachineLearning.ImageFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ImageFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageFeatureValue
    };

    // ----- LearningModel class --------------------
    constexpr const char* const _type_name_LearningModel = "LearningModel";

    static PyObject* _new_LearningModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LearningModel);
        return nullptr;
    }

    static void _dealloc_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModel_Close(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromFilePath(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromFilePath(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStorageFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_LoadFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModel::LoadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Author(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Description(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Domain(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_InputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Metadata(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Metadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Name(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_OutputFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModel_get_Version(py::wrapper::Windows::AI::MachineLearning::LearningModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LearningModel(py::wrapper::Windows::AI::MachineLearning::LearningModel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModel[] = {
        { "close", reinterpret_cast<PyCFunction>(LearningModel_Close), METH_VARARGS, nullptr },
        { "load_from_file_path", reinterpret_cast<PyCFunction>(LearningModel_LoadFromFilePath), METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_storage_file_async", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStorageFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_stream", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "load_from_stream_async", reinterpret_cast<PyCFunction>(LearningModel_LoadFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LearningModel), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LearningModel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModel[] = {
        { "author", reinterpret_cast<getter>(LearningModel_get_Author), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(LearningModel_get_Description), nullptr, nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(LearningModel_get_Domain), nullptr, nullptr, nullptr },
        { "input_features", reinterpret_cast<getter>(LearningModel_get_InputFeatures), nullptr, nullptr, nullptr },
        { "metadata", reinterpret_cast<getter>(LearningModel_get_Metadata), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LearningModel_get_Name), nullptr, nullptr, nullptr },
        { "output_features", reinterpret_cast<getter>(LearningModel_get_OutputFeatures), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(LearningModel_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModel[] = 
    {
        { Py_tp_new, _new_LearningModel },
        { Py_tp_dealloc, _dealloc_LearningModel },
        { Py_tp_methods, _methods_LearningModel },
        { Py_tp_getset, _getset_LearningModel },
        { },
    };

    static PyType_Spec _type_spec_LearningModel =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModel",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModel
    };

    // ----- LearningModelBinding class --------------------
    constexpr const char* const _type_name_LearningModelBinding = "LearningModelBinding";

    static PyObject* _new_LearningModelBinding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSession>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelBinding instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelBinding_Bind(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.Bind(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                self->obj.Bind(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Clear(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_First(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_HasKey(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Lookup(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_Split(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0 { nullptr };
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1 { nullptr };

                self->obj.Split(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out0.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelBinding_get_Size(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_LearningModelBinding(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelBinding[] = {
        { "bind", reinterpret_cast<PyCFunction>(LearningModelBinding_Bind), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(LearningModelBinding_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(LearningModelBinding_First), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(LearningModelBinding_HasKey), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(LearningModelBinding_Lookup), METH_VARARGS, nullptr },
        { "split", reinterpret_cast<PyCFunction>(LearningModelBinding_Split), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelBinding), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelBinding[] = {
        { "size", reinterpret_cast<getter>(LearningModelBinding_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelBinding[] = 
    {
        { Py_tp_new, _new_LearningModelBinding },
        { Py_tp_dealloc, _dealloc_LearningModelBinding },
        { Py_tp_methods, _methods_LearningModelBinding },
        { Py_tp_getset, _getset_LearningModelBinding },
        { Py_tp_iter, _iterator_LearningModelBinding },
        { Py_sq_contains, _map_contains_LearningModelBinding },
        { Py_mp_length, _map_length_LearningModelBinding },
        { Py_mp_subscript, _map_subscript_LearningModelBinding },
        { },
    };

    static PyType_Spec _type_spec_LearningModelBinding =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelBinding",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelBinding
    };

    // ----- LearningModelDevice class --------------------
    constexpr const char* const _type_name_LearningModelDevice = "LearningModelDevice";

    static PyObject* _new_LearningModelDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDeviceKind>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelDevice instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelDevice(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelDevice_CreateFromDirect3D11Device(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::LearningModelDevice::CreateFromDirect3D11Device(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_AdapterId(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelDevice_get_Direct3D11Device(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelDevice[] = {
        { "create_from_direct3_d11_device", reinterpret_cast<PyCFunction>(LearningModelDevice_CreateFromDirect3D11Device), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelDevice[] = {
        { "adapter_id", reinterpret_cast<getter>(LearningModelDevice_get_AdapterId), nullptr, nullptr, nullptr },
        { "direct3_d11_device", reinterpret_cast<getter>(LearningModelDevice_get_Direct3D11Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelDevice[] = 
    {
        { Py_tp_new, _new_LearningModelDevice },
        { Py_tp_dealloc, _dealloc_LearningModelDevice },
        { Py_tp_methods, _methods_LearningModelDevice },
        { Py_tp_getset, _getset_LearningModelDevice },
        { },
    };

    static PyType_Spec _type_spec_LearningModelDevice =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelDevice",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelDevice
    };

    // ----- LearningModelEvaluationResult class --------------------
    constexpr const char* const _type_name_LearningModelEvaluationResult = "LearningModelEvaluationResult";

    static PyObject* _new_LearningModelEvaluationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LearningModelEvaluationResult);
        return nullptr;
    }

    static void _dealloc_LearningModelEvaluationResult(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelEvaluationResult_get_CorrelationId(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CorrelationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_ErrorStatus(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Outputs(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Outputs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelEvaluationResult_get_Succeeded(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Succeeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelEvaluationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelEvaluationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelEvaluationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelEvaluationResult[] = {
        { "correlation_id", reinterpret_cast<getter>(LearningModelEvaluationResult_get_CorrelationId), nullptr, nullptr, nullptr },
        { "error_status", reinterpret_cast<getter>(LearningModelEvaluationResult_get_ErrorStatus), nullptr, nullptr, nullptr },
        { "outputs", reinterpret_cast<getter>(LearningModelEvaluationResult_get_Outputs), nullptr, nullptr, nullptr },
        { "succeeded", reinterpret_cast<getter>(LearningModelEvaluationResult_get_Succeeded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelEvaluationResult[] = 
    {
        { Py_tp_new, _new_LearningModelEvaluationResult },
        { Py_tp_dealloc, _dealloc_LearningModelEvaluationResult },
        { Py_tp_methods, _methods_LearningModelEvaluationResult },
        { Py_tp_getset, _getset_LearningModelEvaluationResult },
        { },
    };

    static PyType_Spec _type_spec_LearningModelEvaluationResult =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelEvaluationResult",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelEvaluationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelEvaluationResult
    };

    // ----- LearningModelSession class --------------------
    constexpr const char* const _type_name_LearningModelSession = "LearningModelSession";

    static PyObject* _new_LearningModelSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>(args, 2);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelDevice>(args, 1);

                winrt::Windows::AI::MachineLearning::LearningModelSession instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelSession_Close(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_Evaluate(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Evaluate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::AI::MachineLearning::LearningModelBinding>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeatures(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeatures(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_EvaluateFeaturesAsync(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IMap<winrt::hstring, winrt::Windows::Foundation::IInspectable>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.EvaluateFeaturesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Device(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_EvaluationProperties(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EvaluationProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LearningModelSession_get_Model(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LearningModelSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LearningModelSession(py::wrapper::Windows::AI::MachineLearning::LearningModelSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSession[] = {
        { "close", reinterpret_cast<PyCFunction>(LearningModelSession_Close), METH_VARARGS, nullptr },
        { "evaluate", reinterpret_cast<PyCFunction>(LearningModelSession_Evaluate), METH_VARARGS, nullptr },
        { "evaluate_async", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateAsync), METH_VARARGS, nullptr },
        { "evaluate_features", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateFeatures), METH_VARARGS, nullptr },
        { "evaluate_features_async", reinterpret_cast<PyCFunction>(LearningModelSession_EvaluateFeaturesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LearningModelSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LearningModelSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelSession[] = {
        { "device", reinterpret_cast<getter>(LearningModelSession_get_Device), nullptr, nullptr, nullptr },
        { "evaluation_properties", reinterpret_cast<getter>(LearningModelSession_get_EvaluationProperties), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(LearningModelSession_get_Model), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelSession[] = 
    {
        { Py_tp_new, _new_LearningModelSession },
        { Py_tp_dealloc, _dealloc_LearningModelSession },
        { Py_tp_methods, _methods_LearningModelSession },
        { Py_tp_getset, _getset_LearningModelSession },
        { },
    };

    static PyType_Spec _type_spec_LearningModelSession =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelSession",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSession
    };

    // ----- LearningModelSessionOptions class --------------------
    constexpr const char* const _type_name_LearningModelSessionOptions = "LearningModelSessionOptions";

    static PyObject* _new_LearningModelSessionOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::AI::MachineLearning::LearningModelSessionOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LearningModelSessionOptions(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LearningModelSessionOptions_OverrideNamedDimension(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.OverrideNamedDimension(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LearningModelSessionOptions_get_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BatchSizeOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_BatchSizeOverride(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BatchSizeOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LearningModelSessionOptions_get_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CloseModelOnSessionCreation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LearningModelSessionOptions_put_CloseModelOnSessionCreation(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CloseModelOnSessionCreation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LearningModelSessionOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LearningModelSessionOptions[] = {
        { "override_named_dimension", reinterpret_cast<PyCFunction>(LearningModelSessionOptions_OverrideNamedDimension), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LearningModelSessionOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LearningModelSessionOptions[] = {
        { "batch_size_override", reinterpret_cast<getter>(LearningModelSessionOptions_get_BatchSizeOverride), reinterpret_cast<setter>(LearningModelSessionOptions_put_BatchSizeOverride), nullptr, nullptr },
        { "close_model_on_session_creation", reinterpret_cast<getter>(LearningModelSessionOptions_get_CloseModelOnSessionCreation), reinterpret_cast<setter>(LearningModelSessionOptions_put_CloseModelOnSessionCreation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LearningModelSessionOptions[] = 
    {
        { Py_tp_new, _new_LearningModelSessionOptions },
        { Py_tp_dealloc, _dealloc_LearningModelSessionOptions },
        { Py_tp_methods, _methods_LearningModelSessionOptions },
        { Py_tp_getset, _getset_LearningModelSessionOptions },
        { },
    };

    static PyType_Spec _type_spec_LearningModelSessionOptions =
    {
        "_winsdk_Windows_AI_MachineLearning.LearningModelSessionOptions",
        sizeof(py::wrapper::Windows::AI::MachineLearning::LearningModelSessionOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LearningModelSessionOptions
    };

    // ----- MapFeatureDescriptor class --------------------
    constexpr const char* const _type_name_MapFeatureDescriptor = "MapFeatureDescriptor";

    static PyObject* _new_MapFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MapFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_MapFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MapFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_KeyKind(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MapFeatureDescriptor_get_ValueDescriptor(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValueDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MapFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MapFeatureDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MapFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MapFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(MapFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(MapFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(MapFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(MapFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "key_kind", reinterpret_cast<getter>(MapFeatureDescriptor_get_KeyKind), nullptr, nullptr, nullptr },
        { "value_descriptor", reinterpret_cast<getter>(MapFeatureDescriptor_get_ValueDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MapFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_MapFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_MapFeatureDescriptor },
        { Py_tp_methods, _methods_MapFeatureDescriptor },
        { Py_tp_getset, _getset_MapFeatureDescriptor },
        { },
    };

    static PyType_Spec _type_spec_MapFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.MapFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::MapFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MapFeatureDescriptor
    };

    // ----- SequenceFeatureDescriptor class --------------------
    constexpr const char* const _type_name_SequenceFeatureDescriptor = "SequenceFeatureDescriptor";

    static PyObject* _new_SequenceFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SequenceFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_SequenceFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SequenceFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SequenceFeatureDescriptor_get_ElementDescriptor(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ElementDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SequenceFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SequenceFeatureDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SequenceFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SequenceFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "element_descriptor", reinterpret_cast<getter>(SequenceFeatureDescriptor_get_ElementDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SequenceFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_SequenceFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_SequenceFeatureDescriptor },
        { Py_tp_methods, _methods_SequenceFeatureDescriptor },
        { Py_tp_getset, _getset_SequenceFeatureDescriptor },
        { },
    };

    static PyType_Spec _type_spec_SequenceFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.SequenceFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::SequenceFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SequenceFeatureDescriptor
    };

    // ----- TensorBoolean class --------------------
    constexpr const char* const _type_name_TensorBoolean = "TensorBoolean";

    static PyObject* _new_TensorBoolean(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorBoolean);
        return nullptr;
    }

    static void _dealloc_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorBoolean_Close(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorBoolean::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorBoolean_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorBoolean(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorBoolean>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorBoolean(py::wrapper::Windows::AI::MachineLearning::TensorBoolean* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorBoolean[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorBoolean_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorBoolean_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorBoolean_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorBoolean_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorBoolean_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorBoolean), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorBoolean), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorBoolean), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorBoolean[] = {
        { "kind", reinterpret_cast<getter>(TensorBoolean_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorBoolean_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorBoolean_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorBoolean[] = 
    {
        { Py_tp_new, _new_TensorBoolean },
        { Py_tp_dealloc, _dealloc_TensorBoolean },
        { Py_tp_methods, _methods_TensorBoolean },
        { Py_tp_getset, _getset_TensorBoolean },
        { },
    };

    static PyType_Spec _type_spec_TensorBoolean =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorBoolean",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorBoolean),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorBoolean
    };

    // ----- TensorDouble class --------------------
    constexpr const char* const _type_name_TensorDouble = "TensorDouble";

    static PyObject* _new_TensorDouble(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorDouble);
        return nullptr;
    }

    static void _dealloc_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorDouble_Close(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorDouble::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorDouble_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorDouble(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorDouble>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorDouble(py::wrapper::Windows::AI::MachineLearning::TensorDouble* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorDouble[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorDouble_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorDouble_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorDouble_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorDouble_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorDouble_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorDouble), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorDouble), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorDouble), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorDouble[] = {
        { "kind", reinterpret_cast<getter>(TensorDouble_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorDouble_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorDouble_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorDouble[] = 
    {
        { Py_tp_new, _new_TensorDouble },
        { Py_tp_dealloc, _dealloc_TensorDouble },
        { Py_tp_methods, _methods_TensorDouble },
        { Py_tp_getset, _getset_TensorDouble },
        { },
    };

    static PyType_Spec _type_spec_TensorDouble =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorDouble",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorDouble
    };

    // ----- TensorFeatureDescriptor class --------------------
    constexpr const char* const _type_name_TensorFeatureDescriptor = "TensorFeatureDescriptor";

    static PyObject* _new_TensorFeatureDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_TensorFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFeatureDescriptor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFeatureDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(TensorFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFeatureDescriptor_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFeatureDescriptor_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_TensorFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_TensorFeatureDescriptor },
        { Py_tp_methods, _methods_TensorFeatureDescriptor },
        { Py_tp_getset, _getset_TensorFeatureDescriptor },
        { },
    };

    static PyType_Spec _type_spec_TensorFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFeatureDescriptor
    };

    // ----- TensorFloat class --------------------
    constexpr const char* const _type_name_TensorFloat = "TensorFloat";

    static PyObject* _new_TensorFloat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorFloat);
        return nullptr;
    }

    static void _dealloc_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorFloat_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorFloat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorFloat(py::wrapper::Windows::AI::MachineLearning::TensorFloat* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorFloat_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorFloat_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorFloat_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorFloat_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorFloat_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFloat), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorFloat), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorFloat), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFloat[] = {
        { "kind", reinterpret_cast<getter>(TensorFloat_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFloat_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFloat_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFloat[] = 
    {
        { Py_tp_new, _new_TensorFloat },
        { Py_tp_dealloc, _dealloc_TensorFloat },
        { Py_tp_methods, _methods_TensorFloat },
        { Py_tp_getset, _getset_TensorFloat },
        { },
    };

    static PyType_Spec _type_spec_TensorFloat =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorFloat",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat
    };

    // ----- TensorFloat16Bit class --------------------
    constexpr const char* const _type_name_TensorFloat16Bit = "TensorFloat16Bit";

    static PyObject* _new_TensorFloat16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorFloat16Bit);
        return nullptr;
    }

    static void _dealloc_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorFloat16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorFloat16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorFloat16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorFloat16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorFloat16Bit(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorFloat16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorFloat16Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorFloat16Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorFloat16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorFloat16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorFloat16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorFloat16Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorFloat16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorFloat16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorFloat16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorFloat16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorFloat16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorFloat16Bit[] = 
    {
        { Py_tp_new, _new_TensorFloat16Bit },
        { Py_tp_dealloc, _dealloc_TensorFloat16Bit },
        { Py_tp_methods, _methods_TensorFloat16Bit },
        { Py_tp_getset, _getset_TensorFloat16Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorFloat16Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorFloat16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorFloat16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorFloat16Bit
    };

    // ----- TensorInt16Bit class --------------------
    constexpr const char* const _type_name_TensorInt16Bit = "TensorInt16Bit";

    static PyObject* _new_TensorInt16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt16Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt16Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt16Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt16Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt16Bit[] = 
    {
        { Py_tp_new, _new_TensorInt16Bit },
        { Py_tp_dealloc, _dealloc_TensorInt16Bit },
        { Py_tp_methods, _methods_TensorInt16Bit },
        { Py_tp_getset, _getset_TensorInt16Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorInt16Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt16Bit
    };

    // ----- TensorInt32Bit class --------------------
    constexpr const char* const _type_name_TensorInt32Bit = "TensorInt32Bit";

    static PyObject* _new_TensorInt32Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt32Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt32Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt32Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt32Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt32Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt32Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt32Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt32Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt32Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt32Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt32Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt32Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt32Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt32Bit[] = 
    {
        { Py_tp_new, _new_TensorInt32Bit },
        { Py_tp_dealloc, _dealloc_TensorInt32Bit },
        { Py_tp_methods, _methods_TensorInt32Bit },
        { Py_tp_getset, _getset_TensorInt32Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorInt32Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt32Bit
    };

    // ----- TensorInt64Bit class --------------------
    constexpr const char* const _type_name_TensorInt64Bit = "TensorInt64Bit";

    static PyObject* _new_TensorInt64Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt64Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt64Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt64Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt64Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt64Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt64Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt64Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt64Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt64Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt64Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt64Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt64Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt64Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt64Bit[] = 
    {
        { Py_tp_new, _new_TensorInt64Bit },
        { Py_tp_dealloc, _dealloc_TensorInt64Bit },
        { Py_tp_methods, _methods_TensorInt64Bit },
        { Py_tp_getset, _getset_TensorInt64Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorInt64Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt64Bit
    };

    // ----- TensorInt8Bit class --------------------
    constexpr const char* const _type_name_TensorInt8Bit = "TensorInt8Bit";

    static PyObject* _new_TensorInt8Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorInt8Bit);
        return nullptr;
    }

    static void _dealloc_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorInt8Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorInt8Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorInt8Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorInt8Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorInt8Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorInt8Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorInt8Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorInt8Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorInt8Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorInt8Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorInt8Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorInt8Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorInt8Bit[] = 
    {
        { Py_tp_new, _new_TensorInt8Bit },
        { Py_tp_dealloc, _dealloc_TensorInt8Bit },
        { Py_tp_methods, _methods_TensorInt8Bit },
        { Py_tp_getset, _getset_TensorInt8Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorInt8Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorInt8Bit
    };

    // ----- TensorString class --------------------
    constexpr const char* const _type_name_TensorString = "TensorString";

    static PyObject* _new_TensorString(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorString);
        return nullptr;
    }

    static void _dealloc_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorString_Close(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorString::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorString* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorString_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorString* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorString(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorString>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorString(py::wrapper::Windows::AI::MachineLearning::TensorString* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorString[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorString_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorString_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorString_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorString_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorString_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorString_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorString_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorString), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorString), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorString), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorString[] = {
        { "kind", reinterpret_cast<getter>(TensorString_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorString_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorString_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorString[] = 
    {
        { Py_tp_new, _new_TensorString },
        { Py_tp_dealloc, _dealloc_TensorString },
        { Py_tp_methods, _methods_TensorString },
        { Py_tp_getset, _getset_TensorString },
        { },
    };

    static PyType_Spec _type_spec_TensorString =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorString",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorString),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorString
    };

    // ----- TensorUInt16Bit class --------------------
    constexpr const char* const _type_name_TensorUInt16Bit = "TensorUInt16Bit";

    static PyObject* _new_TensorUInt16Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt16Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt16Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt16Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt16Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt16Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt16Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt16Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt16Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt16Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt16Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt16Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt16Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt16Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt16Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt16Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt16Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt16Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt16Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt16Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt16Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt16Bit },
        { Py_tp_methods, _methods_TensorUInt16Bit },
        { Py_tp_getset, _getset_TensorUInt16Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorUInt16Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt16Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt16Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt16Bit
    };

    // ----- TensorUInt32Bit class --------------------
    constexpr const char* const _type_name_TensorUInt32Bit = "TensorUInt32Bit";

    static PyObject* _new_TensorUInt32Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt32Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt32Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt32Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt32Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt32Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt32Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt32Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt32Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt32Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt32Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt32Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt32Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt32Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt32Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt32Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt32Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt32Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt32Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt32Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt32Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt32Bit },
        { Py_tp_methods, _methods_TensorUInt32Bit },
        { Py_tp_getset, _getset_TensorUInt32Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorUInt32Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt32Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt32Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt32Bit
    };

    // ----- TensorUInt64Bit class --------------------
    constexpr const char* const _type_name_TensorUInt64Bit = "TensorUInt64Bit";

    static PyObject* _new_TensorUInt64Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt64Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt64Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt64Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt64Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt64Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt64Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt64Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt64Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt64Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt64Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt64Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt64Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt64Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt64Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt64Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt64Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt64Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt64Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt64Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt64Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt64Bit },
        { Py_tp_methods, _methods_TensorUInt64Bit },
        { Py_tp_getset, _getset_TensorUInt64Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorUInt64Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt64Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt64Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt64Bit
    };

    // ----- TensorUInt8Bit class --------------------
    constexpr const char* const _type_name_TensorUInt8Bit = "TensorUInt8Bit";

    static PyObject* _new_TensorUInt8Bit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TensorUInt8Bit);
        return nullptr;
    }

    static void _dealloc_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TensorUInt8Bit_Close(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromIterable(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromIterable(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateFromShapeArrayAndDataArray(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<int64_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(winrt::Windows::AI::MachineLearning::TensorUInt8Bit::CreateFromShapeArrayAndDataArray(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_CreateReference(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_GetAsVectorView(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAsVectorView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Kind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_Shape(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TensorUInt8Bit_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TensorUInt8Bit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_TensorUInt8Bit(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TensorUInt8Bit[] = {
        { "close", reinterpret_cast<PyCFunction>(TensorUInt8Bit_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(TensorUInt8Bit_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_array", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_buffer", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_iterable", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromIterable), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_shape_array_and_data_array", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateFromShapeArrayAndDataArray), METH_VARARGS | METH_STATIC, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(TensorUInt8Bit_CreateReference), METH_VARARGS, nullptr },
        { "get_as_vector_view", reinterpret_cast<PyCFunction>(TensorUInt8Bit_GetAsVectorView), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TensorUInt8Bit), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_TensorUInt8Bit), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_TensorUInt8Bit), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_TensorUInt8Bit[] = {
        { "kind", reinterpret_cast<getter>(TensorUInt8Bit_get_Kind), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(TensorUInt8Bit_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(TensorUInt8Bit_get_TensorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TensorUInt8Bit[] = 
    {
        { Py_tp_new, _new_TensorUInt8Bit },
        { Py_tp_dealloc, _dealloc_TensorUInt8Bit },
        { Py_tp_methods, _methods_TensorUInt8Bit },
        { Py_tp_getset, _getset_TensorUInt8Bit },
        { },
    };

    static PyType_Spec _type_spec_TensorUInt8Bit =
    {
        "_winsdk_Windows_AI_MachineLearning.TensorUInt8Bit",
        sizeof(py::wrapper::Windows::AI::MachineLearning::TensorUInt8Bit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TensorUInt8Bit
    };

    // ----- ILearningModelFeatureDescriptor interface --------------------
    constexpr const char* const _type_name_ILearningModelFeatureDescriptor = "ILearningModelFeatureDescriptor";

    static PyObject* _new_ILearningModelFeatureDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILearningModelFeatureDescriptor);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureDescriptor(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Description(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_IsRequired(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILearningModelFeatureDescriptor_get_Name(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILearningModelFeatureDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelFeatureDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelFeatureDescriptor[] = {
        { "description", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Description), nullptr, nullptr, nullptr },
        { "is_required", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_IsRequired), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Kind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ILearningModelFeatureDescriptor_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureDescriptor[] = 
    {
        { Py_tp_new, _new_ILearningModelFeatureDescriptor },
        { Py_tp_dealloc, _dealloc_ILearningModelFeatureDescriptor },
        { Py_tp_methods, _methods_ILearningModelFeatureDescriptor },
        { Py_tp_getset, _getset_ILearningModelFeatureDescriptor },
        { },
    };

    static PyType_Spec _type_spec_ILearningModelFeatureDescriptor =
    {
        "_winsdk_Windows_AI_MachineLearning.ILearningModelFeatureDescriptor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureDescriptor
    };

    // ----- ILearningModelFeatureValue interface --------------------
    constexpr const char* const _type_name_ILearningModelFeatureValue = "ILearningModelFeatureValue";

    static PyObject* _new_ILearningModelFeatureValue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILearningModelFeatureValue);
        return nullptr;
    }

    static void _dealloc_ILearningModelFeatureValue(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILearningModelFeatureValue_get_Kind(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILearningModelFeatureValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelFeatureValue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelFeatureValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelFeatureValue[] = {
        { "kind", reinterpret_cast<getter>(ILearningModelFeatureValue_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILearningModelFeatureValue[] = 
    {
        { Py_tp_new, _new_ILearningModelFeatureValue },
        { Py_tp_dealloc, _dealloc_ILearningModelFeatureValue },
        { Py_tp_methods, _methods_ILearningModelFeatureValue },
        { Py_tp_getset, _getset_ILearningModelFeatureValue },
        { },
    };

    static PyType_Spec _type_spec_ILearningModelFeatureValue =
    {
        "_winsdk_Windows_AI_MachineLearning.ILearningModelFeatureValue",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelFeatureValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelFeatureValue
    };

    // ----- ILearningModelOperatorProvider interface --------------------
    constexpr const char* const _type_name_ILearningModelOperatorProvider = "ILearningModelOperatorProvider";

    static PyObject* _new_ILearningModelOperatorProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILearningModelOperatorProvider);
        return nullptr;
    }

    static void _dealloc_ILearningModelOperatorProvider(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ILearningModelOperatorProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILearningModelOperatorProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILearningModelOperatorProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILearningModelOperatorProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ILearningModelOperatorProvider[] = 
    {
        { Py_tp_new, _new_ILearningModelOperatorProvider },
        { Py_tp_dealloc, _dealloc_ILearningModelOperatorProvider },
        { Py_tp_methods, _methods_ILearningModelOperatorProvider },
        { Py_tp_getset, _getset_ILearningModelOperatorProvider },
        { },
    };

    static PyType_Spec _type_spec_ILearningModelOperatorProvider =
    {
        "_winsdk_Windows_AI_MachineLearning.ILearningModelOperatorProvider",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ILearningModelOperatorProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILearningModelOperatorProvider
    };

    // ----- ITensor interface --------------------
    constexpr const char* const _type_name_ITensor = "ITensor";

    static PyObject* _new_ITensor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITensor);
        return nullptr;
    }

    static void _dealloc_ITensor(py::wrapper::Windows::AI::MachineLearning::ITensor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITensor_get_Shape(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_TensorKind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TensorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITensor_get_Kind(py::wrapper::Windows::AI::MachineLearning::ITensor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ITensor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::AI::MachineLearning::ITensor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITensor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ITensor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITensor[] = {
        { "shape", reinterpret_cast<getter>(ITensor_get_Shape), nullptr, nullptr, nullptr },
        { "tensor_kind", reinterpret_cast<getter>(ITensor_get_TensorKind), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ITensor_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITensor[] = 
    {
        { Py_tp_new, _new_ITensor },
        { Py_tp_dealloc, _dealloc_ITensor },
        { Py_tp_methods, _methods_ITensor },
        { Py_tp_getset, _getset_ITensor },
        { },
    };

    static PyType_Spec _type_spec_ITensor =
    {
        "_winsdk_Windows_AI_MachineLearning.ITensor",
        sizeof(py::wrapper::Windows::AI::MachineLearning::ITensor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITensor
    };

    // ----- Windows.AI.MachineLearning Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_ImageFeatureDescriptor, &_type_spec_ImageFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ImageFeatureValue>::python_type = py::register_python_type(module, _type_name_ImageFeatureValue, &_type_spec_ImageFeatureValue, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModel>::python_type = py::register_python_type(module, _type_name_LearningModel, &_type_spec_LearningModel, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelBinding>::python_type = py::register_python_type(module, _type_name_LearningModelBinding, &_type_spec_LearningModelBinding, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelDevice>::python_type = py::register_python_type(module, _type_name_LearningModelDevice, &_type_spec_LearningModelDevice, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelEvaluationResult>::python_type = py::register_python_type(module, _type_name_LearningModelEvaluationResult, &_type_spec_LearningModelEvaluationResult, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSession>::python_type = py::register_python_type(module, _type_name_LearningModelSession, &_type_spec_LearningModelSession, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::LearningModelSessionOptions>::python_type = py::register_python_type(module, _type_name_LearningModelSessionOptions, &_type_spec_LearningModelSessionOptions, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::MapFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_MapFeatureDescriptor, &_type_spec_MapFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::SequenceFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_SequenceFeatureDescriptor, &_type_spec_SequenceFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorBoolean>::python_type = py::register_python_type(module, _type_name_TensorBoolean, &_type_spec_TensorBoolean, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorDouble>::python_type = py::register_python_type(module, _type_name_TensorDouble, &_type_spec_TensorDouble, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_TensorFeatureDescriptor, &_type_spec_TensorFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat>::python_type = py::register_python_type(module, _type_name_TensorFloat, &_type_spec_TensorFloat, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorFloat16Bit>::python_type = py::register_python_type(module, _type_name_TensorFloat16Bit, &_type_spec_TensorFloat16Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt16Bit>::python_type = py::register_python_type(module, _type_name_TensorInt16Bit, &_type_spec_TensorInt16Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt32Bit>::python_type = py::register_python_type(module, _type_name_TensorInt32Bit, &_type_spec_TensorInt32Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt64Bit>::python_type = py::register_python_type(module, _type_name_TensorInt64Bit, &_type_spec_TensorInt64Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorInt8Bit>::python_type = py::register_python_type(module, _type_name_TensorInt8Bit, &_type_spec_TensorInt8Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorString>::python_type = py::register_python_type(module, _type_name_TensorString, &_type_spec_TensorString, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt16Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt16Bit, &_type_spec_TensorUInt16Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt32Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt32Bit, &_type_spec_TensorUInt32Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt64Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt64Bit, &_type_spec_TensorUInt64Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::TensorUInt8Bit>::python_type = py::register_python_type(module, _type_name_TensorUInt8Bit, &_type_spec_TensorUInt8Bit, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureDescriptor>::python_type = py::register_python_type(module, _type_name_ILearningModelFeatureDescriptor, &_type_spec_ILearningModelFeatureDescriptor, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelFeatureValue>::python_type = py::register_python_type(module, _type_name_ILearningModelFeatureValue, &_type_spec_ILearningModelFeatureValue, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ILearningModelOperatorProvider>::python_type = py::register_python_type(module, _type_name_ILearningModelOperatorProvider, &_type_spec_ILearningModelOperatorProvider, bases.get());
            py::winrt_type<winrt::Windows::AI::MachineLearning::ITensor>::python_type = py::register_python_type(module, _type_name_ITensor, &_type_spec_ITensor, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.AI.MachineLearning");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_AI_MachineLearning",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::AI::MachineLearning

PyMODINIT_FUNC
PyInit__winsdk_Windows_AI_MachineLearning (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::AI::MachineLearning::module_def);
}
