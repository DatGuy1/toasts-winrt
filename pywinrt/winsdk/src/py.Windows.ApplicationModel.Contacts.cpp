// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Contacts.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::Contact>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAddress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactBatch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactDate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactEmail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPhone>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPicker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::KnownContactField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactField>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>::python_type;

namespace py::cpp::Windows::ApplicationModel::Contacts
{
    // ----- AggregateContactManager class --------------------
    constexpr const char* const _type_name_AggregateContactManager = "AggregateContactManager";

    static PyObject* _new_AggregateContactManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AggregateContactManager);
        return nullptr;
    }

    static void _dealloc_AggregateContactManager(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AggregateContactManager_FindRawContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.FindRawContactsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_SetRemoteIdentificationInformationAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.SetRemoteIdentificationInformationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_TryLinkContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 1);

                return py::convert(self->obj.TryLinkContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_TrySetPreferredSourceForPictureAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 1);

                return py::convert(self->obj.TrySetPreferredSourceForPictureAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AggregateContactManager_UnlinkRawContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.UnlinkRawContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AggregateContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AggregateContactManager[] = {
        { "find_raw_contacts_async", reinterpret_cast<PyCFunction>(AggregateContactManager_FindRawContactsAsync), METH_VARARGS, nullptr },
        { "set_remote_identification_information_async", reinterpret_cast<PyCFunction>(AggregateContactManager_SetRemoteIdentificationInformationAsync), METH_VARARGS, nullptr },
        { "try_link_contacts_async", reinterpret_cast<PyCFunction>(AggregateContactManager_TryLinkContactsAsync), METH_VARARGS, nullptr },
        { "try_set_preferred_source_for_picture_async", reinterpret_cast<PyCFunction>(AggregateContactManager_TrySetPreferredSourceForPictureAsync), METH_VARARGS, nullptr },
        { "unlink_raw_contact_async", reinterpret_cast<PyCFunction>(AggregateContactManager_UnlinkRawContactAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AggregateContactManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AggregateContactManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AggregateContactManager[] = 
    {
        { Py_tp_new, _new_AggregateContactManager },
        { Py_tp_dealloc, _dealloc_AggregateContactManager },
        { Py_tp_methods, _methods_AggregateContactManager },
        { Py_tp_getset, _getset_AggregateContactManager },
        { },
    };

    static PyType_Spec _type_spec_AggregateContactManager =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.AggregateContactManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::AggregateContactManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AggregateContactManager
    };

    // ----- Contact class --------------------
    constexpr const char* const _type_name_Contact = "Contact";

    static PyObject* _new_Contact(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::Contact instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Contact(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Contact_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Name(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Fields(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Id(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Notes(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Notes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Notes(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Notes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_ConnectedServiceAccounts(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectedServiceAccounts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Emails(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Addresses(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Addresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_ImportantDates(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImportantDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_JobInfo(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.JobInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_DataSuppliers(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataSuppliers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Phones(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Phones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_ProviderProperties(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SignificantOthers(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignificantOthers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_Websites(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Websites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SourceDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_SourceDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.SourceDisplayPicture(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_TextToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextToneToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_TextToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TextToneToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayNameOverride(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_DisplayNameOverride(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayPictureUserUpdateTime(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayPictureUserUpdateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_DisplayPictureUserUpdateTime(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.DisplayPictureUserUpdateTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_Nickname(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_Nickname(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Nickname(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_RingToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RingToneToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_RingToneToken(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RingToneToken(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_LargeDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LargeDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SmallDisplayPicture(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmallDisplayPicture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_SortName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SortName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_AggregateId(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AggregateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_FullName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsAggregate(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAggregate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsDisplayPictureManuallySet(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisplayPictureManuallySet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_IsMe(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_YomiGivenName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YomiGivenName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_YomiGivenName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YomiGivenName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_HonorificNameSuffix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HonorificNameSuffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_HonorificNameSuffix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificNameSuffix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_YomiFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YomiFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_YomiFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.YomiFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_MiddleName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MiddleName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_MiddleName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MiddleName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_LastName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_LastName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LastName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_HonorificNamePrefix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HonorificNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_HonorificNamePrefix(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HonorificNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_FirstName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Contact_put_FirstName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FirstName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Contact_get_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Contact_get_YomiDisplayName(py::wrapper::Windows::ApplicationModel::Contacts::Contact* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.YomiDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Contact(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::Contact>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Contact[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Contact), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Contact[] = {
        { "thumbnail", reinterpret_cast<getter>(Contact_get_Thumbnail), reinterpret_cast<setter>(Contact_put_Thumbnail), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(Contact_get_Name), reinterpret_cast<setter>(Contact_put_Name), nullptr, nullptr },
        { "fields", reinterpret_cast<getter>(Contact_get_Fields), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(Contact_get_Id), reinterpret_cast<setter>(Contact_put_Id), nullptr, nullptr },
        { "notes", reinterpret_cast<getter>(Contact_get_Notes), reinterpret_cast<setter>(Contact_put_Notes), nullptr, nullptr },
        { "connected_service_accounts", reinterpret_cast<getter>(Contact_get_ConnectedServiceAccounts), nullptr, nullptr, nullptr },
        { "emails", reinterpret_cast<getter>(Contact_get_Emails), nullptr, nullptr, nullptr },
        { "addresses", reinterpret_cast<getter>(Contact_get_Addresses), nullptr, nullptr, nullptr },
        { "important_dates", reinterpret_cast<getter>(Contact_get_ImportantDates), nullptr, nullptr, nullptr },
        { "job_info", reinterpret_cast<getter>(Contact_get_JobInfo), nullptr, nullptr, nullptr },
        { "data_suppliers", reinterpret_cast<getter>(Contact_get_DataSuppliers), nullptr, nullptr, nullptr },
        { "phones", reinterpret_cast<getter>(Contact_get_Phones), nullptr, nullptr, nullptr },
        { "provider_properties", reinterpret_cast<getter>(Contact_get_ProviderProperties), nullptr, nullptr, nullptr },
        { "significant_others", reinterpret_cast<getter>(Contact_get_SignificantOthers), nullptr, nullptr, nullptr },
        { "websites", reinterpret_cast<getter>(Contact_get_Websites), nullptr, nullptr, nullptr },
        { "source_display_picture", reinterpret_cast<getter>(Contact_get_SourceDisplayPicture), reinterpret_cast<setter>(Contact_put_SourceDisplayPicture), nullptr, nullptr },
        { "text_tone_token", reinterpret_cast<getter>(Contact_get_TextToneToken), reinterpret_cast<setter>(Contact_put_TextToneToken), nullptr, nullptr },
        { "display_name_override", reinterpret_cast<getter>(Contact_get_DisplayNameOverride), reinterpret_cast<setter>(Contact_put_DisplayNameOverride), nullptr, nullptr },
        { "display_picture_user_update_time", reinterpret_cast<getter>(Contact_get_DisplayPictureUserUpdateTime), reinterpret_cast<setter>(Contact_put_DisplayPictureUserUpdateTime), nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(Contact_get_Nickname), reinterpret_cast<setter>(Contact_put_Nickname), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(Contact_get_RemoteId), reinterpret_cast<setter>(Contact_put_RemoteId), nullptr, nullptr },
        { "ring_tone_token", reinterpret_cast<getter>(Contact_get_RingToneToken), reinterpret_cast<setter>(Contact_put_RingToneToken), nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(Contact_get_ContactListId), nullptr, nullptr, nullptr },
        { "large_display_picture", reinterpret_cast<getter>(Contact_get_LargeDisplayPicture), nullptr, nullptr, nullptr },
        { "small_display_picture", reinterpret_cast<getter>(Contact_get_SmallDisplayPicture), nullptr, nullptr, nullptr },
        { "sort_name", reinterpret_cast<getter>(Contact_get_SortName), nullptr, nullptr, nullptr },
        { "aggregate_id", reinterpret_cast<getter>(Contact_get_AggregateId), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(Contact_get_FullName), nullptr, nullptr, nullptr },
        { "is_aggregate", reinterpret_cast<getter>(Contact_get_IsAggregate), nullptr, nullptr, nullptr },
        { "is_display_picture_manually_set", reinterpret_cast<getter>(Contact_get_IsDisplayPictureManuallySet), nullptr, nullptr, nullptr },
        { "is_me", reinterpret_cast<getter>(Contact_get_IsMe), nullptr, nullptr, nullptr },
        { "yomi_given_name", reinterpret_cast<getter>(Contact_get_YomiGivenName), reinterpret_cast<setter>(Contact_put_YomiGivenName), nullptr, nullptr },
        { "honorific_name_suffix", reinterpret_cast<getter>(Contact_get_HonorificNameSuffix), reinterpret_cast<setter>(Contact_put_HonorificNameSuffix), nullptr, nullptr },
        { "yomi_family_name", reinterpret_cast<getter>(Contact_get_YomiFamilyName), reinterpret_cast<setter>(Contact_put_YomiFamilyName), nullptr, nullptr },
        { "middle_name", reinterpret_cast<getter>(Contact_get_MiddleName), reinterpret_cast<setter>(Contact_put_MiddleName), nullptr, nullptr },
        { "last_name", reinterpret_cast<getter>(Contact_get_LastName), reinterpret_cast<setter>(Contact_put_LastName), nullptr, nullptr },
        { "honorific_name_prefix", reinterpret_cast<getter>(Contact_get_HonorificNamePrefix), reinterpret_cast<setter>(Contact_put_HonorificNamePrefix), nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(Contact_get_FirstName), reinterpret_cast<setter>(Contact_put_FirstName), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(Contact_get_DisplayName), nullptr, nullptr, nullptr },
        { "yomi_display_name", reinterpret_cast<getter>(Contact_get_YomiDisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Contact[] = 
    {
        { Py_tp_new, _new_Contact },
        { Py_tp_dealloc, _dealloc_Contact },
        { Py_tp_methods, _methods_Contact },
        { Py_tp_getset, _getset_Contact },
        { },
    };

    static PyType_Spec _type_spec_Contact =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.Contact",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::Contact),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Contact
    };

    // ----- ContactAddress class --------------------
    constexpr const char* const _type_name_ContactAddress = "ContactAddress";

    static PyObject* _new_ContactAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAddress_get_StreetAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreetAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_StreetAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StreetAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Region(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PostalCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Locality(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Locality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Locality(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Locality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAddressKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAddress_get_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAddress_put_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Country(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAddress[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAddress[] = {
        { "street_address", reinterpret_cast<getter>(ContactAddress_get_StreetAddress), reinterpret_cast<setter>(ContactAddress_put_StreetAddress), nullptr, nullptr },
        { "region", reinterpret_cast<getter>(ContactAddress_get_Region), reinterpret_cast<setter>(ContactAddress_put_Region), nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(ContactAddress_get_PostalCode), reinterpret_cast<setter>(ContactAddress_put_PostalCode), nullptr, nullptr },
        { "locality", reinterpret_cast<getter>(ContactAddress_get_Locality), reinterpret_cast<setter>(ContactAddress_put_Locality), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ContactAddress_get_Kind), reinterpret_cast<setter>(ContactAddress_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactAddress_get_Description), reinterpret_cast<setter>(ContactAddress_put_Description), nullptr, nullptr },
        { "country", reinterpret_cast<getter>(ContactAddress_get_Country), reinterpret_cast<setter>(ContactAddress_put_Country), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAddress[] = 
    {
        { Py_tp_new, _new_ContactAddress },
        { Py_tp_dealloc, _dealloc_ContactAddress },
        { Py_tp_methods, _methods_ContactAddress },
        { Py_tp_getset, _getset_ContactAddress },
        { },
    };

    static PyType_Spec _type_spec_ContactAddress =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAddress
    };

    // ----- ContactAnnotation class --------------------
    constexpr const char* const _type_name_ContactAnnotation = "ContactAnnotation";

    static PyObject* _new_ContactAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactAnnotation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactAnnotation(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAnnotation_get_SupportedOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_SupportedOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationOperations>(arg);

            self->obj.SupportedOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_RemoteId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_ContactId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactAnnotation_get_AnnotationListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnnotationListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_IsDisabled(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_ProviderProperties(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotation_get_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactListId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactAnnotation_put_ContactListId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactListId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAnnotation[] = {
        { "supported_operations", reinterpret_cast<getter>(ContactAnnotation_get_SupportedOperations), reinterpret_cast<setter>(ContactAnnotation_put_SupportedOperations), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ContactAnnotation_get_RemoteId), reinterpret_cast<setter>(ContactAnnotation_put_RemoteId), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(ContactAnnotation_get_ContactId), reinterpret_cast<setter>(ContactAnnotation_put_ContactId), nullptr, nullptr },
        { "annotation_list_id", reinterpret_cast<getter>(ContactAnnotation_get_AnnotationListId), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactAnnotation_get_Id), nullptr, nullptr, nullptr },
        { "is_disabled", reinterpret_cast<getter>(ContactAnnotation_get_IsDisabled), nullptr, nullptr, nullptr },
        { "provider_properties", reinterpret_cast<getter>(ContactAnnotation_get_ProviderProperties), nullptr, nullptr, nullptr },
        { "contact_list_id", reinterpret_cast<getter>(ContactAnnotation_get_ContactListId), reinterpret_cast<setter>(ContactAnnotation_put_ContactListId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAnnotation[] = 
    {
        { Py_tp_new, _new_ContactAnnotation },
        { Py_tp_dealloc, _dealloc_ContactAnnotation },
        { Py_tp_methods, _methods_ContactAnnotation },
        { Py_tp_getset, _getset_ContactAnnotation },
        { },
    };

    static PyType_Spec _type_spec_ContactAnnotation =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactAnnotation",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotation
    };

    // ----- ContactAnnotationList class --------------------
    constexpr const char* const _type_name_ContactAnnotationList = "ContactAnnotationList";

    static PyObject* _new_ContactAnnotationList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactAnnotationList);
        return nullptr;
    }

    static void _dealloc_ContactAnnotationList(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAnnotationList_DeleteAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.DeleteAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_DeleteAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_FindAnnotationsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAnnotationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_FindAnnotationsByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAnnotationsByRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_GetAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_TrySaveAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.TrySaveAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_ProviderPackageFamilyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationList_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactAnnotationList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotationList[] = {
        { "delete_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_DeleteAnnotationAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_DeleteAsync), METH_VARARGS, nullptr },
        { "find_annotations_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_FindAnnotationsAsync), METH_VARARGS, nullptr },
        { "find_annotations_by_remote_id_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_FindAnnotationsByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_GetAnnotationAsync), METH_VARARGS, nullptr },
        { "try_save_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationList_TrySaveAnnotationAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAnnotationList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAnnotationList[] = {
        { "id", reinterpret_cast<getter>(ContactAnnotationList_get_Id), nullptr, nullptr, nullptr },
        { "provider_package_family_name", reinterpret_cast<getter>(ContactAnnotationList_get_ProviderPackageFamilyName), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(ContactAnnotationList_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactAnnotationList[] = 
    {
        { Py_tp_new, _new_ContactAnnotationList },
        { Py_tp_dealloc, _dealloc_ContactAnnotationList },
        { Py_tp_methods, _methods_ContactAnnotationList },
        { Py_tp_getset, _getset_ContactAnnotationList },
        { },
    };

    static PyType_Spec _type_spec_ContactAnnotationList =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactAnnotationList",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotationList
    };

    // ----- ContactAnnotationStore class --------------------
    constexpr const char* const _type_name_ContactAnnotationStore = "ContactAnnotationStore";

    static PyObject* _new_ContactAnnotationStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactAnnotationStore);
        return nullptr;
    }

    static void _dealloc_ContactAnnotationStore(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactAnnotationStore_CreateAnnotationListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateAnnotationListAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAnnotationListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_DisableAnnotationAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>(args, 0);

                return py::convert(self->obj.DisableAnnotationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationListsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAnnotationListsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationsForContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.FindAnnotationsForContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindAnnotationsForContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAnnotationsForContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindContactIdsByEmailAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactIdsByEmailAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_FindContactIdsByPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactIdsByPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactAnnotationStore_GetAnnotationListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAnnotationListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactAnnotationStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactAnnotationStore[] = {
        { "create_annotation_list_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_CreateAnnotationListAsync), METH_VARARGS, nullptr },
        { "disable_annotation_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_DisableAnnotationAsync), METH_VARARGS, nullptr },
        { "find_annotation_lists_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindAnnotationListsAsync), METH_VARARGS, nullptr },
        { "find_annotations_for_contact_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindAnnotationsForContactAsync), METH_VARARGS, nullptr },
        { "find_annotations_for_contact_list_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindAnnotationsForContactListAsync), METH_VARARGS, nullptr },
        { "find_contact_ids_by_email_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindContactIdsByEmailAsync), METH_VARARGS, nullptr },
        { "find_contact_ids_by_phone_number_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_FindContactIdsByPhoneNumberAsync), METH_VARARGS, nullptr },
        { "get_annotation_list_async", reinterpret_cast<PyCFunction>(ContactAnnotationStore_GetAnnotationListAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactAnnotationStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactAnnotationStore[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactAnnotationStore[] = 
    {
        { Py_tp_new, _new_ContactAnnotationStore },
        { Py_tp_dealloc, _dealloc_ContactAnnotationStore },
        { Py_tp_methods, _methods_ContactAnnotationStore },
        { Py_tp_getset, _getset_ContactAnnotationStore },
        { },
    };

    static PyType_Spec _type_spec_ContactAnnotationStore =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactAnnotationStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactAnnotationStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactAnnotationStore
    };

    // ----- ContactBatch class --------------------
    constexpr const char* const _type_name_ContactBatch = "ContactBatch";

    static PyObject* _new_ContactBatch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactBatch);
        return nullptr;
    }

    static void _dealloc_ContactBatch(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactBatch_get_Contacts(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contacts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactBatch_get_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactBatch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactBatch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactBatch[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactBatch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactBatch[] = {
        { "contacts", reinterpret_cast<getter>(ContactBatch_get_Contacts), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ContactBatch_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactBatch[] = 
    {
        { Py_tp_new, _new_ContactBatch },
        { Py_tp_dealloc, _dealloc_ContactBatch },
        { Py_tp_methods, _methods_ContactBatch },
        { Py_tp_getset, _getset_ContactBatch },
        { },
    };

    static PyType_Spec _type_spec_ContactBatch =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactBatch",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactBatch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactBatch
    };

    // ----- ContactCardDelayedDataLoader class --------------------
    constexpr const char* const _type_name_ContactCardDelayedDataLoader = "ContactCardDelayedDataLoader";

    static PyObject* _new_ContactCardDelayedDataLoader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactCardDelayedDataLoader);
        return nullptr;
    }

    static void _dealloc_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactCardDelayedDataLoader_Close(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactCardDelayedDataLoader_SetData(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactCardDelayedDataLoader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ContactCardDelayedDataLoader(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCardDelayedDataLoader[] = {
        { "close", reinterpret_cast<PyCFunction>(ContactCardDelayedDataLoader_Close), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(ContactCardDelayedDataLoader_SetData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCardDelayedDataLoader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ContactCardDelayedDataLoader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ContactCardDelayedDataLoader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactCardDelayedDataLoader[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactCardDelayedDataLoader[] = 
    {
        { Py_tp_new, _new_ContactCardDelayedDataLoader },
        { Py_tp_dealloc, _dealloc_ContactCardDelayedDataLoader },
        { Py_tp_methods, _methods_ContactCardDelayedDataLoader },
        { Py_tp_getset, _getset_ContactCardDelayedDataLoader },
        { },
    };

    static PyType_Spec _type_spec_ContactCardDelayedDataLoader =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactCardDelayedDataLoader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCardDelayedDataLoader
    };

    // ----- ContactCardOptions class --------------------
    constexpr const char* const _type_name_ContactCardOptions = "ContactCardOptions";

    static PyObject* _new_ContactCardOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactCardOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactCardOptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactCardOptions_get_InitialTabKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialTabKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactCardOptions_put_InitialTabKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardTabKind>(arg);

            self->obj.InitialTabKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactCardOptions_get_HeaderKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactCardOptions_put_HeaderKind(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardHeaderKind>(arg);

            self->obj.HeaderKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactCardOptions_get_ServerSearchContactListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerSearchContactListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCardOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCardOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactCardOptions[] = {
        { "initial_tab_kind", reinterpret_cast<getter>(ContactCardOptions_get_InitialTabKind), reinterpret_cast<setter>(ContactCardOptions_put_InitialTabKind), nullptr, nullptr },
        { "header_kind", reinterpret_cast<getter>(ContactCardOptions_get_HeaderKind), reinterpret_cast<setter>(ContactCardOptions_put_HeaderKind), nullptr, nullptr },
        { "server_search_contact_list_ids", reinterpret_cast<getter>(ContactCardOptions_get_ServerSearchContactListIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactCardOptions[] = 
    {
        { Py_tp_new, _new_ContactCardOptions },
        { Py_tp_dealloc, _dealloc_ContactCardOptions },
        { Py_tp_methods, _methods_ContactCardOptions },
        { Py_tp_getset, _getset_ContactCardOptions },
        { },
    };

    static PyType_Spec _type_spec_ContactCardOptions =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactCardOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactCardOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCardOptions
    };

    // ----- ContactChange class --------------------
    constexpr const char* const _type_name_ContactChange = "ContactChange";

    static PyObject* _new_ContactChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChange);
        return nullptr;
    }

    static void _dealloc_ContactChange(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactChange_get_Contact(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChange[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChange[] = {
        { "change_type", reinterpret_cast<getter>(ContactChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactChange_get_Contact), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactChange[] = 
    {
        { Py_tp_new, _new_ContactChange },
        { Py_tp_dealloc, _dealloc_ContactChange },
        { Py_tp_methods, _methods_ContactChange },
        { Py_tp_getset, _getset_ContactChange },
        { },
    };

    static PyType_Spec _type_spec_ContactChange =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChange
    };

    // ----- ContactChangeReader class --------------------
    constexpr const char* const _type_name_ContactChangeReader = "ContactChangeReader";

    static PyObject* _new_ContactChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangeReader);
        return nullptr;
    }

    static void _dealloc_ContactChangeReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(ContactChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(ContactChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ContactChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactChangeReader[] = 
    {
        { Py_tp_new, _new_ContactChangeReader },
        { Py_tp_dealloc, _dealloc_ContactChangeReader },
        { Py_tp_methods, _methods_ContactChangeReader },
        { Py_tp_getset, _getset_ContactChangeReader },
        { },
    };

    static PyType_Spec _type_spec_ContactChangeReader =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeReader
    };

    // ----- ContactChangeTracker class --------------------
    constexpr const char* const _type_name_ContactChangeTracker = "ContactChangeTracker";

    static PyObject* _new_ContactChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangeTracker);
        return nullptr;
    }

    static void _dealloc_ContactChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(ContactChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(ContactChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(ContactChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangeTracker[] = {
        { "is_tracking", reinterpret_cast<getter>(ContactChangeTracker_get_IsTracking), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactChangeTracker[] = 
    {
        { Py_tp_new, _new_ContactChangeTracker },
        { Py_tp_dealloc, _dealloc_ContactChangeTracker },
        { Py_tp_methods, _methods_ContactChangeTracker },
        { Py_tp_getset, _getset_ContactChangeTracker },
        { },
    };

    static PyType_Spec _type_spec_ContactChangeTracker =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangeTracker
    };

    // ----- ContactChangedDeferral class --------------------
    constexpr const char* const _type_name_ContactChangedDeferral = "ContactChangedDeferral";

    static PyObject* _new_ContactChangedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangedDeferral);
        return nullptr;
    }

    static void _dealloc_ContactChangedDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ContactChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactChangedDeferral[] = 
    {
        { Py_tp_new, _new_ContactChangedDeferral },
        { Py_tp_dealloc, _dealloc_ContactChangedDeferral },
        { Py_tp_methods, _methods_ContactChangedDeferral },
        { Py_tp_getset, _getset_ContactChangedDeferral },
        { },
    };

    static PyType_Spec _type_spec_ContactChangedDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangedDeferral
    };

    // ----- ContactChangedEventArgs class --------------------
    constexpr const char* const _type_name_ContactChangedEventArgs = "ContactChangedEventArgs";

    static PyObject* _new_ContactChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactChangedEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactChangedEventArgs },
        { Py_tp_methods, _methods_ContactChangedEventArgs },
        { Py_tp_getset, _getset_ContactChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ContactChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactChangedEventArgs
    };

    // ----- ContactConnectedServiceAccount class --------------------
    constexpr const char* const _type_name_ContactConnectedServiceAccount = "ContactConnectedServiceAccount";

    static PyObject* _new_ContactConnectedServiceAccount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactConnectedServiceAccount(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactConnectedServiceAccount_get_ServiceName(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactConnectedServiceAccount_put_ServiceName(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ServiceName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactConnectedServiceAccount_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactConnectedServiceAccount_put_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactConnectedServiceAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactConnectedServiceAccount[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactConnectedServiceAccount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactConnectedServiceAccount[] = {
        { "service_name", reinterpret_cast<getter>(ContactConnectedServiceAccount_get_ServiceName), reinterpret_cast<setter>(ContactConnectedServiceAccount_put_ServiceName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactConnectedServiceAccount_get_Id), reinterpret_cast<setter>(ContactConnectedServiceAccount_put_Id), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactConnectedServiceAccount[] = 
    {
        { Py_tp_new, _new_ContactConnectedServiceAccount },
        { Py_tp_dealloc, _dealloc_ContactConnectedServiceAccount },
        { Py_tp_methods, _methods_ContactConnectedServiceAccount },
        { Py_tp_getset, _getset_ContactConnectedServiceAccount },
        { },
    };

    static PyType_Spec _type_spec_ContactConnectedServiceAccount =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactConnectedServiceAccount",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactConnectedServiceAccount
    };

    // ----- ContactDate class --------------------
    constexpr const char* const _type_name_ContactDate = "ContactDate";

    static PyObject* _new_ContactDate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactDate instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactDate(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactDate_get_Year(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Year());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Year(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.Year(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Month(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Month());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Month(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Month(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactDateKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactDate_get_Day(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Day());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactDate_put_Day(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Day(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactDate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactDate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactDate[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactDate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactDate[] = {
        { "year", reinterpret_cast<getter>(ContactDate_get_Year), reinterpret_cast<setter>(ContactDate_put_Year), nullptr, nullptr },
        { "month", reinterpret_cast<getter>(ContactDate_get_Month), reinterpret_cast<setter>(ContactDate_put_Month), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ContactDate_get_Kind), reinterpret_cast<setter>(ContactDate_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactDate_get_Description), reinterpret_cast<setter>(ContactDate_put_Description), nullptr, nullptr },
        { "day", reinterpret_cast<getter>(ContactDate_get_Day), reinterpret_cast<setter>(ContactDate_put_Day), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactDate[] = 
    {
        { Py_tp_new, _new_ContactDate },
        { Py_tp_dealloc, _dealloc_ContactDate },
        { Py_tp_methods, _methods_ContactDate },
        { Py_tp_getset, _getset_ContactDate },
        { },
    };

    static PyType_Spec _type_spec_ContactDate =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactDate",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactDate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactDate
    };

    // ----- ContactEmail class --------------------
    constexpr const char* const _type_name_ContactEmail = "ContactEmail";

    static PyObject* _new_ContactEmail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactEmail instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactEmail(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactEmail_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactEmailKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactEmail_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactEmail_get_Address(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactEmail_put_Address(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactEmail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactEmail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactEmail[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactEmail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactEmail[] = {
        { "kind", reinterpret_cast<getter>(ContactEmail_get_Kind), reinterpret_cast<setter>(ContactEmail_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactEmail_get_Description), reinterpret_cast<setter>(ContactEmail_put_Description), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(ContactEmail_get_Address), reinterpret_cast<setter>(ContactEmail_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactEmail[] = 
    {
        { Py_tp_new, _new_ContactEmail },
        { Py_tp_dealloc, _dealloc_ContactEmail },
        { Py_tp_methods, _methods_ContactEmail },
        { Py_tp_getset, _getset_ContactEmail },
        { },
    };

    static PyType_Spec _type_spec_ContactEmail =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactEmail",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactEmail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactEmail
    };

    // ----- ContactField class --------------------
    constexpr const char* const _type_name_ContactField = "ContactField";

    static PyObject* _new_ContactField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                winrt::Windows::ApplicationModel::Contacts::ContactField instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactField(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactField[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactField[] = {
        { "category", reinterpret_cast<getter>(ContactField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContactField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ContactField_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactField[] = 
    {
        { Py_tp_new, _new_ContactField },
        { Py_tp_dealloc, _dealloc_ContactField },
        { Py_tp_methods, _methods_ContactField },
        { Py_tp_getset, _getset_ContactField },
        { },
    };

    static PyType_Spec _type_spec_ContactField =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactField
    };

    // ----- ContactFieldFactory class --------------------
    constexpr const char* const _type_name_ContactFieldFactory = "ContactFieldFactory";

    static PyObject* _new_ContactFieldFactory(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactFieldFactory_CreateField(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                return py::convert(self->obj.CreateField(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                return py::convert(self->obj.CreateField(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                return py::convert(self->obj.CreateField(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactFieldFactory_CreateInstantMessage(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateInstantMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateInstantMessage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                return py::convert(self->obj.CreateInstantMessage(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactFieldFactory_CreateLocation(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateLocation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.CreateLocation(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactFieldFactory[] = {
        { "create_field", reinterpret_cast<PyCFunction>(ContactFieldFactory_CreateField), METH_VARARGS, nullptr },
        { "create_instant_message", reinterpret_cast<PyCFunction>(ContactFieldFactory_CreateInstantMessage), METH_VARARGS, nullptr },
        { "create_location", reinterpret_cast<PyCFunction>(ContactFieldFactory_CreateLocation), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactFieldFactory[] = 
    {
        { Py_tp_new, _new_ContactFieldFactory },
        { Py_tp_dealloc, _dealloc_ContactFieldFactory },
        { Py_tp_methods, _methods_ContactFieldFactory },
        { Py_tp_getset, _getset_ContactFieldFactory },
        { },
    };

    static PyType_Spec _type_spec_ContactFieldFactory =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactFieldFactory
    };

    // ----- ContactGroup class --------------------
    constexpr const char* const _type_name_ContactGroup = "ContactGroup";

    static PyObject* _new_ContactGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactGroup);
        return nullptr;
    }

    static void _dealloc_ContactGroup(py::wrapper::Windows::ApplicationModel::Contacts::ContactGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ContactGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactGroup[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactGroup[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactGroup[] = 
    {
        { Py_tp_new, _new_ContactGroup },
        { Py_tp_dealloc, _dealloc_ContactGroup },
        { Py_tp_methods, _methods_ContactGroup },
        { Py_tp_getset, _getset_ContactGroup },
        { },
    };

    static PyType_Spec _type_spec_ContactGroup =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactGroup
    };

    // ----- ContactInformation class --------------------
    constexpr const char* const _type_name_ContactInformation = "ContactInformation";

    static PyObject* _new_ContactInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactInformation);
        return nullptr;
    }

    static void _dealloc_ContactInformation(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactInformation_GetThumbnailAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_QueryCustomFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.QueryCustomFields(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_CustomFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Emails(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_InstantMessages(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstantMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Locations(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Locations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInformation_get_PhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInformation[] = {
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(ContactInformation_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "query_custom_fields", reinterpret_cast<PyCFunction>(ContactInformation_QueryCustomFields), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactInformation[] = {
        { "custom_fields", reinterpret_cast<getter>(ContactInformation_get_CustomFields), nullptr, nullptr, nullptr },
        { "emails", reinterpret_cast<getter>(ContactInformation_get_Emails), nullptr, nullptr, nullptr },
        { "instant_messages", reinterpret_cast<getter>(ContactInformation_get_InstantMessages), nullptr, nullptr, nullptr },
        { "locations", reinterpret_cast<getter>(ContactInformation_get_Locations), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactInformation_get_Name), nullptr, nullptr, nullptr },
        { "phone_numbers", reinterpret_cast<getter>(ContactInformation_get_PhoneNumbers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactInformation[] = 
    {
        { Py_tp_new, _new_ContactInformation },
        { Py_tp_dealloc, _dealloc_ContactInformation },
        { Py_tp_methods, _methods_ContactInformation },
        { Py_tp_getset, _getset_ContactInformation },
        { },
    };

    static PyType_Spec _type_spec_ContactInformation =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactInformation",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInformation
    };

    // ----- ContactInstantMessageField class --------------------
    constexpr const char* const _type_name_ContactInstantMessageField = "ContactInstantMessageField";

    static PyObject* _new_ContactInstantMessageField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactInstantMessageField(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactInstantMessageField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_DisplayText(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_LaunchUri(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LaunchUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_Service(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Service());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactInstantMessageField_get_UserName(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactInstantMessageField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactInstantMessageField[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactInstantMessageField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactInstantMessageField[] = {
        { "category", reinterpret_cast<getter>(ContactInstantMessageField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactInstantMessageField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContactInstantMessageField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ContactInstantMessageField_get_Value), nullptr, nullptr, nullptr },
        { "display_text", reinterpret_cast<getter>(ContactInstantMessageField_get_DisplayText), nullptr, nullptr, nullptr },
        { "launch_uri", reinterpret_cast<getter>(ContactInstantMessageField_get_LaunchUri), nullptr, nullptr, nullptr },
        { "service", reinterpret_cast<getter>(ContactInstantMessageField_get_Service), nullptr, nullptr, nullptr },
        { "user_name", reinterpret_cast<getter>(ContactInstantMessageField_get_UserName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactInstantMessageField[] = 
    {
        { Py_tp_new, _new_ContactInstantMessageField },
        { Py_tp_dealloc, _dealloc_ContactInstantMessageField },
        { Py_tp_methods, _methods_ContactInstantMessageField },
        { Py_tp_getset, _getset_ContactInstantMessageField },
        { },
    };

    static PyType_Spec _type_spec_ContactInstantMessageField =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactInstantMessageField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactInstantMessageField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactInstantMessageField
    };

    // ----- ContactJobInfo class --------------------
    constexpr const char* const _type_name_ContactJobInfo = "ContactJobInfo";

    static PyObject* _new_ContactJobInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactJobInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactJobInfo_get_Title(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Title(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Office(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Office());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Office(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Office(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Manager(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Manager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Manager(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Manager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_Department(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Department());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_Department(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Department(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyYomiName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompanyYomiName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyYomiName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyYomiName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompanyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyName(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactJobInfo_get_CompanyAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompanyAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactJobInfo_put_CompanyAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CompanyAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactJobInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactJobInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactJobInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactJobInfo[] = {
        { "title", reinterpret_cast<getter>(ContactJobInfo_get_Title), reinterpret_cast<setter>(ContactJobInfo_put_Title), nullptr, nullptr },
        { "office", reinterpret_cast<getter>(ContactJobInfo_get_Office), reinterpret_cast<setter>(ContactJobInfo_put_Office), nullptr, nullptr },
        { "manager", reinterpret_cast<getter>(ContactJobInfo_get_Manager), reinterpret_cast<setter>(ContactJobInfo_put_Manager), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactJobInfo_get_Description), reinterpret_cast<setter>(ContactJobInfo_put_Description), nullptr, nullptr },
        { "department", reinterpret_cast<getter>(ContactJobInfo_get_Department), reinterpret_cast<setter>(ContactJobInfo_put_Department), nullptr, nullptr },
        { "company_yomi_name", reinterpret_cast<getter>(ContactJobInfo_get_CompanyYomiName), reinterpret_cast<setter>(ContactJobInfo_put_CompanyYomiName), nullptr, nullptr },
        { "company_name", reinterpret_cast<getter>(ContactJobInfo_get_CompanyName), reinterpret_cast<setter>(ContactJobInfo_put_CompanyName), nullptr, nullptr },
        { "company_address", reinterpret_cast<getter>(ContactJobInfo_get_CompanyAddress), reinterpret_cast<setter>(ContactJobInfo_put_CompanyAddress), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactJobInfo[] = 
    {
        { Py_tp_new, _new_ContactJobInfo },
        { Py_tp_dealloc, _dealloc_ContactJobInfo },
        { Py_tp_methods, _methods_ContactJobInfo },
        { Py_tp_getset, _getset_ContactJobInfo },
        { },
    };

    static PyType_Spec _type_spec_ContactJobInfo =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactJobInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactJobInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactJobInfo
    };

    // ----- ContactLaunchActionVerbs class --------------------
    constexpr const char* const _type_name_ContactLaunchActionVerbs = "ContactLaunchActionVerbs";

    static PyObject* _new_ContactLaunchActionVerbs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactLaunchActionVerbs);
        return nullptr;
    }

    static PyObject* ContactLaunchActionVerbs_get_Call(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Call());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Map(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Map());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Message(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_Post(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::Post());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLaunchActionVerbs_get_VideoCall(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs::VideoCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactLaunchActionVerbs[] = {
        { "get_call", reinterpret_cast<PyCFunction>(ContactLaunchActionVerbs_get_Call), METH_NOARGS | METH_STATIC, nullptr },
        { "get_map", reinterpret_cast<PyCFunction>(ContactLaunchActionVerbs_get_Map), METH_NOARGS | METH_STATIC, nullptr },
        { "get_message", reinterpret_cast<PyCFunction>(ContactLaunchActionVerbs_get_Message), METH_NOARGS | METH_STATIC, nullptr },
        { "get_post", reinterpret_cast<PyCFunction>(ContactLaunchActionVerbs_get_Post), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_call", reinterpret_cast<PyCFunction>(ContactLaunchActionVerbs_get_VideoCall), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactLaunchActionVerbs[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactLaunchActionVerbs[] = 
    {
        { Py_tp_new, _new_ContactLaunchActionVerbs },
        { Py_tp_methods, _methods_ContactLaunchActionVerbs },
        { Py_tp_getset, _getset_ContactLaunchActionVerbs },
        { },
    };

    static PyType_Spec _type_spec_ContactLaunchActionVerbs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactLaunchActionVerbs",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactLaunchActionVerbs
    };

    // ----- ContactList class --------------------
    constexpr const char* const _type_name_ContactList = "ContactList";

    static PyObject* _new_ContactList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactList);
        return nullptr;
    }

    static void _dealloc_ContactList(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactList_DeleteAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_DeleteContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.DeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactFromRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactFromRemoteIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetContactReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.GetContactReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_GetMeContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMeContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_SaveAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_SaveContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.SaveContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SupportsServerSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsServerSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_SupportsServerSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsServerSearch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_IsHidden(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_IsHidden(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_DisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactList_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactList_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_Id(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SyncManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_SyncConstraints(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncConstraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_get_LimitedWriteOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LimitedWriteOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_add_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactList, winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>(arg);

            return py::convert(self->obj.ContactChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactList_remove_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContactChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactList[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(ContactList_DeleteAsync), METH_VARARGS, nullptr },
        { "delete_contact_async", reinterpret_cast<PyCFunction>(ContactList_DeleteContactAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(ContactList_GetChangeTracker), METH_VARARGS, nullptr },
        { "get_contact_async", reinterpret_cast<PyCFunction>(ContactList_GetContactAsync), METH_VARARGS, nullptr },
        { "get_contact_from_remote_id_async", reinterpret_cast<PyCFunction>(ContactList_GetContactFromRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_contact_reader", reinterpret_cast<PyCFunction>(ContactList_GetContactReader), METH_VARARGS, nullptr },
        { "get_me_contact_async", reinterpret_cast<PyCFunction>(ContactList_GetMeContactAsync), METH_VARARGS, nullptr },
        { "register_sync_manager_async", reinterpret_cast<PyCFunction>(ContactList_RegisterSyncManagerAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(ContactList_SaveAsync), METH_VARARGS, nullptr },
        { "save_contact_async", reinterpret_cast<PyCFunction>(ContactList_SaveContactAsync), METH_VARARGS, nullptr },
        { "add_contact_changed", reinterpret_cast<PyCFunction>(ContactList_add_ContactChanged), METH_O, nullptr },
        { "remove_contact_changed", reinterpret_cast<PyCFunction>(ContactList_remove_ContactChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactList[] = {
        { "supports_server_search", reinterpret_cast<getter>(ContactList_get_SupportsServerSearch), reinterpret_cast<setter>(ContactList_put_SupportsServerSearch), nullptr, nullptr },
        { "is_hidden", reinterpret_cast<getter>(ContactList_get_IsHidden), reinterpret_cast<setter>(ContactList_put_IsHidden), nullptr, nullptr },
        { "other_app_write_access", reinterpret_cast<getter>(ContactList_get_OtherAppWriteAccess), reinterpret_cast<setter>(ContactList_put_OtherAppWriteAccess), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ContactList_get_DisplayName), reinterpret_cast<setter>(ContactList_put_DisplayName), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(ContactList_get_OtherAppReadAccess), reinterpret_cast<setter>(ContactList_put_OtherAppReadAccess), nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(ContactList_get_ChangeTracker), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(ContactList_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContactList_get_Id), nullptr, nullptr, nullptr },
        { "sync_manager", reinterpret_cast<getter>(ContactList_get_SyncManager), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(ContactList_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { "sync_constraints", reinterpret_cast<getter>(ContactList_get_SyncConstraints), nullptr, nullptr, nullptr },
        { "limited_write_operations", reinterpret_cast<getter>(ContactList_get_LimitedWriteOperations), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactList[] = 
    {
        { Py_tp_new, _new_ContactList },
        { Py_tp_dealloc, _dealloc_ContactList },
        { Py_tp_methods, _methods_ContactList },
        { Py_tp_getset, _getset_ContactList },
        { },
    };

    static PyType_Spec _type_spec_ContactList =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactList",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactList
    };

    // ----- ContactListLimitedWriteOperations class --------------------
    constexpr const char* const _type_name_ContactListLimitedWriteOperations = "ContactListLimitedWriteOperations";

    static PyObject* _new_ContactListLimitedWriteOperations(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactListLimitedWriteOperations);
        return nullptr;
    }

    static void _dealloc_ContactListLimitedWriteOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactListLimitedWriteOperations_TryCreateOrUpdateContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.TryCreateOrUpdateContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListLimitedWriteOperations_TryDeleteContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDeleteContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactListLimitedWriteOperations(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListLimitedWriteOperations[] = {
        { "try_create_or_update_contact_async", reinterpret_cast<PyCFunction>(ContactListLimitedWriteOperations_TryCreateOrUpdateContactAsync), METH_VARARGS, nullptr },
        { "try_delete_contact_async", reinterpret_cast<PyCFunction>(ContactListLimitedWriteOperations_TryDeleteContactAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListLimitedWriteOperations), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListLimitedWriteOperations[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactListLimitedWriteOperations[] = 
    {
        { Py_tp_new, _new_ContactListLimitedWriteOperations },
        { Py_tp_dealloc, _dealloc_ContactListLimitedWriteOperations },
        { Py_tp_methods, _methods_ContactListLimitedWriteOperations },
        { Py_tp_getset, _getset_ContactListLimitedWriteOperations },
        { },
    };

    static PyType_Spec _type_spec_ContactListLimitedWriteOperations =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactListLimitedWriteOperations",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListLimitedWriteOperations
    };

    // ----- ContactListSyncConstraints class --------------------
    constexpr const char* const _type_name_ContactListSyncConstraints = "ContactListSyncConstraints";

    static PyObject* _new_ContactListSyncConstraints(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactListSyncConstraints);
        return nullptr;
    }

    static void _dealloc_ContactListSyncConstraints(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactListSyncConstraints_get_CanSyncDescriptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSyncDescriptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_CanSyncDescriptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSyncDescriptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxCompanyPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxCompanyPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxCompanyPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxCompanyPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxChildRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxChildRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxChildRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxChildRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxBusinessFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBusinessFaxPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxBusinessFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxBusinessFaxPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxBirthdayDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBirthdayDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxBirthdayDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxBirthdayDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxAssistantPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAssistantPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxAssistantPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxAssistantPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxAnniversaryDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAnniversaryDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxAnniversaryDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxAnniversaryDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomeAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxHomeAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomeAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomeAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherDates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherDates(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherDates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxMobilePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMobilePhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxMobilePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxMobilePhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxJobInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxJobInfo(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxJobInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxHomePhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomePhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomePhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxHomeFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxHomeFaxPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxHomeFaxPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxHomeFaxPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPersonalEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPersonalEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPersonalEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPersonalEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPartnerRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPartnerRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPartnerRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPartnerRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxParentRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxParentRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxParentRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxParentRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxPagerPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPagerPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxPagerPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxPagerPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxOtherPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxOtherPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxOtherPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxOtherPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxRadioPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRadioPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxRadioPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxRadioPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWorkPhoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkPhoneNumbers(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkPhoneNumbers(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWorkEmailAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkEmailAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkEmailAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWorkAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWorkAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWorkAddresses(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWorkAddresses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxWebsites(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWebsites());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxWebsites(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxWebsites(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxSpouseRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSpouseRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxSpouseRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxSpouseRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncConstraints_get_MaxSiblingRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSiblingRelationships());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncConstraints_put_MaxSiblingRelationships(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.MaxSiblingRelationships(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactListSyncConstraints(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncConstraints[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncConstraints), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncConstraints[] = {
        { "can_sync_descriptions", reinterpret_cast<getter>(ContactListSyncConstraints_get_CanSyncDescriptions), reinterpret_cast<setter>(ContactListSyncConstraints_put_CanSyncDescriptions), nullptr, nullptr },
        { "max_company_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxCompanyPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxCompanyPhoneNumbers), nullptr, nullptr },
        { "max_child_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxChildRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxChildRelationships), nullptr, nullptr },
        { "max_business_fax_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxBusinessFaxPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxBusinessFaxPhoneNumbers), nullptr, nullptr },
        { "max_birthday_dates", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxBirthdayDates), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxBirthdayDates), nullptr, nullptr },
        { "max_assistant_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxAssistantPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxAssistantPhoneNumbers), nullptr, nullptr },
        { "max_other_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherAddresses), nullptr, nullptr },
        { "max_anniversary_dates", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxAnniversaryDates), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxAnniversaryDates), nullptr, nullptr },
        { "max_home_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxHomeAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxHomeAddresses), nullptr, nullptr },
        { "max_other_dates", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherDates), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherDates), nullptr, nullptr },
        { "max_mobile_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxMobilePhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxMobilePhoneNumbers), nullptr, nullptr },
        { "max_job_info", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxJobInfo), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxJobInfo), nullptr, nullptr },
        { "max_home_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxHomePhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxHomePhoneNumbers), nullptr, nullptr },
        { "max_home_fax_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxHomeFaxPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxHomeFaxPhoneNumbers), nullptr, nullptr },
        { "max_other_email_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherEmailAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherEmailAddresses), nullptr, nullptr },
        { "max_personal_email_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxPersonalEmailAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxPersonalEmailAddresses), nullptr, nullptr },
        { "max_partner_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxPartnerRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxPartnerRelationships), nullptr, nullptr },
        { "max_parent_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxParentRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxParentRelationships), nullptr, nullptr },
        { "max_pager_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxPagerPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxPagerPhoneNumbers), nullptr, nullptr },
        { "max_other_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherRelationships), nullptr, nullptr },
        { "max_other_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxOtherPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxOtherPhoneNumbers), nullptr, nullptr },
        { "max_radio_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxRadioPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxRadioPhoneNumbers), nullptr, nullptr },
        { "max_work_phone_numbers", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWorkPhoneNumbers), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWorkPhoneNumbers), nullptr, nullptr },
        { "max_work_email_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWorkEmailAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWorkEmailAddresses), nullptr, nullptr },
        { "max_work_addresses", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWorkAddresses), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWorkAddresses), nullptr, nullptr },
        { "max_websites", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxWebsites), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxWebsites), nullptr, nullptr },
        { "max_spouse_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxSpouseRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxSpouseRelationships), nullptr, nullptr },
        { "max_sibling_relationships", reinterpret_cast<getter>(ContactListSyncConstraints_get_MaxSiblingRelationships), reinterpret_cast<setter>(ContactListSyncConstraints_put_MaxSiblingRelationships), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncConstraints[] = 
    {
        { Py_tp_new, _new_ContactListSyncConstraints },
        { Py_tp_dealloc, _dealloc_ContactListSyncConstraints },
        { Py_tp_methods, _methods_ContactListSyncConstraints },
        { Py_tp_getset, _getset_ContactListSyncConstraints },
        { },
    };

    static PyType_Spec _type_spec_ContactListSyncConstraints =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactListSyncConstraints",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncConstraints),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncConstraints
    };

    // ----- ContactListSyncManager class --------------------
    constexpr const char* const _type_name_ContactListSyncManager = "ContactListSyncManager";

    static PyObject* _new_ContactListSyncManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactListSyncManager);
        return nullptr;
    }

    static void _dealloc_ContactListSyncManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactListSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactListSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactListSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactListSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactListSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactListSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactListSyncManager[] = {
        { "sync_async", reinterpret_cast<PyCFunction>(ContactListSyncManager_SyncAsync), METH_VARARGS, nullptr },
        { "add_sync_status_changed", reinterpret_cast<PyCFunction>(ContactListSyncManager_add_SyncStatusChanged), METH_O, nullptr },
        { "remove_sync_status_changed", reinterpret_cast<PyCFunction>(ContactListSyncManager_remove_SyncStatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactListSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactListSyncManager[] = {
        { "status", reinterpret_cast<getter>(ContactListSyncManager_get_Status), reinterpret_cast<setter>(ContactListSyncManager_put_Status), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(ContactListSyncManager_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(ContactListSyncManager_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "last_attempted_sync_time", reinterpret_cast<getter>(ContactListSyncManager_get_LastAttemptedSyncTime), reinterpret_cast<setter>(ContactListSyncManager_put_LastAttemptedSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactListSyncManager[] = 
    {
        { Py_tp_new, _new_ContactListSyncManager },
        { Py_tp_dealloc, _dealloc_ContactListSyncManager },
        { Py_tp_methods, _methods_ContactListSyncManager },
        { Py_tp_getset, _getset_ContactListSyncManager },
        { },
    };

    static PyType_Spec _type_spec_ContactListSyncManager =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactListSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactListSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactListSyncManager
    };

    // ----- ContactLocationField class --------------------
    constexpr const char* const _type_name_ContactLocationField = "ContactLocationField";

    static PyObject* _new_ContactLocationField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                winrt::Windows::ApplicationModel::Contacts::ContactLocationField instance{ param0, param1, param2, param3, param4, param5, param6 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactLocationField(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactLocationField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_City(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Country(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_PostalCode(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Region(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Region());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_Street(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Street());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactLocationField_get_UnstructuredAddress(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnstructuredAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactLocationField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactLocationField[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactLocationField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactLocationField[] = {
        { "category", reinterpret_cast<getter>(ContactLocationField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ContactLocationField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContactLocationField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ContactLocationField_get_Value), nullptr, nullptr, nullptr },
        { "city", reinterpret_cast<getter>(ContactLocationField_get_City), nullptr, nullptr, nullptr },
        { "country", reinterpret_cast<getter>(ContactLocationField_get_Country), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(ContactLocationField_get_PostalCode), nullptr, nullptr, nullptr },
        { "region", reinterpret_cast<getter>(ContactLocationField_get_Region), nullptr, nullptr, nullptr },
        { "street", reinterpret_cast<getter>(ContactLocationField_get_Street), nullptr, nullptr, nullptr },
        { "unstructured_address", reinterpret_cast<getter>(ContactLocationField_get_UnstructuredAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactLocationField[] = 
    {
        { Py_tp_new, _new_ContactLocationField },
        { Py_tp_dealloc, _dealloc_ContactLocationField },
        { Py_tp_methods, _methods_ContactLocationField },
        { Py_tp_getset, _getset_ContactLocationField },
        { },
    };

    static PyType_Spec _type_spec_ContactLocationField =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactLocationField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactLocationField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactLocationField
    };

    // ----- ContactManager class --------------------
    constexpr const char* const _type_name_ContactManager = "ContactManager";

    static PyObject* _new_ContactManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactManager);
        return nullptr;
    }

    static PyObject* ContactManager_ConvertContactToVCardAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertContactToVCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertContactToVCardAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ConvertVCardToContactAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ConvertVCardToContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowContactCardSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowContactCardSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowDelayLoadedContactCardSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowDelayLoadedContactCardSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_IsShowFullContactCardSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IsShowFullContactCardSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_RequestAnnotationStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestAnnotationStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>(args, 3);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowContactCard(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowDelayLoadedContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowDelayLoadedContactCard(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowDelayLoadedContactCard(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_ShowFullContactCard(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactManager::ShowFullContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_SystemSortOrder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemSortOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_put_SystemSortOrder(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemSortOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_SystemDisplayNameOrder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemDisplayNameOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_put_SystemDisplayNameOrder(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::SystemDisplayNameOrder(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_get_IncludeMiddleNameInSystemDisplayAndSort(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactManager::IncludeMiddleNameInSystemDisplayAndSort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactManager_put_IncludeMiddleNameInSystemDisplayAndSort(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Contacts::ContactManager::IncludeMiddleNameInSystemDisplayAndSort(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactManager[] = {
        { "convert_contact_to_v_card_async", reinterpret_cast<PyCFunction>(ContactManager_ConvertContactToVCardAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "convert_v_card_to_contact_async", reinterpret_cast<PyCFunction>(ContactManager_ConvertVCardToContactAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(ContactManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_contact_card_supported", reinterpret_cast<PyCFunction>(ContactManager_IsShowContactCardSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_delay_loaded_contact_card_supported", reinterpret_cast<PyCFunction>(ContactManager_IsShowDelayLoadedContactCardSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "is_show_full_contact_card_supported_async", reinterpret_cast<PyCFunction>(ContactManager_IsShowFullContactCardSupportedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_annotation_store_async", reinterpret_cast<PyCFunction>(ContactManager_RequestAnnotationStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ContactManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_contact_card", reinterpret_cast<PyCFunction>(ContactManager_ShowContactCard), METH_VARARGS | METH_STATIC, nullptr },
        { "show_delay_loaded_contact_card", reinterpret_cast<PyCFunction>(ContactManager_ShowDelayLoadedContactCard), METH_VARARGS | METH_STATIC, nullptr },
        { "show_full_contact_card", reinterpret_cast<PyCFunction>(ContactManager_ShowFullContactCard), METH_VARARGS | METH_STATIC, nullptr },
        { "get_system_sort_order", reinterpret_cast<PyCFunction>(ContactManager_get_SystemSortOrder), METH_NOARGS | METH_STATIC, nullptr },
        { "put_system_sort_order", reinterpret_cast<PyCFunction>(ContactManager_put_SystemSortOrder), METH_O | METH_STATIC, nullptr },
        { "get_system_display_name_order", reinterpret_cast<PyCFunction>(ContactManager_get_SystemDisplayNameOrder), METH_NOARGS | METH_STATIC, nullptr },
        { "put_system_display_name_order", reinterpret_cast<PyCFunction>(ContactManager_put_SystemDisplayNameOrder), METH_O | METH_STATIC, nullptr },
        { "get_include_middle_name_in_system_display_and_sort", reinterpret_cast<PyCFunction>(ContactManager_get_IncludeMiddleNameInSystemDisplayAndSort), METH_NOARGS | METH_STATIC, nullptr },
        { "put_include_middle_name_in_system_display_and_sort", reinterpret_cast<PyCFunction>(ContactManager_put_IncludeMiddleNameInSystemDisplayAndSort), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactManager[] = 
    {
        { Py_tp_new, _new_ContactManager },
        { Py_tp_methods, _methods_ContactManager },
        { Py_tp_getset, _getset_ContactManager },
        { },
    };

    static PyType_Spec _type_spec_ContactManager =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactManager
    };

    // ----- ContactManagerForUser class --------------------
    constexpr const char* const _type_name_ContactManagerForUser = "ContactManagerForUser";

    static PyObject* _new_ContactManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactManagerForUser);
        return nullptr;
    }

    static void _dealloc_ContactManagerForUser(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactManagerForUser_ConvertContactToVCardAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.ConvertContactToVCardAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.ConvertContactToVCardAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_ConvertVCardToContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(self->obj.ConvertVCardToContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_RequestAnnotationStoreAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestAnnotationStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_ShowFullContactCard(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>(args, 1);

                self->obj.ShowFullContactCard(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactManagerForUser_get_SystemSortOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemSortOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManagerForUser_put_SystemSortOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            self->obj.SystemSortOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManagerForUser_get_SystemDisplayNameOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemDisplayNameOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactManagerForUser_put_SystemDisplayNameOrder(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactNameOrder>(arg);

            self->obj.SystemDisplayNameOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactManagerForUser[] = {
        { "convert_contact_to_v_card_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_ConvertContactToVCardAsync), METH_VARARGS, nullptr },
        { "convert_v_card_to_contact_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_ConvertVCardToContactAsync), METH_VARARGS, nullptr },
        { "request_annotation_store_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_RequestAnnotationStoreAsync), METH_VARARGS, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ContactManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_full_contact_card", reinterpret_cast<PyCFunction>(ContactManagerForUser_ShowFullContactCard), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactManagerForUser[] = {
        { "system_sort_order", reinterpret_cast<getter>(ContactManagerForUser_get_SystemSortOrder), reinterpret_cast<setter>(ContactManagerForUser_put_SystemSortOrder), nullptr, nullptr },
        { "system_display_name_order", reinterpret_cast<getter>(ContactManagerForUser_get_SystemDisplayNameOrder), reinterpret_cast<setter>(ContactManagerForUser_put_SystemDisplayNameOrder), nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactManagerForUser[] = 
    {
        { Py_tp_new, _new_ContactManagerForUser },
        { Py_tp_dealloc, _dealloc_ContactManagerForUser },
        { Py_tp_methods, _methods_ContactManagerForUser },
        { Py_tp_getset, _getset_ContactManagerForUser },
        { },
    };

    static PyType_Spec _type_spec_ContactManagerForUser =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactManagerForUser
    };

    // ----- ContactMatchReason class --------------------
    constexpr const char* const _type_name_ContactMatchReason = "ContactMatchReason";

    static PyObject* _new_ContactMatchReason(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactMatchReason);
        return nullptr;
    }

    static void _dealloc_ContactMatchReason(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactMatchReason_get_Field(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Field());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMatchReason_get_Segments(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Segments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMatchReason_get_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactMatchReason(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMatchReason[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMatchReason), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactMatchReason[] = {
        { "field", reinterpret_cast<getter>(ContactMatchReason_get_Field), nullptr, nullptr, nullptr },
        { "segments", reinterpret_cast<getter>(ContactMatchReason_get_Segments), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(ContactMatchReason_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactMatchReason[] = 
    {
        { Py_tp_new, _new_ContactMatchReason },
        { Py_tp_dealloc, _dealloc_ContactMatchReason },
        { Py_tp_methods, _methods_ContactMatchReason },
        { Py_tp_getset, _getset_ContactMatchReason },
        { },
    };

    static PyType_Spec _type_spec_ContactMatchReason =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactMatchReason",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactMatchReason),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMatchReason
    };

    // ----- ContactPanel class --------------------
    constexpr const char* const _type_name_ContactPanel = "ContactPanel";

    static PyObject* _new_ContactPanel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactPanel);
        return nullptr;
    }

    static void _dealloc_ContactPanel(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPanel_ClosePanel(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClosePanel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPanel_get_HeaderColor(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPanel_put_HeaderColor(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.HeaderColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPanel_add_Closing(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactPanel, winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>>(arg);

            return py::convert(self->obj.Closing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_remove_Closing(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_add_LaunchFullAppRequested(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactPanel, winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>>(arg);

            return py::convert(self->obj.LaunchFullAppRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanel_remove_LaunchFullAppRequested(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LaunchFullAppRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPanel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanel[] = {
        { "close_panel", reinterpret_cast<PyCFunction>(ContactPanel_ClosePanel), METH_VARARGS, nullptr },
        { "add_closing", reinterpret_cast<PyCFunction>(ContactPanel_add_Closing), METH_O, nullptr },
        { "remove_closing", reinterpret_cast<PyCFunction>(ContactPanel_remove_Closing), METH_O, nullptr },
        { "add_launch_full_app_requested", reinterpret_cast<PyCFunction>(ContactPanel_add_LaunchFullAppRequested), METH_O, nullptr },
        { "remove_launch_full_app_requested", reinterpret_cast<PyCFunction>(ContactPanel_remove_LaunchFullAppRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanel[] = {
        { "header_color", reinterpret_cast<getter>(ContactPanel_get_HeaderColor), reinterpret_cast<setter>(ContactPanel_put_HeaderColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPanel[] = 
    {
        { Py_tp_new, _new_ContactPanel },
        { Py_tp_dealloc, _dealloc_ContactPanel },
        { Py_tp_methods, _methods_ContactPanel },
        { Py_tp_getset, _getset_ContactPanel },
        { },
    };

    static PyType_Spec _type_spec_ContactPanel =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactPanel",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanel
    };

    // ----- ContactPanelClosingEventArgs class --------------------
    constexpr const char* const _type_name_ContactPanelClosingEventArgs = "ContactPanelClosingEventArgs";

    static PyObject* _new_ContactPanelClosingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactPanelClosingEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPanelClosingEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPanelClosingEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactPanelClosingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelClosingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ContactPanelClosingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelClosingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanelClosingEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactPanelClosingEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPanelClosingEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPanelClosingEventArgs },
        { Py_tp_methods, _methods_ContactPanelClosingEventArgs },
        { Py_tp_getset, _getset_ContactPanelClosingEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ContactPanelClosingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactPanelClosingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelClosingEventArgs
    };

    // ----- ContactPanelLaunchFullAppRequestedEventArgs class --------------------
    constexpr const char* const _type_name_ContactPanelLaunchFullAppRequestedEventArgs = "ContactPanelLaunchFullAppRequestedEventArgs";

    static PyObject* _new_ContactPanelLaunchFullAppRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactPanelLaunchFullAppRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPanelLaunchFullAppRequestedEventArgs(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPanelLaunchFullAppRequestedEventArgs_get_Handled(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPanelLaunchFullAppRequestedEventArgs_put_Handled(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactPanelLaunchFullAppRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelLaunchFullAppRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelLaunchFullAppRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanelLaunchFullAppRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContactPanelLaunchFullAppRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ContactPanelLaunchFullAppRequestedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPanelLaunchFullAppRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPanelLaunchFullAppRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPanelLaunchFullAppRequestedEventArgs },
        { Py_tp_methods, _methods_ContactPanelLaunchFullAppRequestedEventArgs },
        { Py_tp_getset, _getset_ContactPanelLaunchFullAppRequestedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ContactPanelLaunchFullAppRequestedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactPanelLaunchFullAppRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelLaunchFullAppRequestedEventArgs
    };

    // ----- ContactPhone class --------------------
    constexpr const char* const _type_name_ContactPhone = "ContactPhone";

    static PyObject* _new_ContactPhone(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactPhone instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactPhone(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPhone_get_Number(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Number(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPhone_get_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Kind(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhoneKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPhone_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPhone_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactPhone(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPhone>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPhone[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPhone), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPhone[] = {
        { "number", reinterpret_cast<getter>(ContactPhone_get_Number), reinterpret_cast<setter>(ContactPhone_put_Number), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ContactPhone_get_Kind), reinterpret_cast<setter>(ContactPhone_put_Kind), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactPhone_get_Description), reinterpret_cast<setter>(ContactPhone_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPhone[] = 
    {
        { Py_tp_new, _new_ContactPhone },
        { Py_tp_dealloc, _dealloc_ContactPhone },
        { Py_tp_methods, _methods_ContactPhone },
        { Py_tp_getset, _getset_ContactPhone },
        { },
    };

    static PyType_Spec _type_spec_ContactPhone =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactPhone",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPhone),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPhone
    };

    // ----- ContactPicker class --------------------
    constexpr const char* const _type_name_ContactPicker = "ContactPicker";

    static PyObject* _new_ContactPicker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactPicker instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactPicker(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactPicker_CreateForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactPicker::CreateForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_IsSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::ContactPicker::IsSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickMultipleContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickMultipleContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_PickSingleContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PickSingleContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_SelectionMode(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPicker_put_SelectionMode(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactSelectionMode>(arg);

            self->obj.SelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPicker_get_CommitButtonText(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommitButtonText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactPicker_put_CommitButtonText(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CommitButtonText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactPicker_get_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_DesiredFieldsWithContactFieldType(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFieldsWithContactFieldType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPicker_get_User(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPicker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactPicker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPicker[] = {
        { "create_for_user", reinterpret_cast<PyCFunction>(ContactPicker_CreateForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported_async", reinterpret_cast<PyCFunction>(ContactPicker_IsSupportedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "pick_contact_async", reinterpret_cast<PyCFunction>(ContactPicker_PickContactAsync), METH_VARARGS, nullptr },
        { "pick_contacts_async", reinterpret_cast<PyCFunction>(ContactPicker_PickContactsAsync), METH_VARARGS, nullptr },
        { "pick_multiple_contacts_async", reinterpret_cast<PyCFunction>(ContactPicker_PickMultipleContactsAsync), METH_VARARGS, nullptr },
        { "pick_single_contact_async", reinterpret_cast<PyCFunction>(ContactPicker_PickSingleContactAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPicker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPicker[] = {
        { "selection_mode", reinterpret_cast<getter>(ContactPicker_get_SelectionMode), reinterpret_cast<setter>(ContactPicker_put_SelectionMode), nullptr, nullptr },
        { "commit_button_text", reinterpret_cast<getter>(ContactPicker_get_CommitButtonText), reinterpret_cast<setter>(ContactPicker_put_CommitButtonText), nullptr, nullptr },
        { "desired_fields", reinterpret_cast<getter>(ContactPicker_get_DesiredFields), nullptr, nullptr, nullptr },
        { "desired_fields_with_contact_field_type", reinterpret_cast<getter>(ContactPicker_get_DesiredFieldsWithContactFieldType), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactPicker_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPicker[] = 
    {
        { Py_tp_new, _new_ContactPicker },
        { Py_tp_dealloc, _dealloc_ContactPicker },
        { Py_tp_methods, _methods_ContactPicker },
        { Py_tp_getset, _getset_ContactPicker },
        { },
    };

    static PyType_Spec _type_spec_ContactPicker =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactPicker",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactPicker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPicker
    };

    // ----- ContactQueryOptions class --------------------
    constexpr const char* const _type_name_ContactQueryOptions = "ContactQueryOptions";

    static PyObject* _new_ContactQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchFields>(args, 1);

                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactQueryOptions(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactQueryOptions_get_IncludeContactsFromHiddenLists(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeContactsFromHiddenLists());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_IncludeContactsFromHiddenLists(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeContactsFromHiddenLists(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredOperations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_DesiredOperations(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationOperations>(arg);

            self->obj.DesiredOperations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryOptions_put_DesiredFields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryDesiredFields>(arg);

            self->obj.DesiredFields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryOptions_get_AnnotationListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnnotationListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactQueryOptions_get_ContactListIds(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactListIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactQueryOptions_get_TextSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextSearch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryOptions[] = {
        { "include_contacts_from_hidden_lists", reinterpret_cast<getter>(ContactQueryOptions_get_IncludeContactsFromHiddenLists), reinterpret_cast<setter>(ContactQueryOptions_put_IncludeContactsFromHiddenLists), nullptr, nullptr },
        { "desired_operations", reinterpret_cast<getter>(ContactQueryOptions_get_DesiredOperations), reinterpret_cast<setter>(ContactQueryOptions_put_DesiredOperations), nullptr, nullptr },
        { "desired_fields", reinterpret_cast<getter>(ContactQueryOptions_get_DesiredFields), reinterpret_cast<setter>(ContactQueryOptions_put_DesiredFields), nullptr, nullptr },
        { "annotation_list_ids", reinterpret_cast<getter>(ContactQueryOptions_get_AnnotationListIds), nullptr, nullptr, nullptr },
        { "contact_list_ids", reinterpret_cast<getter>(ContactQueryOptions_get_ContactListIds), nullptr, nullptr, nullptr },
        { "text_search", reinterpret_cast<getter>(ContactQueryOptions_get_TextSearch), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactQueryOptions[] = 
    {
        { Py_tp_new, _new_ContactQueryOptions },
        { Py_tp_dealloc, _dealloc_ContactQueryOptions },
        { Py_tp_methods, _methods_ContactQueryOptions },
        { Py_tp_getset, _getset_ContactQueryOptions },
        { },
    };

    static PyType_Spec _type_spec_ContactQueryOptions =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryOptions
    };

    // ----- ContactQueryTextSearch class --------------------
    constexpr const char* const _type_name_ContactQueryTextSearch = "ContactQueryTextSearch";

    static PyObject* _new_ContactQueryTextSearch(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactQueryTextSearch);
        return nullptr;
    }

    static void _dealloc_ContactQueryTextSearch(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactQueryTextSearch_get_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_Text(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryTextSearch_get_SearchScope(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SearchScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_SearchScope(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchScope>(arg);

            self->obj.SearchScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactQueryTextSearch_get_Fields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Fields());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactQueryTextSearch_put_Fields(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQuerySearchFields>(arg);

            self->obj.Fields(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactQueryTextSearch(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactQueryTextSearch[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactQueryTextSearch), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactQueryTextSearch[] = {
        { "text", reinterpret_cast<getter>(ContactQueryTextSearch_get_Text), reinterpret_cast<setter>(ContactQueryTextSearch_put_Text), nullptr, nullptr },
        { "search_scope", reinterpret_cast<getter>(ContactQueryTextSearch_get_SearchScope), reinterpret_cast<setter>(ContactQueryTextSearch_put_SearchScope), nullptr, nullptr },
        { "fields", reinterpret_cast<getter>(ContactQueryTextSearch_get_Fields), reinterpret_cast<setter>(ContactQueryTextSearch_put_Fields), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactQueryTextSearch[] = 
    {
        { Py_tp_new, _new_ContactQueryTextSearch },
        { Py_tp_dealloc, _dealloc_ContactQueryTextSearch },
        { Py_tp_methods, _methods_ContactQueryTextSearch },
        { Py_tp_getset, _getset_ContactQueryTextSearch },
        { },
    };

    static PyType_Spec _type_spec_ContactQueryTextSearch =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactQueryTextSearch",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactQueryTextSearch),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactQueryTextSearch
    };

    // ----- ContactReader class --------------------
    constexpr const char* const _type_name_ContactReader = "ContactReader";

    static PyObject* _new_ContactReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactReader);
        return nullptr;
    }

    static void _dealloc_ContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactReader_GetMatchingPropertiesWithMatchReason(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                return py::convert(self->obj.GetMatchingPropertiesWithMatchReason(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ContactReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactReader[] = {
        { "get_matching_properties_with_match_reason", reinterpret_cast<PyCFunction>(ContactReader_GetMatchingPropertiesWithMatchReason), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ContactReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactReader[] = 
    {
        { Py_tp_new, _new_ContactReader },
        { Py_tp_dealloc, _dealloc_ContactReader },
        { Py_tp_methods, _methods_ContactReader },
        { Py_tp_getset, _getset_ContactReader },
        { },
    };

    static PyType_Spec _type_spec_ContactReader =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactReader
    };

    // ----- ContactSignificantOther class --------------------
    constexpr const char* const _type_name_ContactSignificantOther = "ContactSignificantOther";

    static PyObject* _new_ContactSignificantOther(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactSignificantOther(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactSignificantOther_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Name(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactSignificantOther_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactSignificantOther_get_Relationship(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Relationship());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactSignificantOther_put_Relationship(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactRelationship>(arg);

            self->obj.Relationship(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactSignificantOther(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactSignificantOther[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactSignificantOther), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactSignificantOther[] = {
        { "name", reinterpret_cast<getter>(ContactSignificantOther_get_Name), reinterpret_cast<setter>(ContactSignificantOther_put_Name), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactSignificantOther_get_Description), reinterpret_cast<setter>(ContactSignificantOther_put_Description), nullptr, nullptr },
        { "relationship", reinterpret_cast<getter>(ContactSignificantOther_get_Relationship), reinterpret_cast<setter>(ContactSignificantOther_put_Relationship), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactSignificantOther[] = 
    {
        { Py_tp_new, _new_ContactSignificantOther },
        { Py_tp_dealloc, _dealloc_ContactSignificantOther },
        { Py_tp_methods, _methods_ContactSignificantOther },
        { Py_tp_getset, _getset_ContactSignificantOther },
        { },
    };

    static PyType_Spec _type_spec_ContactSignificantOther =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactSignificantOther",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactSignificantOther),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactSignificantOther
    };

    // ----- ContactStore class --------------------
    constexpr const char* const _type_name_ContactStore = "ContactStore";

    static PyObject* _new_ContactStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactStore);
        return nullptr;
    }

    static void _dealloc_ContactStore(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactStore_CreateContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateContactListAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactListsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindContactListsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_FindContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindContactsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindContactsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactListAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContactListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetContactReader(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetContactReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>(args, 0);

                return py::convert(self->obj.GetContactReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_GetMeContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMeContactAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_AggregateContactManager(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AggregateContactManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_add_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Contacts::ContactStore, winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>>(arg);

            return py::convert(self->obj.ContactChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactStore_remove_ContactChanged(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContactChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStore[] = {
        { "create_contact_list_async", reinterpret_cast<PyCFunction>(ContactStore_CreateContactListAsync), METH_VARARGS, nullptr },
        { "find_contact_lists_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactListsAsync), METH_VARARGS, nullptr },
        { "find_contacts_async", reinterpret_cast<PyCFunction>(ContactStore_FindContactsAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(ContactStore_GetChangeTracker), METH_VARARGS, nullptr },
        { "get_contact_async", reinterpret_cast<PyCFunction>(ContactStore_GetContactAsync), METH_VARARGS, nullptr },
        { "get_contact_list_async", reinterpret_cast<PyCFunction>(ContactStore_GetContactListAsync), METH_VARARGS, nullptr },
        { "get_contact_reader", reinterpret_cast<PyCFunction>(ContactStore_GetContactReader), METH_VARARGS, nullptr },
        { "get_me_contact_async", reinterpret_cast<PyCFunction>(ContactStore_GetMeContactAsync), METH_VARARGS, nullptr },
        { "add_contact_changed", reinterpret_cast<PyCFunction>(ContactStore_add_ContactChanged), METH_O, nullptr },
        { "remove_contact_changed", reinterpret_cast<PyCFunction>(ContactStore_remove_ContactChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStore[] = {
        { "aggregate_contact_manager", reinterpret_cast<getter>(ContactStore_get_AggregateContactManager), nullptr, nullptr, nullptr },
        { "change_tracker", reinterpret_cast<getter>(ContactStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactStore[] = 
    {
        { Py_tp_new, _new_ContactStore },
        { Py_tp_dealloc, _dealloc_ContactStore },
        { Py_tp_methods, _methods_ContactStore },
        { Py_tp_getset, _getset_ContactStore },
        { },
    };

    static PyType_Spec _type_spec_ContactStore =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStore
    };

    // ----- ContactStoreNotificationTriggerDetails class --------------------
    constexpr const char* const _type_name_ContactStoreNotificationTriggerDetails = "ContactStoreNotificationTriggerDetails";

    static PyObject* _new_ContactStoreNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ContactStoreNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ContactStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ContactStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactStoreNotificationTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactStoreNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactStoreNotificationTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_ContactStoreNotificationTriggerDetails[] = 
    {
        { Py_tp_new, _new_ContactStoreNotificationTriggerDetails },
        { Py_tp_dealloc, _dealloc_ContactStoreNotificationTriggerDetails },
        { Py_tp_methods, _methods_ContactStoreNotificationTriggerDetails },
        { Py_tp_getset, _getset_ContactStoreNotificationTriggerDetails },
        { },
    };

    static PyType_Spec _type_spec_ContactStoreNotificationTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactStoreNotificationTriggerDetails
    };

    // ----- ContactWebsite class --------------------
    constexpr const char* const _type_name_ContactWebsite = "ContactWebsite";

    static PyObject* _new_ContactWebsite(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::ContactWebsite instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContactWebsite(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ContactWebsite_get_Uri(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_Uri(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactWebsite_get_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_Description(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContactWebsite_get_RawValue(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContactWebsite_put_RawValue(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ContactWebsite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactWebsite[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactWebsite), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactWebsite[] = {
        { "uri", reinterpret_cast<getter>(ContactWebsite_get_Uri), reinterpret_cast<setter>(ContactWebsite_put_Uri), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ContactWebsite_get_Description), reinterpret_cast<setter>(ContactWebsite_put_Description), nullptr, nullptr },
        { "raw_value", reinterpret_cast<getter>(ContactWebsite_get_RawValue), reinterpret_cast<setter>(ContactWebsite_put_RawValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactWebsite[] = 
    {
        { Py_tp_new, _new_ContactWebsite },
        { Py_tp_dealloc, _dealloc_ContactWebsite },
        { Py_tp_methods, _methods_ContactWebsite },
        { Py_tp_getset, _getset_ContactWebsite },
        { },
    };

    static PyType_Spec _type_spec_ContactWebsite =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.ContactWebsite",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::ContactWebsite),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactWebsite
    };

    // ----- FullContactCardOptions class --------------------
    constexpr const char* const _type_name_FullContactCardOptions = "FullContactCardOptions";

    static PyObject* _new_FullContactCardOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FullContactCardOptions(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FullContactCardOptions_get_DesiredRemainingView(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRemainingView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FullContactCardOptions_put_DesiredRemainingView(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.DesiredRemainingView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FullContactCardOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FullContactCardOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FullContactCardOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FullContactCardOptions[] = {
        { "desired_remaining_view", reinterpret_cast<getter>(FullContactCardOptions_get_DesiredRemainingView), reinterpret_cast<setter>(FullContactCardOptions_put_DesiredRemainingView), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FullContactCardOptions[] = 
    {
        { Py_tp_new, _new_FullContactCardOptions },
        { Py_tp_dealloc, _dealloc_FullContactCardOptions },
        { Py_tp_methods, _methods_FullContactCardOptions },
        { Py_tp_getset, _getset_FullContactCardOptions },
        { },
    };

    static PyType_Spec _type_spec_FullContactCardOptions =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.FullContactCardOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::FullContactCardOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FullContactCardOptions
    };

    // ----- KnownContactField class --------------------
    constexpr const char* const _type_name_KnownContactField = "KnownContactField";

    static PyObject* _new_KnownContactField(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KnownContactField);
        return nullptr;
    }

    static PyObject* KnownContactField_ConvertNameToType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::ConvertNameToType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownContactField_ConvertTypeToName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::ConvertTypeToName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_Email(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::Email());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_InstantMessage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::InstantMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_Location(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownContactField_get_PhoneNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Contacts::KnownContactField::PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownContactField[] = {
        { "convert_name_to_type", reinterpret_cast<PyCFunction>(KnownContactField_ConvertNameToType), METH_VARARGS | METH_STATIC, nullptr },
        { "convert_type_to_name", reinterpret_cast<PyCFunction>(KnownContactField_ConvertTypeToName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_email", reinterpret_cast<PyCFunction>(KnownContactField_get_Email), METH_NOARGS | METH_STATIC, nullptr },
        { "get_instant_message", reinterpret_cast<PyCFunction>(KnownContactField_get_InstantMessage), METH_NOARGS | METH_STATIC, nullptr },
        { "get_location", reinterpret_cast<PyCFunction>(KnownContactField_get_Location), METH_NOARGS | METH_STATIC, nullptr },
        { "get_phone_number", reinterpret_cast<PyCFunction>(KnownContactField_get_PhoneNumber), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownContactField[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownContactField[] = 
    {
        { Py_tp_new, _new_KnownContactField },
        { Py_tp_methods, _methods_KnownContactField },
        { Py_tp_getset, _getset_KnownContactField },
        { },
    };

    static PyType_Spec _type_spec_KnownContactField =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.KnownContactField",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownContactField
    };

    // ----- PinnedContactIdsQueryResult class --------------------
    constexpr const char* const _type_name_PinnedContactIdsQueryResult = "PinnedContactIdsQueryResult";

    static PyObject* _new_PinnedContactIdsQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PinnedContactIdsQueryResult);
        return nullptr;
    }

    static void _dealloc_PinnedContactIdsQueryResult(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PinnedContactIdsQueryResult_get_ContactIds(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PinnedContactIdsQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PinnedContactIdsQueryResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PinnedContactIdsQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PinnedContactIdsQueryResult[] = {
        { "contact_ids", reinterpret_cast<getter>(PinnedContactIdsQueryResult_get_ContactIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PinnedContactIdsQueryResult[] = 
    {
        { Py_tp_new, _new_PinnedContactIdsQueryResult },
        { Py_tp_dealloc, _dealloc_PinnedContactIdsQueryResult },
        { Py_tp_methods, _methods_PinnedContactIdsQueryResult },
        { Py_tp_getset, _getset_PinnedContactIdsQueryResult },
        { },
    };

    static PyType_Spec _type_spec_PinnedContactIdsQueryResult =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.PinnedContactIdsQueryResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PinnedContactIdsQueryResult
    };

    // ----- PinnedContactManager class --------------------
    constexpr const char* const _type_name_PinnedContactManager = "PinnedContactManager";

    static PyObject* _new_PinnedContactManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PinnedContactManager);
        return nullptr;
    }

    static void _dealloc_PinnedContactManager(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PinnedContactManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_GetPinnedContactIdsAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPinnedContactIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsContactPinned(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.IsContactPinned(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsPinSurfaceSupported(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 0);

                return py::convert(self->obj.IsPinSurfaceSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Contacts::PinnedContactManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestPinContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestPinContactAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestPinContactsAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Contacts::Contact>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestPinContactsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_RequestUnpinContactAsync(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::PinnedContactSurface>(args, 1);

                return py::convert(self->obj.RequestUnpinContactAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_SignalContactActivity(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(args, 0);

                self->obj.SignalContactActivity(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PinnedContactManager_get_User(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PinnedContactManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PinnedContactManager[] = {
        { "get_default", reinterpret_cast<PyCFunction>(PinnedContactManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(PinnedContactManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_pinned_contact_ids_async", reinterpret_cast<PyCFunction>(PinnedContactManager_GetPinnedContactIdsAsync), METH_VARARGS, nullptr },
        { "is_contact_pinned", reinterpret_cast<PyCFunction>(PinnedContactManager_IsContactPinned), METH_VARARGS, nullptr },
        { "is_pin_surface_supported", reinterpret_cast<PyCFunction>(PinnedContactManager_IsPinSurfaceSupported), METH_VARARGS, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(PinnedContactManager_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "request_pin_contact_async", reinterpret_cast<PyCFunction>(PinnedContactManager_RequestPinContactAsync), METH_VARARGS, nullptr },
        { "request_pin_contacts_async", reinterpret_cast<PyCFunction>(PinnedContactManager_RequestPinContactsAsync), METH_VARARGS, nullptr },
        { "request_unpin_contact_async", reinterpret_cast<PyCFunction>(PinnedContactManager_RequestUnpinContactAsync), METH_VARARGS, nullptr },
        { "signal_contact_activity", reinterpret_cast<PyCFunction>(PinnedContactManager_SignalContactActivity), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PinnedContactManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PinnedContactManager[] = {
        { "user", reinterpret_cast<getter>(PinnedContactManager_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PinnedContactManager[] = 
    {
        { Py_tp_new, _new_PinnedContactManager },
        { Py_tp_dealloc, _dealloc_PinnedContactManager },
        { Py_tp_methods, _methods_PinnedContactManager },
        { Py_tp_getset, _getset_PinnedContactManager },
        { },
    };

    static PyType_Spec _type_spec_PinnedContactManager =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.PinnedContactManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::PinnedContactManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PinnedContactManager
    };

    // ----- IContactField interface --------------------
    constexpr const char* const _type_name_IContactField = "IContactField";

    static PyObject* _new_IContactField(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactField);
        return nullptr;
    }

    static void _dealloc_IContactField(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactField_get_Category(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Name(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Type(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactField_get_Value(py::wrapper::Windows::ApplicationModel::Contacts::IContactField* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactField(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactField>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactField[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactField), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactField[] = {
        { "category", reinterpret_cast<getter>(IContactField_get_Category), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IContactField_get_Name), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IContactField_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IContactField_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactField[] = 
    {
        { Py_tp_new, _new_IContactField },
        { Py_tp_dealloc, _dealloc_IContactField },
        { Py_tp_methods, _methods_IContactField },
        { Py_tp_getset, _getset_IContactField },
        { },
    };

    static PyType_Spec _type_spec_IContactField =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.IContactField",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactField),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactField
    };

    // ----- IContactFieldFactory interface --------------------
    constexpr const char* const _type_name_IContactFieldFactory = "IContactFieldFactory";

    static PyObject* _new_IContactFieldFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactFieldFactory);
        return nullptr;
    }

    static void _dealloc_IContactFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactFieldFactory_CreateField(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);

                return py::convert(self->obj.CreateField(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 2);

                return py::convert(self->obj.CreateField(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldType>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 3);

                return py::convert(self->obj.CreateField(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IContactFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactFieldFactory[] = {
        { "create_field", reinterpret_cast<PyCFunction>(IContactFieldFactory_CreateField), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IContactFieldFactory[] = 
    {
        { Py_tp_new, _new_IContactFieldFactory },
        { Py_tp_dealloc, _dealloc_IContactFieldFactory },
        { Py_tp_methods, _methods_IContactFieldFactory },
        { Py_tp_getset, _getset_IContactFieldFactory },
        { },
    };

    static PyType_Spec _type_spec_IContactFieldFactory =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.IContactFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactFieldFactory
    };

    // ----- IContactInstantMessageFieldFactory interface --------------------
    constexpr const char* const _type_name_IContactInstantMessageFieldFactory = "IContactInstantMessageFieldFactory";

    static PyObject* _new_IContactInstantMessageFieldFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactInstantMessageFieldFactory);
        return nullptr;
    }

    static void _dealloc_IContactInstantMessageFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactInstantMessageFieldFactory_CreateInstantMessage(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateInstantMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateInstantMessage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                return py::convert(self->obj.CreateInstantMessage(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IContactInstantMessageFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactInstantMessageFieldFactory[] = {
        { "create_instant_message", reinterpret_cast<PyCFunction>(IContactInstantMessageFieldFactory_CreateInstantMessage), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactInstantMessageFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactInstantMessageFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IContactInstantMessageFieldFactory[] = 
    {
        { Py_tp_new, _new_IContactInstantMessageFieldFactory },
        { Py_tp_dealloc, _dealloc_IContactInstantMessageFieldFactory },
        { Py_tp_methods, _methods_IContactInstantMessageFieldFactory },
        { Py_tp_getset, _getset_IContactInstantMessageFieldFactory },
        { },
    };

    static PyType_Spec _type_spec_IContactInstantMessageFieldFactory =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.IContactInstantMessageFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactInstantMessageFieldFactory
    };

    // ----- IContactLocationFieldFactory interface --------------------
    constexpr const char* const _type_name_IContactLocationFieldFactory = "IContactLocationFieldFactory";

    static PyObject* _new_IContactLocationFieldFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IContactLocationFieldFactory);
        return nullptr;
    }

    static void _dealloc_IContactLocationFieldFactory(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IContactLocationFieldFactory_CreateLocation(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateLocation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);

                return py::convert(self->obj.CreateLocation(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactFieldCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.CreateLocation(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IContactLocationFieldFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactLocationFieldFactory[] = {
        { "create_location", reinterpret_cast<PyCFunction>(IContactLocationFieldFactory_CreateLocation), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactLocationFieldFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactLocationFieldFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IContactLocationFieldFactory[] = 
    {
        { Py_tp_new, _new_IContactLocationFieldFactory },
        { Py_tp_dealloc, _dealloc_IContactLocationFieldFactory },
        { Py_tp_methods, _methods_IContactLocationFieldFactory },
        { Py_tp_getset, _getset_IContactLocationFieldFactory },
        { },
    };

    static PyType_Spec _type_spec_IContactLocationFieldFactory =
    {
        "_winsdk_Windows_ApplicationModel_Contacts.IContactLocationFieldFactory",
        sizeof(py::wrapper::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactLocationFieldFactory
    };

    // ----- Windows.ApplicationModel.Contacts Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::AggregateContactManager>::python_type = py::register_python_type(module, _type_name_AggregateContactManager, &_type_spec_AggregateContactManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::Contact>::python_type = py::register_python_type(module, _type_name_Contact, &_type_spec_Contact, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAddress>::python_type = py::register_python_type(module, _type_name_ContactAddress, &_type_spec_ContactAddress, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotation>::python_type = py::register_python_type(module, _type_name_ContactAnnotation, &_type_spec_ContactAnnotation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationList>::python_type = py::register_python_type(module, _type_name_ContactAnnotationList, &_type_spec_ContactAnnotationList, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactAnnotationStore>::python_type = py::register_python_type(module, _type_name_ContactAnnotationStore, &_type_spec_ContactAnnotationStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactBatch>::python_type = py::register_python_type(module, _type_name_ContactBatch, &_type_spec_ContactBatch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardDelayedDataLoader>::python_type = py::register_python_type(module, _type_name_ContactCardDelayedDataLoader, &_type_spec_ContactCardDelayedDataLoader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactCardOptions>::python_type = py::register_python_type(module, _type_name_ContactCardOptions, &_type_spec_ContactCardOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChange>::python_type = py::register_python_type(module, _type_name_ContactChange, &_type_spec_ContactChange, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeReader>::python_type = py::register_python_type(module, _type_name_ContactChangeReader, &_type_spec_ContactChangeReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangeTracker>::python_type = py::register_python_type(module, _type_name_ContactChangeTracker, &_type_spec_ContactChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedDeferral>::python_type = py::register_python_type(module, _type_name_ContactChangedDeferral, &_type_spec_ContactChangedDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ContactChangedEventArgs, &_type_spec_ContactChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactConnectedServiceAccount>::python_type = py::register_python_type(module, _type_name_ContactConnectedServiceAccount, &_type_spec_ContactConnectedServiceAccount, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactDate>::python_type = py::register_python_type(module, _type_name_ContactDate, &_type_spec_ContactDate, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactEmail>::python_type = py::register_python_type(module, _type_name_ContactEmail, &_type_spec_ContactEmail, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactField>::python_type = py::register_python_type(module, _type_name_ContactField, &_type_spec_ContactField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactFieldFactory>::python_type = py::register_python_type(module, _type_name_ContactFieldFactory, &_type_spec_ContactFieldFactory, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactGroup>::python_type = py::register_python_type(module, _type_name_ContactGroup, &_type_spec_ContactGroup, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInformation>::python_type = py::register_python_type(module, _type_name_ContactInformation, &_type_spec_ContactInformation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactInstantMessageField>::python_type = py::register_python_type(module, _type_name_ContactInstantMessageField, &_type_spec_ContactInstantMessageField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactJobInfo>::python_type = py::register_python_type(module, _type_name_ContactJobInfo, &_type_spec_ContactJobInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLaunchActionVerbs>::python_type = py::register_python_type(module, _type_name_ContactLaunchActionVerbs, &_type_spec_ContactLaunchActionVerbs, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactList>::python_type = py::register_python_type(module, _type_name_ContactList, &_type_spec_ContactList, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListLimitedWriteOperations>::python_type = py::register_python_type(module, _type_name_ContactListLimitedWriteOperations, &_type_spec_ContactListLimitedWriteOperations, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncConstraints>::python_type = py::register_python_type(module, _type_name_ContactListSyncConstraints, &_type_spec_ContactListSyncConstraints, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactListSyncManager>::python_type = py::register_python_type(module, _type_name_ContactListSyncManager, &_type_spec_ContactListSyncManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactLocationField>::python_type = py::register_python_type(module, _type_name_ContactLocationField, &_type_spec_ContactLocationField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManager>::python_type = py::register_python_type(module, _type_name_ContactManager, &_type_spec_ContactManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactManagerForUser>::python_type = py::register_python_type(module, _type_name_ContactManagerForUser, &_type_spec_ContactManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactMatchReason>::python_type = py::register_python_type(module, _type_name_ContactMatchReason, &_type_spec_ContactMatchReason, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanel>::python_type = py::register_python_type(module, _type_name_ContactPanel, &_type_spec_ContactPanel, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelClosingEventArgs>::python_type = py::register_python_type(module, _type_name_ContactPanelClosingEventArgs, &_type_spec_ContactPanelClosingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPanelLaunchFullAppRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_ContactPanelLaunchFullAppRequestedEventArgs, &_type_spec_ContactPanelLaunchFullAppRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPhone>::python_type = py::register_python_type(module, _type_name_ContactPhone, &_type_spec_ContactPhone, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactPicker>::python_type = py::register_python_type(module, _type_name_ContactPicker, &_type_spec_ContactPicker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryOptions>::python_type = py::register_python_type(module, _type_name_ContactQueryOptions, &_type_spec_ContactQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactQueryTextSearch>::python_type = py::register_python_type(module, _type_name_ContactQueryTextSearch, &_type_spec_ContactQueryTextSearch, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactReader>::python_type = py::register_python_type(module, _type_name_ContactReader, &_type_spec_ContactReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactSignificantOther>::python_type = py::register_python_type(module, _type_name_ContactSignificantOther, &_type_spec_ContactSignificantOther, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStore>::python_type = py::register_python_type(module, _type_name_ContactStore, &_type_spec_ContactStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactStoreNotificationTriggerDetails>::python_type = py::register_python_type(module, _type_name_ContactStoreNotificationTriggerDetails, &_type_spec_ContactStoreNotificationTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::ContactWebsite>::python_type = py::register_python_type(module, _type_name_ContactWebsite, &_type_spec_ContactWebsite, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::FullContactCardOptions>::python_type = py::register_python_type(module, _type_name_FullContactCardOptions, &_type_spec_FullContactCardOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::KnownContactField>::python_type = py::register_python_type(module, _type_name_KnownContactField, &_type_spec_KnownContactField, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactIdsQueryResult>::python_type = py::register_python_type(module, _type_name_PinnedContactIdsQueryResult, &_type_spec_PinnedContactIdsQueryResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::PinnedContactManager>::python_type = py::register_python_type(module, _type_name_PinnedContactManager, &_type_spec_PinnedContactManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactField>::python_type = py::register_python_type(module, _type_name_IContactField, &_type_spec_IContactField, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactFieldFactory>::python_type = py::register_python_type(module, _type_name_IContactFieldFactory, &_type_spec_IContactFieldFactory, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactInstantMessageFieldFactory>::python_type = py::register_python_type(module, _type_name_IContactInstantMessageFieldFactory, &_type_spec_IContactInstantMessageFieldFactory, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Contacts::IContactLocationFieldFactory>::python_type = py::register_python_type(module, _type_name_IContactLocationFieldFactory, &_type_spec_IContactLocationFieldFactory, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Contacts");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Contacts",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel::Contacts

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel_Contacts (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Contacts::module_def);
}
