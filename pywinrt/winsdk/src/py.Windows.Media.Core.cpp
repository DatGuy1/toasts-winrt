// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.4

#include "pybase.h"
#include "py.Windows.Media.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ChapterCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecQuery>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecSubtypes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::DataCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ImageCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::LowLightFusion>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::LowLightFusionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaBinder>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaCueEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSample>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseSourceBuffer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseSourceBufferList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseStreamSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SpeechCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextBouten>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextLine>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextRegion>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextRuby>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextStyle>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSubformat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaCue>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaTrack>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseTimeRange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextDouble>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextPadding>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextPoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSize>::python_type;

PyObject* py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert(winrt::Windows::Media::Core::MseTimeRange instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::MseTimeRange>());
}
winrt::Windows::Media::Core::MseTimeRange py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::MseTimeRange>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::MseTimeRange>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::MseTimeRange or dict");
        throw python_exception();
    }

    winrt::Windows::Media::Core::MseTimeRange return_value{};

    PyObject* py_Start = PyDict_GetItemString(obj, "start");
    if (!py_Start) {
        PyErr_SetString(PyExc_KeyError, "Start");
        throw python_exception();
    }
    return_value.Start = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_Start);

    PyObject* py_End = PyDict_GetItemString(obj, "end");
    if (!py_End) {
        PyErr_SetString(PyExc_KeyError, "End");
        throw python_exception();
    }
    return_value.End = converter<winrt::Windows::Foundation::TimeSpan>::convert_to(py_End);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert(winrt::Windows::Media::Core::TimedTextDouble instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextDouble>());
}
winrt::Windows::Media::Core::TimedTextDouble py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextDouble>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextDouble>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextDouble or dict");
        throw python_exception();
    }

    winrt::Windows::Media::Core::TimedTextDouble return_value{};

    PyObject* py_Value = PyDict_GetItemString(obj, "value");
    if (!py_Value) {
        PyErr_SetString(PyExc_KeyError, "Value");
        throw python_exception();
    }
    return_value.Value = converter<double>::convert_to(py_Value);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) {
        PyErr_SetString(PyExc_KeyError, "Unit");
        throw python_exception();
    }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert(winrt::Windows::Media::Core::TimedTextPadding instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextPadding>());
}
winrt::Windows::Media::Core::TimedTextPadding py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextPadding>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPadding>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextPadding or dict");
        throw python_exception();
    }

    winrt::Windows::Media::Core::TimedTextPadding return_value{};

    PyObject* py_Before = PyDict_GetItemString(obj, "before");
    if (!py_Before) {
        PyErr_SetString(PyExc_KeyError, "Before");
        throw python_exception();
    }
    return_value.Before = converter<double>::convert_to(py_Before);

    PyObject* py_After = PyDict_GetItemString(obj, "after");
    if (!py_After) {
        PyErr_SetString(PyExc_KeyError, "After");
        throw python_exception();
    }
    return_value.After = converter<double>::convert_to(py_After);

    PyObject* py_Start = PyDict_GetItemString(obj, "start");
    if (!py_Start) {
        PyErr_SetString(PyExc_KeyError, "Start");
        throw python_exception();
    }
    return_value.Start = converter<double>::convert_to(py_Start);

    PyObject* py_End = PyDict_GetItemString(obj, "end");
    if (!py_End) {
        PyErr_SetString(PyExc_KeyError, "End");
        throw python_exception();
    }
    return_value.End = converter<double>::convert_to(py_End);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) {
        PyErr_SetString(PyExc_KeyError, "Unit");
        throw python_exception();
    }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert(winrt::Windows::Media::Core::TimedTextPoint instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextPoint>());
}
winrt::Windows::Media::Core::TimedTextPoint py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextPoint>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPoint>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextPoint or dict");
        throw python_exception();
    }

    winrt::Windows::Media::Core::TimedTextPoint return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) {
        PyErr_SetString(PyExc_KeyError, "X");
        throw python_exception();
    }
    return_value.X = converter<double>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) {
        PyErr_SetString(PyExc_KeyError, "Y");
        throw python_exception();
    }
    return_value.Y = converter<double>::convert_to(py_Y);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) {
        PyErr_SetString(PyExc_KeyError, "Unit");
        throw python_exception();
    }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert(winrt::Windows::Media::Core::TimedTextSize instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Core::TimedTextSize>());
}
winrt::Windows::Media::Core::TimedTextSize py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Core::TimedTextSize>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextSize>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextSize or dict");
        throw python_exception();
    }

    winrt::Windows::Media::Core::TimedTextSize return_value{};

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) {
        PyErr_SetString(PyExc_KeyError, "Height");
        throw python_exception();
    }
    return_value.Height = converter<double>::convert_to(py_Height);

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) {
        PyErr_SetString(PyExc_KeyError, "Width");
        throw python_exception();
    }
    return_value.Width = converter<double>::convert_to(py_Width);

    PyObject* py_Unit = PyDict_GetItemString(obj, "unit");
    if (!py_Unit) {
        PyErr_SetString(PyExc_KeyError, "Unit");
        throw python_exception();
    }
    return_value.Unit = converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(py_Unit);

    return return_value;
}

namespace py::cpp::Windows::Media::Core
{
    // ----- AudioStreamDescriptor class --------------------
    constexpr const char* const _type_name_AudioStreamDescriptor = "AudioStreamDescriptor";

    static PyObject* _new_AudioStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::AudioStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioStreamDescriptor(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrailingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.TrailingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeadingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LeadingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStreamDescriptor[] = {
        { "encoding_properties", reinterpret_cast<getter>(AudioStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "trailing_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_TrailingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_TrailingEncoderPadding), nullptr, nullptr },
        { "leading_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_LeadingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_LeadingEncoderPadding), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AudioStreamDescriptor_get_Name), reinterpret_cast<setter>(AudioStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioStreamDescriptor_get_Language), reinterpret_cast<setter>(AudioStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(AudioStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioStreamDescriptor_get_Label), reinterpret_cast<setter>(AudioStreamDescriptor_put_Label), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStreamDescriptor[] = 
    {
        { Py_tp_new, _new_AudioStreamDescriptor },
        { Py_tp_dealloc, _dealloc_AudioStreamDescriptor },
        { Py_tp_methods, _methods_AudioStreamDescriptor },
        { Py_tp_getset, _getset_AudioStreamDescriptor },
        { },
    };

    static PyType_Spec _type_spec_AudioStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.AudioStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::AudioStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStreamDescriptor
    };

    // ----- AudioTrack class --------------------
    constexpr const char* const _type_name_AudioTrack = "AudioTrack";

    static PyObject* _new_AudioTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioTrack);
        return nullptr;
    }

    static void _dealloc_AudioTrack(py::wrapper::Windows::Media::Core::AudioTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Name(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioTrack_put_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioTrack_get_Id(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Language(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_TrackKind(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::AudioTrack, winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(AudioTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_remove_OpenFailed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrack[] = {
        { "name", reinterpret_cast<getter>(AudioTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(AudioTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(AudioTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioTrack_get_Label), reinterpret_cast<setter>(AudioTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AudioTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(AudioTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrack[] = 
    {
        { Py_tp_new, _new_AudioTrack },
        { Py_tp_dealloc, _dealloc_AudioTrack },
        { Py_tp_methods, _methods_AudioTrack },
        { Py_tp_getset, _getset_AudioTrack },
        { },
    };

    static PyType_Spec _type_spec_AudioTrack =
    {
        "_winsdk_Windows_Media_Core.AudioTrack",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrack
    };

    // ----- AudioTrackOpenFailedEventArgs class --------------------
    constexpr const char* const _type_name_AudioTrackOpenFailedEventArgs = "AudioTrackOpenFailedEventArgs";

    static PyObject* _new_AudioTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackOpenFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(AudioTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, _new_AudioTrackOpenFailedEventArgs },
        { Py_tp_dealloc, _dealloc_AudioTrackOpenFailedEventArgs },
        { Py_tp_methods, _methods_AudioTrackOpenFailedEventArgs },
        { Py_tp_getset, _getset_AudioTrackOpenFailedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_AudioTrackOpenFailedEventArgs =
    {
        "_winsdk_Windows_Media_Core.AudioTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackOpenFailedEventArgs
    };

    // ----- AudioTrackSupportInfo class --------------------
    constexpr const char* const _type_name_AudioTrackSupportInfo = "AudioTrackSupportInfo";

    static PyObject* _new_AudioTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_AudioTrackSupportInfo(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_Degradation(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Degradation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_DegradationReason(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DegradationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackSupportInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "degradation", reinterpret_cast<getter>(AudioTrackSupportInfo_get_Degradation), nullptr, nullptr, nullptr },
        { "degradation_reason", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DegradationReason), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackSupportInfo[] = 
    {
        { Py_tp_new, _new_AudioTrackSupportInfo },
        { Py_tp_dealloc, _dealloc_AudioTrackSupportInfo },
        { Py_tp_methods, _methods_AudioTrackSupportInfo },
        { Py_tp_getset, _getset_AudioTrackSupportInfo },
        { },
    };

    static PyType_Spec _type_spec_AudioTrackSupportInfo =
    {
        "_winsdk_Windows_Media_Core.AudioTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackSupportInfo
    };

    // ----- ChapterCue class --------------------
    constexpr const char* const _type_name_ChapterCue = "ChapterCue";

    static PyObject* _new_ChapterCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ChapterCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChapterCue(py::wrapper::Windows::Media::Core::ChapterCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChapterCue_get_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ChapterCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChapterCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChapterCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChapterCue[] = {
        { "title", reinterpret_cast<getter>(ChapterCue_get_Title), reinterpret_cast<setter>(ChapterCue_put_Title), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ChapterCue_get_StartTime), reinterpret_cast<setter>(ChapterCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChapterCue_get_Id), reinterpret_cast<setter>(ChapterCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ChapterCue_get_Duration), reinterpret_cast<setter>(ChapterCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChapterCue[] = 
    {
        { Py_tp_new, _new_ChapterCue },
        { Py_tp_dealloc, _dealloc_ChapterCue },
        { Py_tp_methods, _methods_ChapterCue },
        { Py_tp_getset, _getset_ChapterCue },
        { },
    };

    static PyType_Spec _type_spec_ChapterCue =
    {
        "_winsdk_Windows_Media_Core.ChapterCue",
        sizeof(py::wrapper::Windows::Media::Core::ChapterCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChapterCue
    };

    // ----- CodecInfo class --------------------
    constexpr const char* const _type_name_CodecInfo = "CodecInfo";

    static PyObject* _new_CodecInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CodecInfo);
        return nullptr;
    }

    static void _dealloc_CodecInfo(py::wrapper::Windows::Media::Core::CodecInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CodecInfo_get_Category(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_DisplayName(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_IsTrusted(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Kind(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Subtypes(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecInfo[] = {
        { "category", reinterpret_cast<getter>(CodecInfo_get_Category), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(CodecInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_trusted", reinterpret_cast<getter>(CodecInfo_get_IsTrusted), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CodecInfo_get_Kind), nullptr, nullptr, nullptr },
        { "subtypes", reinterpret_cast<getter>(CodecInfo_get_Subtypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CodecInfo[] = 
    {
        { Py_tp_new, _new_CodecInfo },
        { Py_tp_dealloc, _dealloc_CodecInfo },
        { Py_tp_methods, _methods_CodecInfo },
        { Py_tp_getset, _getset_CodecInfo },
        { },
    };

    static PyType_Spec _type_spec_CodecInfo =
    {
        "_winsdk_Windows_Media_Core.CodecInfo",
        sizeof(py::wrapper::Windows::Media::Core::CodecInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecInfo
    };

    // ----- CodecQuery class --------------------
    constexpr const char* const _type_name_CodecQuery = "CodecQuery";

    static PyObject* _new_CodecQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::CodecQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CodecQuery(py::wrapper::Windows::Media::Core::CodecQuery* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CodecQuery_FindAllAsync(py::wrapper::Windows::Media::Core::CodecQuery* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::CodecKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::CodecCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecQuery[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CodecQuery_FindAllAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecQuery[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecQuery[] = 
    {
        { Py_tp_new, _new_CodecQuery },
        { Py_tp_dealloc, _dealloc_CodecQuery },
        { Py_tp_methods, _methods_CodecQuery },
        { Py_tp_getset, _getset_CodecQuery },
        { },
    };

    static PyType_Spec _type_spec_CodecQuery =
    {
        "_winsdk_Windows_Media_Core.CodecQuery",
        sizeof(py::wrapper::Windows::Media::Core::CodecQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecQuery
    };

    // ----- CodecSubtypes class --------------------
    constexpr const char* const _type_name_CodecSubtypes = "CodecSubtypes";

    static PyObject* _new_CodecSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CodecSubtypes);
        return nullptr;
    }

    static PyObject* CodecSubtypes_get_AudioFormatAac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrNB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrNB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3Spdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3Spdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyDDPlus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyDDPlus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDrm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDrm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFloat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFloat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMP3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMP3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMPeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMPeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMsp1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMsp1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatOpus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatOpus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatPcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatPcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioLossless(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioLossless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWmaSpdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWmaSpdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormat420O(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormat420O());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV50(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV50());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvh1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvh1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvhD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvhD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264ES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264ES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH265(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH265());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevcES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevcES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatM4S2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatM4S2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP43(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP43());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4S(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4S());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4V(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4V());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP80(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP80());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP90(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP90());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecSubtypes[] = {
        { "get_audio_format_aac", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_adts", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAdts), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_alac", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAlac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_n_b", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAmrNB), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_w_b", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAmrWB), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_w_p", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAmrWP), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_a_c3", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDolbyAC3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_a_c3_spdif", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDolbyAC3Spdif), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_d_d_plus", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDolbyDDPlus), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_drm", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDrm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dts", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDts), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_flac", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatFlac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_float", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatFloat), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_m_p3", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatMP3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_m_peg", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatMPeg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_msp1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatMsp1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_opus", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatOpus), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_pcm", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatPcm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_lossless", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWMAudioLossless), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_v8", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWMAudioV8), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_v9", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWMAudioV9), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_wma_spdif", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWmaSpdif), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format420_o", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormat420O), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_d_v25", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDV25), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_d_v50", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDV50), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvc", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvh1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvh1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvh_d", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvhD), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvsd", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvsd), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvsl", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvsl), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h263", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH263), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h264", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH264), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h264_e_s", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH264ES), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h265", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH265), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_hevc", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatHevc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_hevc_e_s", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatHevcES), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m4_s2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatM4S2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p43", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMP43), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p4_s", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMP4S), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p4_v", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMP4V), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mjpg", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMjpg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mpeg2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMpeg2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mpg1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMpg1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mss1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMss1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mss2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMss2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_v_p80", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatVP80), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_v_p90", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatVP90), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWmv1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWmv2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv3", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWmv3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wvc1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWvc1), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecSubtypes[] = 
    {
        { Py_tp_new, _new_CodecSubtypes },
        { Py_tp_methods, _methods_CodecSubtypes },
        { Py_tp_getset, _getset_CodecSubtypes },
        { },
    };

    static PyType_Spec _type_spec_CodecSubtypes =
    {
        "_winsdk_Windows_Media_Core.CodecSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecSubtypes
    };

    // ----- DataCue class --------------------
    constexpr const char* const _type_name_DataCue = "DataCue";

    static PyObject* _new_DataCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::DataCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataCue(py::wrapper::Windows::Media::Core::DataCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataCue_get_Data(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Data(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Properties(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataCue_get_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Id(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Id(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Duration(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Duration(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::DataCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataCue[] = {
        { "data", reinterpret_cast<getter>(DataCue_get_Data), reinterpret_cast<setter>(DataCue_put_Data), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataCue_get_Properties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(DataCue_get_StartTime), reinterpret_cast<setter>(DataCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DataCue_get_Id), reinterpret_cast<setter>(DataCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(DataCue_get_Duration), reinterpret_cast<setter>(DataCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataCue[] = 
    {
        { Py_tp_new, _new_DataCue },
        { Py_tp_dealloc, _dealloc_DataCue },
        { Py_tp_methods, _methods_DataCue },
        { Py_tp_getset, _getset_DataCue },
        { },
    };

    static PyType_Spec _type_spec_DataCue =
    {
        "_winsdk_Windows_Media_Core.DataCue",
        sizeof(py::wrapper::Windows::Media::Core::DataCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataCue
    };

    // ----- FaceDetectedEventArgs class --------------------
    constexpr const char* const _type_name_FaceDetectedEventArgs = "FaceDetectedEventArgs";

    static PyObject* _new_FaceDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FaceDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_FaceDetectedEventArgs(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(FaceDetectedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectedEventArgs[] = 
    {
        { Py_tp_new, _new_FaceDetectedEventArgs },
        { Py_tp_dealloc, _dealloc_FaceDetectedEventArgs },
        { Py_tp_methods, _methods_FaceDetectedEventArgs },
        { Py_tp_getset, _getset_FaceDetectedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_FaceDetectedEventArgs =
    {
        "_winsdk_Windows_Media_Core.FaceDetectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectedEventArgs
    };

    // ----- FaceDetectionEffect class --------------------
    constexpr const char* const _type_name_FaceDetectionEffect = "FaceDetectionEffect";

    static PyObject* _new_FaceDetectionEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FaceDetectionEffect);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffect(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectionEffect_SetProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_get_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_get_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredDetectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredDetectionInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_add_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::FaceDetectionEffect, winrt::Windows::Media::Core::FaceDetectedEventArgs>>(arg);

            return py::convert(self->obj.FaceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_remove_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FaceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(FaceDetectionEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_add_FaceDetected), METH_O, nullptr },
        { "remove_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_remove_FaceDetected), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffect[] = {
        { "enabled", reinterpret_cast<getter>(FaceDetectionEffect_get_Enabled), reinterpret_cast<setter>(FaceDetectionEffect_put_Enabled), nullptr, nullptr },
        { "desired_detection_interval", reinterpret_cast<getter>(FaceDetectionEffect_get_DesiredDetectionInterval), reinterpret_cast<setter>(FaceDetectionEffect_put_DesiredDetectionInterval), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffect[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffect },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffect },
        { Py_tp_methods, _methods_FaceDetectionEffect },
        { Py_tp_getset, _getset_FaceDetectionEffect },
        { },
    };

    static PyType_Spec _type_spec_FaceDetectionEffect =
    {
        "_winsdk_Windows_Media_Core.FaceDetectionEffect",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffect
    };

    // ----- FaceDetectionEffectDefinition class --------------------
    constexpr const char* const _type_name_FaceDetectionEffectDefinition = "FaceDetectionEffectDefinition";

    static PyObject* _new_FaceDetectionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::FaceDetectionEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FaceDetectionEffectDefinition(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SynchronousDetectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SynchronousDetectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::FaceDetectionMode>(arg);

            self->obj.DetectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectDefinition[] = {
        { "synchronous_detection_enabled", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled), nullptr, nullptr },
        { "detection_mode", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_DetectionMode), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_DetectionMode), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectDefinition[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffectDefinition },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffectDefinition },
        { Py_tp_methods, _methods_FaceDetectionEffectDefinition },
        { Py_tp_getset, _getset_FaceDetectionEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_FaceDetectionEffectDefinition =
    {
        "_winsdk_Windows_Media_Core.FaceDetectionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectDefinition
    };

    // ----- FaceDetectionEffectFrame class --------------------
    constexpr const char* const _type_name_FaceDetectionEffectFrame = "FaceDetectionEffectFrame";

    static PyObject* _new_FaceDetectionEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FaceDetectionEffectFrame);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FaceDetectionEffectFrame_Close(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_DetectedFaces(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectedFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Type(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(FaceDetectionEffectFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FaceDetectionEffectFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FaceDetectionEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectFrame[] = {
        { "detected_faces", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_DetectedFaces), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_RelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Duration), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectFrame[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffectFrame },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffectFrame },
        { Py_tp_methods, _methods_FaceDetectionEffectFrame },
        { Py_tp_getset, _getset_FaceDetectionEffectFrame },
        { },
    };

    static PyType_Spec _type_spec_FaceDetectionEffectFrame =
    {
        "_winsdk_Windows_Media_Core.FaceDetectionEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectFrame
    };

    // ----- HighDynamicRangeControl class --------------------
    constexpr const char* const _type_name_HighDynamicRangeControl = "HighDynamicRangeControl";

    static PyObject* _new_HighDynamicRangeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HighDynamicRangeControl);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeControl(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HighDynamicRangeControl_get_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HighDynamicRangeControl_put_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeControl[] = {
        { "enabled", reinterpret_cast<getter>(HighDynamicRangeControl_get_Enabled), reinterpret_cast<setter>(HighDynamicRangeControl_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeControl[] = 
    {
        { Py_tp_new, _new_HighDynamicRangeControl },
        { Py_tp_dealloc, _dealloc_HighDynamicRangeControl },
        { Py_tp_methods, _methods_HighDynamicRangeControl },
        { Py_tp_getset, _getset_HighDynamicRangeControl },
        { },
    };

    static PyType_Spec _type_spec_HighDynamicRangeControl =
    {
        "_winsdk_Windows_Media_Core.HighDynamicRangeControl",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeControl
    };

    // ----- HighDynamicRangeOutput class --------------------
    constexpr const char* const _type_name_HighDynamicRangeOutput = "HighDynamicRangeOutput";

    static PyObject* _new_HighDynamicRangeOutput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HighDynamicRangeOutput);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeOutput(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HighDynamicRangeOutput_get_Certainty(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certainty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HighDynamicRangeOutput_get_FrameControllers(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeOutput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeOutput[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeOutput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeOutput[] = {
        { "certainty", reinterpret_cast<getter>(HighDynamicRangeOutput_get_Certainty), nullptr, nullptr, nullptr },
        { "frame_controllers", reinterpret_cast<getter>(HighDynamicRangeOutput_get_FrameControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeOutput[] = 
    {
        { Py_tp_new, _new_HighDynamicRangeOutput },
        { Py_tp_dealloc, _dealloc_HighDynamicRangeOutput },
        { Py_tp_methods, _methods_HighDynamicRangeOutput },
        { Py_tp_getset, _getset_HighDynamicRangeOutput },
        { },
    };

    static PyType_Spec _type_spec_HighDynamicRangeOutput =
    {
        "_winsdk_Windows_Media_Core.HighDynamicRangeOutput",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeOutput
    };

    // ----- ImageCue class --------------------
    constexpr const char* const _type_name_ImageCue = "ImageCue";

    static PyObject* _new_ImageCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ImageCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageCue(py::wrapper::Windows::Media::Core::ImageCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ImageCue_get_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(arg);

            self->obj.SoftwareBitmap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Position(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Position(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Id(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Id(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ImageCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageCue[] = {
        { "software_bitmap", reinterpret_cast<getter>(ImageCue_get_SoftwareBitmap), reinterpret_cast<setter>(ImageCue_put_SoftwareBitmap), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ImageCue_get_Position), reinterpret_cast<setter>(ImageCue_put_Position), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(ImageCue_get_Extent), reinterpret_cast<setter>(ImageCue_put_Extent), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ImageCue_get_StartTime), reinterpret_cast<setter>(ImageCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ImageCue_get_Id), reinterpret_cast<setter>(ImageCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ImageCue_get_Duration), reinterpret_cast<setter>(ImageCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageCue[] = 
    {
        { Py_tp_new, _new_ImageCue },
        { Py_tp_dealloc, _dealloc_ImageCue },
        { Py_tp_methods, _methods_ImageCue },
        { Py_tp_getset, _getset_ImageCue },
        { },
    };

    static PyType_Spec _type_spec_ImageCue =
    {
        "_winsdk_Windows_Media_Core.ImageCue",
        sizeof(py::wrapper::Windows::Media::Core::ImageCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageCue
    };

    // ----- InitializeMediaStreamSourceRequestedEventArgs class --------------------
    constexpr const char* const _type_name_InitializeMediaStreamSourceRequestedEventArgs = "InitializeMediaStreamSourceRequestedEventArgs";

    static PyObject* _new_InitializeMediaStreamSourceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InitializeMediaStreamSourceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_InitializeMediaStreamSourceRequestedEventArgs(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RandomAccessStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_Source(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(InitializeMediaStreamSourceRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InitializeMediaStreamSourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "random_access_stream", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InitializeMediaStreamSourceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_methods, _methods_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_getset, _getset_InitializeMediaStreamSourceRequestedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_InitializeMediaStreamSourceRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Core.InitializeMediaStreamSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InitializeMediaStreamSourceRequestedEventArgs
    };

    // ----- LowLightFusion class --------------------
    constexpr const char* const _type_name_LowLightFusion = "LowLightFusion";

    static PyObject* _new_LowLightFusion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLightFusion);
        return nullptr;
    }

    static PyObject* LowLightFusion_FuseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Imaging::SoftwareBitmap>>(args, 0);

                return py::convert(winrt::Windows::Media::Core::LowLightFusion::FuseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_MaxSupportedFrameCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::MaxSupportedFrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_SupportedBitmapPixelFormats(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::SupportedBitmapPixelFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusion[] = {
        { "fuse_async", reinterpret_cast<PyCFunction>(LowLightFusion_FuseAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_max_supported_frame_count", reinterpret_cast<PyCFunction>(LowLightFusion_get_MaxSupportedFrameCount), METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_bitmap_pixel_formats", reinterpret_cast<PyCFunction>(LowLightFusion_get_SupportedBitmapPixelFormats), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusion[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLightFusion[] = 
    {
        { Py_tp_new, _new_LowLightFusion },
        { Py_tp_methods, _methods_LowLightFusion },
        { Py_tp_getset, _getset_LowLightFusion },
        { },
    };

    static PyType_Spec _type_spec_LowLightFusion =
    {
        "_winsdk_Windows_Media_Core.LowLightFusion",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusion
    };

    // ----- LowLightFusionResult class --------------------
    constexpr const char* const _type_name_LowLightFusionResult = "LowLightFusionResult";

    static PyObject* _new_LowLightFusionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLightFusionResult);
        return nullptr;
    }

    static void _dealloc_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLightFusionResult_Close(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusionResult_get_Frame(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::LowLightFusionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusionResult[] = {
        { "close", reinterpret_cast<PyCFunction>(LowLightFusionResult_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLightFusionResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LowLightFusionResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LowLightFusionResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusionResult[] = {
        { "frame", reinterpret_cast<getter>(LowLightFusionResult_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLightFusionResult[] = 
    {
        { Py_tp_new, _new_LowLightFusionResult },
        { Py_tp_dealloc, _dealloc_LowLightFusionResult },
        { Py_tp_methods, _methods_LowLightFusionResult },
        { Py_tp_getset, _getset_LowLightFusionResult },
        { },
    };

    static PyType_Spec _type_spec_LowLightFusionResult =
    {
        "_winsdk_Windows_Media_Core.LowLightFusionResult",
        sizeof(py::wrapper::Windows::Media::Core::LowLightFusionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusionResult
    };

    // ----- MediaBinder class --------------------
    constexpr const char* const _type_name_MediaBinder = "MediaBinder";

    static PyObject* _new_MediaBinder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MediaBinder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBinder(py::wrapper::Windows::Media::Core::MediaBinder* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBinder_get_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBinder_put_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Token(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBinder_get_Source(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_add_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBinder, winrt::Windows::Media::Core::MediaBindingEventArgs>>(arg);

            return py::convert(self->obj.Binding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_remove_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Binding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBinder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBinder[] = {
        { "add_binding", reinterpret_cast<PyCFunction>(MediaBinder_add_Binding), METH_O, nullptr },
        { "remove_binding", reinterpret_cast<PyCFunction>(MediaBinder_remove_Binding), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBinder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBinder[] = {
        { "token", reinterpret_cast<getter>(MediaBinder_get_Token), reinterpret_cast<setter>(MediaBinder_put_Token), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(MediaBinder_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBinder[] = 
    {
        { Py_tp_new, _new_MediaBinder },
        { Py_tp_dealloc, _dealloc_MediaBinder },
        { Py_tp_methods, _methods_MediaBinder },
        { Py_tp_getset, _getset_MediaBinder },
        { },
    };

    static PyType_Spec _type_spec_MediaBinder =
    {
        "_winsdk_Windows_Media_Core.MediaBinder",
        sizeof(py::wrapper::Windows::Media::Core::MediaBinder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBinder
    };

    // ----- MediaBindingEventArgs class --------------------
    constexpr const char* const _type_name_MediaBindingEventArgs = "MediaBindingEventArgs";

    static PyObject* _new_MediaBindingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaBindingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBindingEventArgs(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaBindingEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetAdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                self->obj.SetAdaptiveMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetDownloadOperation(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                self->obj.SetDownloadOperation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStorageFile(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetStorageFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStream(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStreamReference(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStreamReference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetUri(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_get_MediaBinder(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaBinder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_add_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBindingEventArgs, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_remove_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBindingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBindingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetAdaptiveMediaSource), METH_VARARGS, nullptr },
        { "set_download_operation", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetDownloadOperation), METH_VARARGS, nullptr },
        { "set_storage_file", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStorageFile), METH_VARARGS, nullptr },
        { "set_stream", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStream), METH_VARARGS, nullptr },
        { "set_stream_reference", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStreamReference), METH_VARARGS, nullptr },
        { "set_uri", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetUri), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_remove_Canceled), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBindingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBindingEventArgs[] = {
        { "media_binder", reinterpret_cast<getter>(MediaBindingEventArgs_get_MediaBinder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBindingEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBindingEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBindingEventArgs },
        { Py_tp_methods, _methods_MediaBindingEventArgs },
        { Py_tp_getset, _getset_MediaBindingEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaBindingEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaBindingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaBindingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBindingEventArgs
    };

    // ----- MediaCueEventArgs class --------------------
    constexpr const char* const _type_name_MediaCueEventArgs = "MediaCueEventArgs";

    static PyObject* _new_MediaCueEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCueEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCueEventArgs(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCueEventArgs_get_Cue(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaCueEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCueEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCueEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCueEventArgs[] = {
        { "cue", reinterpret_cast<getter>(MediaCueEventArgs_get_Cue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCueEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCueEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCueEventArgs },
        { Py_tp_methods, _methods_MediaCueEventArgs },
        { Py_tp_getset, _getset_MediaCueEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaCueEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaCueEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaCueEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCueEventArgs
    };

    // ----- MediaSource class --------------------
    constexpr const char* const _type_name_MediaSource = "MediaSource";

    static PyObject* _new_MediaSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSource);
        return nullptr;
    }

    static void _dealloc_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSource_Close(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromAdaptiveMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromAdaptiveMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromDownloadOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromDownloadOperation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromIMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromIMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaBinder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaBinder>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaBinder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaFrameSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaFrameSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMseStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMseStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStorageFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStorageFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStreamReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStreamReference(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_OpenAsync(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_Reset(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_CustomProperties(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Duration(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedMetadataTracks(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalTimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedTextSources(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalTimedTextSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_IsOpen(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_State(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_AdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdaptiveMediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MseStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MseStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Uri(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_DownloadOperation(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DownloadOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OpenOperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenOperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSource[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaSource_Close), METH_VARARGS, nullptr },
        { "create_from_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromAdaptiveMediaSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_download_operation", reinterpret_cast<PyCFunction>(MediaSource_CreateFromDownloadOperation), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_i_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromIMediaSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_binder", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaBinder), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_frame_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaFrameSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaStreamSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_mse_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMseStreamSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_storage_file", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStorageFile), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_reference", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStreamReference), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(MediaSource_CreateFromUri), METH_VARARGS | METH_STATIC, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(MediaSource_OpenAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSource_Reset), METH_VARARGS, nullptr },
        { "add_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_add_OpenOperationCompleted), METH_O, nullptr },
        { "remove_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_remove_OpenOperationCompleted), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(MediaSource_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(MediaSource_remove_StateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSource), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSource[] = {
        { "custom_properties", reinterpret_cast<getter>(MediaSource_get_CustomProperties), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSource_get_Duration), nullptr, nullptr, nullptr },
        { "external_timed_metadata_tracks", reinterpret_cast<getter>(MediaSource_get_ExternalTimedMetadataTracks), nullptr, nullptr, nullptr },
        { "external_timed_text_sources", reinterpret_cast<getter>(MediaSource_get_ExternalTimedTextSources), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(MediaSource_get_IsOpen), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MediaSource_get_State), nullptr, nullptr, nullptr },
        { "adaptive_media_source", reinterpret_cast<getter>(MediaSource_get_AdaptiveMediaSource), nullptr, nullptr, nullptr },
        { "media_stream_source", reinterpret_cast<getter>(MediaSource_get_MediaStreamSource), nullptr, nullptr, nullptr },
        { "mse_stream_source", reinterpret_cast<getter>(MediaSource_get_MseStreamSource), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(MediaSource_get_Uri), nullptr, nullptr, nullptr },
        { "download_operation", reinterpret_cast<getter>(MediaSource_get_DownloadOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSource[] = 
    {
        { Py_tp_new, _new_MediaSource },
        { Py_tp_dealloc, _dealloc_MediaSource },
        { Py_tp_methods, _methods_MediaSource },
        { Py_tp_getset, _getset_MediaSource },
        { },
    };

    static PyType_Spec _type_spec_MediaSource =
    {
        "_winsdk_Windows_Media_Core.MediaSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSource
    };

    // ----- MediaSourceAppServiceConnection class --------------------
    constexpr const char* const _type_name_MediaSourceAppServiceConnection = "MediaSourceAppServiceConnection";

    static PyObject* _new_MediaSourceAppServiceConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                winrt::Windows::Media::Core::MediaSourceAppServiceConnection instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaSourceAppServiceConnection(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceAppServiceConnection_Start(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSourceAppServiceConnection, winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.InitializeMediaStreamSourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InitializeMediaStreamSourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAppServiceConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_Start), METH_VARARGS, nullptr },
        { "add_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "remove_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAppServiceConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAppServiceConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAppServiceConnection[] = 
    {
        { Py_tp_new, _new_MediaSourceAppServiceConnection },
        { Py_tp_dealloc, _dealloc_MediaSourceAppServiceConnection },
        { Py_tp_methods, _methods_MediaSourceAppServiceConnection },
        { Py_tp_getset, _getset_MediaSourceAppServiceConnection },
        { },
    };

    static PyType_Spec _type_spec_MediaSourceAppServiceConnection =
    {
        "_winsdk_Windows_Media_Core.MediaSourceAppServiceConnection",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAppServiceConnection
    };

    // ----- MediaSourceError class --------------------
    constexpr const char* const _type_name_MediaSourceError = "MediaSourceError";

    static PyObject* _new_MediaSourceError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceError);
        return nullptr;
    }

    static void _dealloc_MediaSourceError(py::wrapper::Windows::Media::Core::MediaSourceError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceError_get_ExtendedError(py::wrapper::Windows::Media::Core::MediaSourceError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceError[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceError[] = {
        { "extended_error", reinterpret_cast<getter>(MediaSourceError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceError[] = 
    {
        { Py_tp_new, _new_MediaSourceError },
        { Py_tp_dealloc, _dealloc_MediaSourceError },
        { Py_tp_methods, _methods_MediaSourceError },
        { Py_tp_getset, _getset_MediaSourceError },
        { },
    };

    static PyType_Spec _type_spec_MediaSourceError =
    {
        "_winsdk_Windows_Media_Core.MediaSourceError",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceError
    };

    // ----- MediaSourceOpenOperationCompletedEventArgs class --------------------
    constexpr const char* const _type_name_MediaSourceOpenOperationCompletedEventArgs = "MediaSourceOpenOperationCompletedEventArgs";

    static PyObject* _new_MediaSourceOpenOperationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceOpenOperationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceOpenOperationCompletedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceOpenOperationCompletedEventArgs_get_Error(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceOpenOperationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "error", reinterpret_cast<getter>(MediaSourceOpenOperationCompletedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceOpenOperationCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_methods, _methods_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_getset, _getset_MediaSourceOpenOperationCompletedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaSourceOpenOperationCompletedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaSourceOpenOperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceOpenOperationCompletedEventArgs
    };

    // ----- MediaSourceStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaSourceStateChangedEventArgs = "MediaSourceStateChangedEventArgs";

    static PyObject* _new_MediaSourceStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceStateChangedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_NewState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_OldState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaSourceStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaSourceStateChangedEventArgs },
        { Py_tp_methods, _methods_MediaSourceStateChangedEventArgs },
        { Py_tp_getset, _getset_MediaSourceStateChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaSourceStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaSourceStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceStateChangedEventArgs
    };

    // ----- MediaStreamSample class --------------------
    constexpr const char* const _type_name_MediaStreamSample = "MediaStreamSample";

    static PyObject* _new_MediaStreamSample(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSample);
        return nullptr;
    }

    static void _dealloc_MediaStreamSample(py::wrapper::Windows::Media::Core::MediaStreamSample* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSample_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromDirect3D11Surface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Discontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Discontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecodeTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Buffer(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_ExtendedProperties(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Protection(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Timestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Direct3D11Surface(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_add_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSample, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Processed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_remove_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Processed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSample>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSample[] = {
        { "create_from_buffer", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_direct3_d11_surface", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromDirect3D11Surface), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_add_Processed), METH_O, nullptr },
        { "remove_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_remove_Processed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSample), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSample[] = {
        { "key_frame", reinterpret_cast<getter>(MediaStreamSample_get_KeyFrame), reinterpret_cast<setter>(MediaStreamSample_put_KeyFrame), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSample_get_Duration), reinterpret_cast<setter>(MediaStreamSample_put_Duration), nullptr, nullptr },
        { "discontinuous", reinterpret_cast<getter>(MediaStreamSample_get_Discontinuous), reinterpret_cast<setter>(MediaStreamSample_put_Discontinuous), nullptr, nullptr },
        { "decode_timestamp", reinterpret_cast<getter>(MediaStreamSample_get_DecodeTimestamp), reinterpret_cast<setter>(MediaStreamSample_put_DecodeTimestamp), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(MediaStreamSample_get_Buffer), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(MediaStreamSample_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "protection", reinterpret_cast<getter>(MediaStreamSample_get_Protection), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MediaStreamSample_get_Timestamp), nullptr, nullptr, nullptr },
        { "direct3_d11_surface", reinterpret_cast<getter>(MediaStreamSample_get_Direct3D11Surface), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSample[] = 
    {
        { Py_tp_new, _new_MediaStreamSample },
        { Py_tp_dealloc, _dealloc_MediaStreamSample },
        { Py_tp_methods, _methods_MediaStreamSample },
        { Py_tp_getset, _getset_MediaStreamSample },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSample =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSample",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSample),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSample
    };

    // ----- MediaStreamSamplePropertySet class --------------------
    constexpr const char* const _type_name_MediaStreamSamplePropertySet = "MediaStreamSamplePropertySet";

    static PyObject* _new_MediaStreamSamplePropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSamplePropertySet);
        return nullptr;
    }

    static void _dealloc_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSamplePropertySet_Clear(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_First(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_GetView(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_HasKey(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Insert(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Lookup(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Remove(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_get_Size(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaStreamSamplePropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Remove), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSamplePropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSamplePropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaStreamSamplePropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSamplePropertySet[] = 
    {
        { Py_tp_new, _new_MediaStreamSamplePropertySet },
        { Py_tp_dealloc, _dealloc_MediaStreamSamplePropertySet },
        { Py_tp_methods, _methods_MediaStreamSamplePropertySet },
        { Py_tp_getset, _getset_MediaStreamSamplePropertySet },
        { Py_tp_iter, _iterator_MediaStreamSamplePropertySet },
        { Py_sq_contains, _map_contains_MediaStreamSamplePropertySet },
        { Py_mp_length, _map_length_MediaStreamSamplePropertySet },
        { Py_mp_subscript, _map_subscript_MediaStreamSamplePropertySet },
        { Py_mp_ass_subscript, _map_assign_MediaStreamSamplePropertySet },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSamplePropertySet =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSamplePropertySet",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSamplePropertySet
    };

    // ----- MediaStreamSampleProtectionProperties class --------------------
    constexpr const char* const _type_name_MediaStreamSampleProtectionProperties = "MediaStreamSampleProtectionProperties";

    static PyObject* _new_MediaStreamSampleProtectionProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSampleProtectionProperties);
        return nullptr;
    }

    static void _dealloc_MediaStreamSampleProtectionProperties(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetInitializationVector(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetKeyIdentifier(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetSubSampleMapping(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetInitializationVector(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetKeyIdentifier(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetSubSampleMapping(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSampleProtectionProperties[] = {
        { "get_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetInitializationVector), METH_VARARGS, nullptr },
        { "get_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetKeyIdentifier), METH_VARARGS, nullptr },
        { "get_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetSubSampleMapping), METH_VARARGS, nullptr },
        { "set_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetInitializationVector), METH_VARARGS, nullptr },
        { "set_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetKeyIdentifier), METH_VARARGS, nullptr },
        { "set_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetSubSampleMapping), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSampleProtectionProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSampleProtectionProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSampleProtectionProperties[] = 
    {
        { Py_tp_new, _new_MediaStreamSampleProtectionProperties },
        { Py_tp_dealloc, _dealloc_MediaStreamSampleProtectionProperties },
        { Py_tp_methods, _methods_MediaStreamSampleProtectionProperties },
        { Py_tp_getset, _getset_MediaStreamSampleProtectionProperties },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSampleProtectionProperties =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSampleProtectionProperties",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSampleProtectionProperties
    };

    // ----- MediaStreamSource class --------------------
    constexpr const char* const _type_name_MediaStreamSource = "MediaStreamSource";

    static PyObject* _new_MediaStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 1);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaStreamSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSource_AddProtectionKey(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.AddProtectionKey(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_AddStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                self->obj.AddStreamDescriptor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_NotifyError(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSourceErrorStatus>(args, 0);

                self->obj.NotifyError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_SetBufferedRange(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.SetBufferedRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.MediaProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BufferTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MusicProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_VideoProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSupportedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.MaxSupportedPlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Paused(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Paused(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>(arg);

            return py::convert(self->obj.SampleRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>(arg);

            return py::convert(self->obj.Starting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Starting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SwitchStreamsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SwitchStreamsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>(arg);

            return py::convert(self->obj.SampleRendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSource[] = {
        { "add_protection_key", reinterpret_cast<PyCFunction>(MediaStreamSource_AddProtectionKey), METH_VARARGS, nullptr },
        { "add_stream_descriptor", reinterpret_cast<PyCFunction>(MediaStreamSource_AddStreamDescriptor), METH_VARARGS, nullptr },
        { "notify_error", reinterpret_cast<PyCFunction>(MediaStreamSource_NotifyError), METH_VARARGS, nullptr },
        { "set_buffered_range", reinterpret_cast<PyCFunction>(MediaStreamSource_SetBufferedRange), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Closed), METH_O, nullptr },
        { "add_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Paused), METH_O, nullptr },
        { "remove_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Paused), METH_O, nullptr },
        { "add_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRequested), METH_O, nullptr },
        { "remove_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRequested), METH_O, nullptr },
        { "add_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Starting), METH_O, nullptr },
        { "remove_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Starting), METH_O, nullptr },
        { "add_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SwitchStreamsRequested), METH_O, nullptr },
        { "remove_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SwitchStreamsRequested), METH_O, nullptr },
        { "add_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRendered), METH_O, nullptr },
        { "remove_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRendered), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSource[] = {
        { "thumbnail", reinterpret_cast<getter>(MediaStreamSource_get_Thumbnail), reinterpret_cast<setter>(MediaStreamSource_put_Thumbnail), nullptr, nullptr },
        { "media_protection_manager", reinterpret_cast<getter>(MediaStreamSource_get_MediaProtectionManager), reinterpret_cast<setter>(MediaStreamSource_put_MediaProtectionManager), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSource_get_Duration), reinterpret_cast<setter>(MediaStreamSource_put_Duration), nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(MediaStreamSource_get_CanSeek), reinterpret_cast<setter>(MediaStreamSource_put_CanSeek), nullptr, nullptr },
        { "buffer_time", reinterpret_cast<getter>(MediaStreamSource_get_BufferTime), reinterpret_cast<setter>(MediaStreamSource_put_BufferTime), nullptr, nullptr },
        { "music_properties", reinterpret_cast<getter>(MediaStreamSource_get_MusicProperties), nullptr, nullptr, nullptr },
        { "video_properties", reinterpret_cast<getter>(MediaStreamSource_get_VideoProperties), nullptr, nullptr, nullptr },
        { "max_supported_playback_rate", reinterpret_cast<getter>(MediaStreamSource_get_MaxSupportedPlaybackRate), reinterpret_cast<setter>(MediaStreamSource_put_MaxSupportedPlaybackRate), nullptr, nullptr },
        { "is_live", reinterpret_cast<getter>(MediaStreamSource_get_IsLive), reinterpret_cast<setter>(MediaStreamSource_put_IsLive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSource[] = 
    {
        { Py_tp_new, _new_MediaStreamSource },
        { Py_tp_dealloc, _dealloc_MediaStreamSource },
        { Py_tp_methods, _methods_MediaStreamSource },
        { Py_tp_getset, _getset_MediaStreamSource },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSource =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSource
    };

    // ----- MediaStreamSourceClosedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceClosedEventArgs = "MediaStreamSourceClosedEventArgs";

    static PyObject* _new_MediaStreamSourceClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceClosedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceClosedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceClosedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceClosedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceClosedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceClosedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceClosedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedEventArgs
    };

    // ----- MediaStreamSourceClosedRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceClosedRequest = "MediaStreamSourceClosedRequest";

    static PyObject* _new_MediaStreamSourceClosedRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceClosedRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceClosedRequest_get_Reason(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedRequest[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedRequest[] = {
        { "reason", reinterpret_cast<getter>(MediaStreamSourceClosedRequest_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceClosedRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceClosedRequest },
        { Py_tp_methods, _methods_MediaStreamSourceClosedRequest },
        { Py_tp_getset, _getset_MediaStreamSourceClosedRequest },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceClosedRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceClosedRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedRequest
    };

    // ----- MediaStreamSourceSampleRenderedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRenderedEventArgs = "MediaStreamSourceSampleRenderedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRenderedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRenderedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRenderedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRenderedEventArgs_get_SampleLag(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SampleLag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRenderedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "sample_lag", reinterpret_cast<getter>(MediaStreamSourceSampleRenderedEventArgs_get_SampleLag), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRenderedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRenderedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRenderedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRenderedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRenderedEventArgs
    };

    // ----- MediaStreamSourceSampleRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRequest = "MediaStreamSourceSampleRequest";

    static PyObject* _new_MediaStreamSourceSampleRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_ReportSampleProgress(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.ReportSampleProgress(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSourceSampleRequest_put_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(arg);

            self->obj.Sample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_StreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_GetDeferral), METH_VARARGS, nullptr },
        { "report_sample_progress", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_ReportSampleProgress), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequest[] = {
        { "sample", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_Sample), reinterpret_cast<setter>(MediaStreamSourceSampleRequest_put_Sample), nullptr, nullptr },
        { "stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_StreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequest },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequest },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequest },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequest
    };

    // ----- MediaStreamSourceSampleRequestDeferral class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRequestDeferral = "MediaStreamSourceSampleRequestDeferral";

    static PyObject* _new_MediaStreamSourceSampleRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequestDeferral },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRequestDeferral =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestDeferral
    };

    // ----- MediaStreamSourceSampleRequestedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSampleRequestedEventArgs = "MediaStreamSourceSampleRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSampleRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSampleRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSampleRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequestedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSampleRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestedEventArgs
    };

    // ----- MediaStreamSourceStartingEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceStartingEventArgs = "MediaStreamSourceStartingEventArgs";

    static PyObject* _new_MediaStreamSourceStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceStartingEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceStartingEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceStartingEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceStartingEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceStartingEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceStartingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingEventArgs
    };

    // ----- MediaStreamSourceStartingRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceStartingRequest = "MediaStreamSourceStartingRequest";

    static PyObject* _new_MediaStreamSourceStartingRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceStartingRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceStartingRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_SetActualStartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetActualStartPosition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_get_StartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_actual_start_position", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_SetActualStartPosition), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequest[] = {
        { "start_position", reinterpret_cast<getter>(MediaStreamSourceStartingRequest_get_StartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingRequest },
        { Py_tp_methods, _methods_MediaStreamSourceStartingRequest },
        { Py_tp_getset, _getset_MediaStreamSourceStartingRequest },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceStartingRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceStartingRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequest
    };

    // ----- MediaStreamSourceStartingRequestDeferral class --------------------
    constexpr const char* const _type_name_MediaStreamSourceStartingRequestDeferral = "MediaStreamSourceStartingRequestDeferral";

    static PyObject* _new_MediaStreamSourceStartingRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceStartingRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceStartingRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceStartingRequestDeferral },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceStartingRequestDeferral =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceStartingRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequest class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSwitchStreamsRequest = "MediaStreamSourceSwitchStreamsRequest";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSwitchStreamsRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequest[] = {
        { "new_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor), nullptr, nullptr, nullptr },
        { "old_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequest },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSwitchStreamsRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequest
    };

    // ----- MediaStreamSourceSwitchStreamsRequestDeferral class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSwitchStreamsRequestDeferral = "MediaStreamSourceSwitchStreamsRequestDeferral";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSwitchStreamsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequestDeferral },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSwitchStreamsRequestDeferral =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequestedEventArgs class --------------------
    constexpr const char* const _type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs = "MediaStreamSourceSwitchStreamsRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs
    };

    // ----- MseSourceBuffer class --------------------
    constexpr const char* const _type_name_MseSourceBuffer = "MseSourceBuffer";

    static PyObject* _new_MseSourceBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MseSourceBuffer);
        return nullptr;
    }

    static void _dealloc_MseSourceBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MseSourceBuffer_Abort(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Abort();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.AppendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendStream(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.AppendStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AppendStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_Remove(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimestampOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimestampOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MseAppendMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppendWindowStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AppendWindowStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppendWindowEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.AppendWindowEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Buffered(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_IsUpdating(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUpdating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Aborted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Aborted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBuffer[] = {
        { "abort", reinterpret_cast<PyCFunction>(MseSourceBuffer_Abort), METH_VARARGS, nullptr },
        { "append_buffer", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendBuffer), METH_VARARGS, nullptr },
        { "append_stream", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendStream), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MseSourceBuffer_Remove), METH_VARARGS, nullptr },
        { "add_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Aborted), METH_O, nullptr },
        { "remove_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Aborted), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_ErrorOccurred), METH_O, nullptr },
        { "add_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateEnded), METH_O, nullptr },
        { "remove_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateEnded), METH_O, nullptr },
        { "add_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateStarting), METH_O, nullptr },
        { "remove_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateStarting), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Updated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBuffer[] = {
        { "timestamp_offset", reinterpret_cast<getter>(MseSourceBuffer_get_TimestampOffset), reinterpret_cast<setter>(MseSourceBuffer_put_TimestampOffset), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MseSourceBuffer_get_Mode), reinterpret_cast<setter>(MseSourceBuffer_put_Mode), nullptr, nullptr },
        { "append_window_start", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowStart), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowStart), nullptr, nullptr },
        { "append_window_end", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowEnd), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowEnd), nullptr, nullptr },
        { "buffered", reinterpret_cast<getter>(MseSourceBuffer_get_Buffered), nullptr, nullptr, nullptr },
        { "is_updating", reinterpret_cast<getter>(MseSourceBuffer_get_IsUpdating), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBuffer[] = 
    {
        { Py_tp_new, _new_MseSourceBuffer },
        { Py_tp_dealloc, _dealloc_MseSourceBuffer },
        { Py_tp_methods, _methods_MseSourceBuffer },
        { Py_tp_getset, _getset_MseSourceBuffer },
        { },
    };

    static PyType_Spec _type_spec_MseSourceBuffer =
    {
        "_winsdk_Windows_Media_Core.MseSourceBuffer",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBuffer
    };

    // ----- MseSourceBufferList class --------------------
    constexpr const char* const _type_name_MseSourceBufferList = "MseSourceBufferList";

    static PyObject* _new_MseSourceBufferList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MseSourceBufferList);
        return nullptr;
    }

    static void _dealloc_MseSourceBufferList(py::wrapper::Windows::Media::Core::MseSourceBufferList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MseSourceBufferList_get_Buffers(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBufferList[] = {
        { "add_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferAdded), METH_O, nullptr },
        { "remove_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferAdded), METH_O, nullptr },
        { "add_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferRemoved), METH_O, nullptr },
        { "remove_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferRemoved), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBufferList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBufferList[] = {
        { "buffers", reinterpret_cast<getter>(MseSourceBufferList_get_Buffers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBufferList[] = 
    {
        { Py_tp_new, _new_MseSourceBufferList },
        { Py_tp_dealloc, _dealloc_MseSourceBufferList },
        { Py_tp_methods, _methods_MseSourceBufferList },
        { Py_tp_getset, _getset_MseSourceBufferList },
        { },
    };

    static PyType_Spec _type_spec_MseSourceBufferList =
    {
        "_winsdk_Windows_Media_Core.MseSourceBufferList",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBufferList
    };

    // ----- MseStreamSource class --------------------
    constexpr const char* const _type_name_MseStreamSource = "MseStreamSource";

    static PyObject* _new_MseStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MseStreamSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MseStreamSource(py::wrapper::Windows::Media::Core::MseStreamSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MseStreamSource_AddSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddSourceBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_EndOfStream(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseEndOfStreamStatus>(args, 0);

                self->obj.EndOfStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MseStreamSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_RemoveSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseSourceBuffer>(args, 0);

                self->obj.RemoveSourceBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_get_ActiveSourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveSourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_ReadyState(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadyState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_SourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LiveSeekableRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Core::MseTimeRange>>(arg);

            self->obj.LiveSeekableRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseStreamSource[] = {
        { "add_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_AddSourceBuffer), METH_VARARGS, nullptr },
        { "end_of_stream", reinterpret_cast<PyCFunction>(MseStreamSource_EndOfStream), METH_VARARGS, nullptr },
        { "is_content_type_supported", reinterpret_cast<PyCFunction>(MseStreamSource_IsContentTypeSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_RemoveSourceBuffer), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MseStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Closed), METH_O, nullptr },
        { "add_ended", reinterpret_cast<PyCFunction>(MseStreamSource_add_Ended), METH_O, nullptr },
        { "remove_ended", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Ended), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(MseStreamSource_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Opened), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseStreamSource[] = {
        { "duration", reinterpret_cast<getter>(MseStreamSource_get_Duration), reinterpret_cast<setter>(MseStreamSource_put_Duration), nullptr, nullptr },
        { "active_source_buffers", reinterpret_cast<getter>(MseStreamSource_get_ActiveSourceBuffers), nullptr, nullptr, nullptr },
        { "ready_state", reinterpret_cast<getter>(MseStreamSource_get_ReadyState), nullptr, nullptr, nullptr },
        { "source_buffers", reinterpret_cast<getter>(MseStreamSource_get_SourceBuffers), nullptr, nullptr, nullptr },
        { "live_seekable_range", reinterpret_cast<getter>(MseStreamSource_get_LiveSeekableRange), reinterpret_cast<setter>(MseStreamSource_put_LiveSeekableRange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseStreamSource[] = 
    {
        { Py_tp_new, _new_MseStreamSource },
        { Py_tp_dealloc, _dealloc_MseStreamSource },
        { Py_tp_methods, _methods_MseStreamSource },
        { Py_tp_getset, _getset_MseStreamSource },
        { },
    };

    static PyType_Spec _type_spec_MseStreamSource =
    {
        "_winsdk_Windows_Media_Core.MseStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MseStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseStreamSource
    };

    // ----- SceneAnalysisEffect class --------------------
    constexpr const char* const _type_name_SceneAnalysisEffect = "SceneAnalysisEffect";

    static PyObject* _new_SceneAnalysisEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneAnalysisEffect);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffect(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalysisEffect_SetProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_get_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredAnalysisInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffect_put_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredAnalysisInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffect_get_HighDynamicRangeAnalyzer(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighDynamicRangeAnalyzer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_add_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::SceneAnalysisEffect, winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>(arg);

            return py::convert(self->obj.SceneAnalyzed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_remove_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SceneAnalyzed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_add_SceneAnalyzed), METH_O, nullptr },
        { "remove_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_remove_SceneAnalyzed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffect[] = {
        { "desired_analysis_interval", reinterpret_cast<getter>(SceneAnalysisEffect_get_DesiredAnalysisInterval), reinterpret_cast<setter>(SceneAnalysisEffect_put_DesiredAnalysisInterval), nullptr, nullptr },
        { "high_dynamic_range_analyzer", reinterpret_cast<getter>(SceneAnalysisEffect_get_HighDynamicRangeAnalyzer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffect[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffect },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffect },
        { Py_tp_methods, _methods_SceneAnalysisEffect },
        { Py_tp_getset, _getset_SceneAnalysisEffect },
        { },
    };

    static PyType_Spec _type_spec_SceneAnalysisEffect =
    {
        "_winsdk_Windows_Media_Core.SceneAnalysisEffect",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffect
    };

    // ----- SceneAnalysisEffectDefinition class --------------------
    constexpr const char* const _type_name_SceneAnalysisEffectDefinition = "SceneAnalysisEffectDefinition";

    static PyObject* _new_SceneAnalysisEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SceneAnalysisEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SceneAnalysisEffectDefinition(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalysisEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectDefinition[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffectDefinition },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffectDefinition },
        { Py_tp_methods, _methods_SceneAnalysisEffectDefinition },
        { Py_tp_getset, _getset_SceneAnalysisEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_SceneAnalysisEffectDefinition =
    {
        "_winsdk_Windows_Media_Core.SceneAnalysisEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectDefinition
    };

    // ----- SceneAnalysisEffectFrame class --------------------
    constexpr const char* const _type_name_SceneAnalysisEffectFrame = "SceneAnalysisEffectFrame";

    static PyObject* _new_SceneAnalysisEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneAnalysisEffectFrame);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalysisEffectFrame_Close(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_FrameControlValues(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_HighDynamicRange(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighDynamicRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_AnalysisRecommendation(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnalysisRecommendation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Type(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(SceneAnalysisEffectFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SceneAnalysisEffectFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SceneAnalysisEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectFrame[] = {
        { "frame_control_values", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_FrameControlValues), nullptr, nullptr, nullptr },
        { "high_dynamic_range", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_HighDynamicRange), nullptr, nullptr, nullptr },
        { "analysis_recommendation", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_AnalysisRecommendation), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_RelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Duration), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectFrame[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffectFrame },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffectFrame },
        { Py_tp_methods, _methods_SceneAnalysisEffectFrame },
        { Py_tp_getset, _getset_SceneAnalysisEffectFrame },
        { },
    };

    static PyType_Spec _type_spec_SceneAnalysisEffectFrame =
    {
        "_winsdk_Windows_Media_Core.SceneAnalysisEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectFrame
    };

    // ----- SceneAnalyzedEventArgs class --------------------
    constexpr const char* const _type_name_SceneAnalyzedEventArgs = "SceneAnalyzedEventArgs";

    static PyObject* _new_SceneAnalyzedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneAnalyzedEventArgs);
        return nullptr;
    }

    static void _dealloc_SceneAnalyzedEventArgs(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneAnalyzedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalyzedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalyzedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalyzedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(SceneAnalyzedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalyzedEventArgs[] = 
    {
        { Py_tp_new, _new_SceneAnalyzedEventArgs },
        { Py_tp_dealloc, _dealloc_SceneAnalyzedEventArgs },
        { Py_tp_methods, _methods_SceneAnalyzedEventArgs },
        { Py_tp_getset, _getset_SceneAnalyzedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_SceneAnalyzedEventArgs =
    {
        "_winsdk_Windows_Media_Core.SceneAnalyzedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalyzedEventArgs
    };

    // ----- SpeechCue class --------------------
    constexpr const char* const _type_name_SpeechCue = "SpeechCue";

    static PyObject* _new_SpeechCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SpeechCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechCue(py::wrapper::Windows::Media::Core::SpeechCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechCue_get_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.StartPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.EndPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SpeechCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechCue[] = {
        { "start_time", reinterpret_cast<getter>(SpeechCue_get_StartTime), reinterpret_cast<setter>(SpeechCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SpeechCue_get_Id), reinterpret_cast<setter>(SpeechCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SpeechCue_get_Duration), reinterpret_cast<setter>(SpeechCue_put_Duration), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechCue_get_Text), reinterpret_cast<setter>(SpeechCue_put_Text), nullptr, nullptr },
        { "start_position_in_input", reinterpret_cast<getter>(SpeechCue_get_StartPositionInInput), reinterpret_cast<setter>(SpeechCue_put_StartPositionInInput), nullptr, nullptr },
        { "end_position_in_input", reinterpret_cast<getter>(SpeechCue_get_EndPositionInInput), reinterpret_cast<setter>(SpeechCue_put_EndPositionInInput), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechCue[] = 
    {
        { Py_tp_new, _new_SpeechCue },
        { Py_tp_dealloc, _dealloc_SpeechCue },
        { Py_tp_methods, _methods_SpeechCue },
        { Py_tp_getset, _getset_SpeechCue },
        { },
    };

    static PyType_Spec _type_spec_SpeechCue =
    {
        "_winsdk_Windows_Media_Core.SpeechCue",
        sizeof(py::wrapper::Windows::Media::Core::SpeechCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechCue
    };

    // ----- TimedMetadataStreamDescriptor class --------------------
    constexpr const char* const _type_name_TimedMetadataStreamDescriptor = "TimedMetadataStreamDescriptor";

    static PyObject* _new_TimedMetadataStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::TimedMetadataStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataStreamDescriptor(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Name), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Language), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Label), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataStreamDescriptor[] = 
    {
        { Py_tp_new, _new_TimedMetadataStreamDescriptor },
        { Py_tp_dealloc, _dealloc_TimedMetadataStreamDescriptor },
        { Py_tp_methods, _methods_TimedMetadataStreamDescriptor },
        { Py_tp_getset, _getset_TimedMetadataStreamDescriptor },
        { },
    };

    static PyType_Spec _type_spec_TimedMetadataStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataStreamDescriptor
    };

    // ----- TimedMetadataTrack class --------------------
    constexpr const char* const _type_name_TimedMetadataTrack = "TimedMetadataTrack";

    static PyObject* _new_TimedMetadataTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataKind>(args, 2);

                winrt::Windows::Media::Core::TimedMetadataTrack instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataTrack(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataTrack_AddCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.AddCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_RemoveCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.RemoveCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataTrack_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataTrack_get_Id(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TrackKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_ActiveCues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveCues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Cues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_DispatchType(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DispatchType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TimedMetadataKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>(arg);

            return py::convert(self->obj.TrackFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TrackFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrack[] = {
        { "add_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_AddCue), METH_VARARGS, nullptr },
        { "remove_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_RemoveCue), METH_VARARGS, nullptr },
        { "add_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueEntered), METH_O, nullptr },
        { "remove_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueEntered), METH_O, nullptr },
        { "add_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueExited), METH_O, nullptr },
        { "remove_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueExited), METH_O, nullptr },
        { "add_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_TrackFailed), METH_O, nullptr },
        { "remove_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_TrackFailed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrack[] = {
        { "label", reinterpret_cast<getter>(TimedMetadataTrack_get_Label), reinterpret_cast<setter>(TimedMetadataTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedMetadataTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "active_cues", reinterpret_cast<getter>(TimedMetadataTrack_get_ActiveCues), nullptr, nullptr, nullptr },
        { "cues", reinterpret_cast<getter>(TimedMetadataTrack_get_Cues), nullptr, nullptr, nullptr },
        { "dispatch_type", reinterpret_cast<getter>(TimedMetadataTrack_get_DispatchType), nullptr, nullptr, nullptr },
        { "timed_metadata_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TimedMetadataKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedMetadataTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(TimedMetadataTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrack[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrack },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrack },
        { Py_tp_methods, _methods_TimedMetadataTrack },
        { Py_tp_getset, _getset_TimedMetadataTrack },
        { },
    };

    static PyType_Spec _type_spec_TimedMetadataTrack =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataTrack",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrack
    };

    // ----- TimedMetadataTrackError class --------------------
    constexpr const char* const _type_name_TimedMetadataTrackError = "TimedMetadataTrackError";

    static PyObject* _new_TimedMetadataTrackError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedMetadataTrackError);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataTrackError_get_ErrorCode(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrackError_get_ExtendedError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackError[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackError[] = {
        { "error_code", reinterpret_cast<getter>(TimedMetadataTrackError_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(TimedMetadataTrackError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackError[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrackError },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrackError },
        { Py_tp_methods, _methods_TimedMetadataTrackError },
        { Py_tp_getset, _getset_TimedMetadataTrackError },
        { },
    };

    static PyType_Spec _type_spec_TimedMetadataTrackError =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataTrackError",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackError
    };

    // ----- TimedMetadataTrackFailedEventArgs class --------------------
    constexpr const char* const _type_name_TimedMetadataTrackFailedEventArgs = "TimedMetadataTrackFailedEventArgs";

    static PyObject* _new_TimedMetadataTrackFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedMetadataTrackFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackFailedEventArgs(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedMetadataTrackFailedEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackFailedEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedMetadataTrackFailedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackFailedEventArgs[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrackFailedEventArgs },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrackFailedEventArgs },
        { Py_tp_methods, _methods_TimedMetadataTrackFailedEventArgs },
        { Py_tp_getset, _getset_TimedMetadataTrackFailedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_TimedMetadataTrackFailedEventArgs =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataTrackFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackFailedEventArgs
    };

    // ----- TimedTextBouten class --------------------
    constexpr const char* const _type_name_TimedTextBouten = "TimedTextBouten";

    static PyObject* _new_TimedTextBouten(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextBouten);
        return nullptr;
    }

    static void _dealloc_TimedTextBouten(py::wrapper::Windows::Media::Core::TimedTextBouten* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextBouten_get_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextBouten>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextBouten[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextBouten), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextBouten[] = {
        { "type", reinterpret_cast<getter>(TimedTextBouten_get_Type), reinterpret_cast<setter>(TimedTextBouten_put_Type), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextBouten_get_Position), reinterpret_cast<setter>(TimedTextBouten_put_Position), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(TimedTextBouten_get_Color), reinterpret_cast<setter>(TimedTextBouten_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextBouten[] = 
    {
        { Py_tp_new, _new_TimedTextBouten },
        { Py_tp_dealloc, _dealloc_TimedTextBouten },
        { Py_tp_methods, _methods_TimedTextBouten },
        { Py_tp_getset, _getset_TimedTextBouten },
        { },
    };

    static PyType_Spec _type_spec_TimedTextBouten =
    {
        "_winsdk_Windows_Media_Core.TimedTextBouten",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextBouten),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextBouten
    };

    // ----- TimedTextCue class --------------------
    constexpr const char* const _type_name_TimedTextCue = "TimedTextCue";

    static PyObject* _new_TimedTextCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextCue(py::wrapper::Windows::Media::Core::TimedTextCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextCue_get_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CueStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.CueStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CueRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRegion>(arg);

            self->obj.CueRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Lines(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Lines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextCue[] = {
        { "start_time", reinterpret_cast<getter>(TimedTextCue_get_StartTime), reinterpret_cast<setter>(TimedTextCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedTextCue_get_Id), reinterpret_cast<setter>(TimedTextCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(TimedTextCue_get_Duration), reinterpret_cast<setter>(TimedTextCue_put_Duration), nullptr, nullptr },
        { "cue_style", reinterpret_cast<getter>(TimedTextCue_get_CueStyle), reinterpret_cast<setter>(TimedTextCue_put_CueStyle), nullptr, nullptr },
        { "cue_region", reinterpret_cast<getter>(TimedTextCue_get_CueRegion), reinterpret_cast<setter>(TimedTextCue_put_CueRegion), nullptr, nullptr },
        { "lines", reinterpret_cast<getter>(TimedTextCue_get_Lines), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextCue[] = 
    {
        { Py_tp_new, _new_TimedTextCue },
        { Py_tp_dealloc, _dealloc_TimedTextCue },
        { Py_tp_methods, _methods_TimedTextCue },
        { Py_tp_getset, _getset_TimedTextCue },
        { },
    };

    static PyType_Spec _type_spec_TimedTextCue =
    {
        "_winsdk_Windows_Media_Core.TimedTextCue",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextCue
    };

    // ----- TimedTextLine class --------------------
    constexpr const char* const _type_name_TimedTextLine = "TimedTextLine";

    static PyObject* _new_TimedTextLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextLine instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextLine(py::wrapper::Windows::Media::Core::TimedTextLine* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextLine_get_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextLine_put_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextLine_get_Subformats(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subformats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextLine[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextLine[] = {
        { "text", reinterpret_cast<getter>(TimedTextLine_get_Text), reinterpret_cast<setter>(TimedTextLine_put_Text), nullptr, nullptr },
        { "subformats", reinterpret_cast<getter>(TimedTextLine_get_Subformats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextLine[] = 
    {
        { Py_tp_new, _new_TimedTextLine },
        { Py_tp_dealloc, _dealloc_TimedTextLine },
        { Py_tp_methods, _methods_TimedTextLine },
        { Py_tp_getset, _getset_TimedTextLine },
        { },
    };

    static PyType_Spec _type_spec_TimedTextLine =
    {
        "_winsdk_Windows_Media_Core.TimedTextLine",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextLine
    };

    // ----- TimedTextRegion class --------------------
    constexpr const char* const _type_name_TimedTextRegion = "TimedTextRegion";

    static PyObject* _new_TimedTextRegion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextRegion instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextRegion(py::wrapper::Windows::Media::Core::TimedTextRegion* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextRegion_get_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverflowClipped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverflowClipped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDisplayAlignment>(arg);

            self->obj.DisplayAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Padding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);

            self->obj.Padding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WritingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWritingMode>(arg);

            self->obj.WritingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextWrapping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWrapping>(arg);

            self->obj.TextWrapping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextScrollMode>(arg);

            self->obj.ScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRegion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRegion[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRegion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRegion[] = {
        { "name", reinterpret_cast<getter>(TimedTextRegion_get_Name), reinterpret_cast<setter>(TimedTextRegion_put_Name), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(TimedTextRegion_get_LineHeight), reinterpret_cast<setter>(TimedTextRegion_put_LineHeight), nullptr, nullptr },
        { "is_overflow_clipped", reinterpret_cast<getter>(TimedTextRegion_get_IsOverflowClipped), reinterpret_cast<setter>(TimedTextRegion_put_IsOverflowClipped), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(TimedTextRegion_get_Extent), reinterpret_cast<setter>(TimedTextRegion_put_Extent), nullptr, nullptr },
        { "display_alignment", reinterpret_cast<getter>(TimedTextRegion_get_DisplayAlignment), reinterpret_cast<setter>(TimedTextRegion_put_DisplayAlignment), nullptr, nullptr },
        { "padding", reinterpret_cast<getter>(TimedTextRegion_get_Padding), reinterpret_cast<setter>(TimedTextRegion_put_Padding), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextRegion_get_Background), reinterpret_cast<setter>(TimedTextRegion_put_Background), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(TimedTextRegion_get_ZIndex), reinterpret_cast<setter>(TimedTextRegion_put_ZIndex), nullptr, nullptr },
        { "writing_mode", reinterpret_cast<getter>(TimedTextRegion_get_WritingMode), reinterpret_cast<setter>(TimedTextRegion_put_WritingMode), nullptr, nullptr },
        { "text_wrapping", reinterpret_cast<getter>(TimedTextRegion_get_TextWrapping), reinterpret_cast<setter>(TimedTextRegion_put_TextWrapping), nullptr, nullptr },
        { "scroll_mode", reinterpret_cast<getter>(TimedTextRegion_get_ScrollMode), reinterpret_cast<setter>(TimedTextRegion_put_ScrollMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRegion_get_Position), reinterpret_cast<setter>(TimedTextRegion_put_Position), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRegion[] = 
    {
        { Py_tp_new, _new_TimedTextRegion },
        { Py_tp_dealloc, _dealloc_TimedTextRegion },
        { Py_tp_methods, _methods_TimedTextRegion },
        { Py_tp_getset, _getset_TimedTextRegion },
        { },
    };

    static PyType_Spec _type_spec_TimedTextRegion =
    {
        "_winsdk_Windows_Media_Core.TimedTextRegion",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRegion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRegion
    };

    // ----- TimedTextRuby class --------------------
    constexpr const char* const _type_name_TimedTextRuby = "TimedTextRuby";

    static PyObject* _new_TimedTextRuby(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextRuby);
        return nullptr;
    }

    static void _dealloc_TimedTextRuby(py::wrapper::Windows::Media::Core::TimedTextRuby* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextRuby_get_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyReserve>(arg);

            self->obj.Reserve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyAlign>(arg);

            self->obj.Align(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRuby>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRuby[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRuby), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRuby[] = {
        { "text", reinterpret_cast<getter>(TimedTextRuby_get_Text), reinterpret_cast<setter>(TimedTextRuby_put_Text), nullptr, nullptr },
        { "reserve", reinterpret_cast<getter>(TimedTextRuby_get_Reserve), reinterpret_cast<setter>(TimedTextRuby_put_Reserve), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRuby_get_Position), reinterpret_cast<setter>(TimedTextRuby_put_Position), nullptr, nullptr },
        { "align", reinterpret_cast<getter>(TimedTextRuby_get_Align), reinterpret_cast<setter>(TimedTextRuby_put_Align), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRuby[] = 
    {
        { Py_tp_new, _new_TimedTextRuby },
        { Py_tp_dealloc, _dealloc_TimedTextRuby },
        { Py_tp_methods, _methods_TimedTextRuby },
        { Py_tp_getset, _getset_TimedTextRuby },
        { },
    };

    static PyType_Spec _type_spec_TimedTextRuby =
    {
        "_winsdk_Windows_Media_Core.TimedTextRuby",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRuby),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRuby
    };

    // ----- TimedTextSource class --------------------
    constexpr const char* const _type_name_TimedTextSource = "TimedTextSource";

    static PyObject* _new_TimedTextSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextSource);
        return nullptr;
    }

    static void _dealloc_TimedTextSource(py::wrapper::Windows::Media::Core::TimedTextSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_add_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedTextSource, winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>(arg);

            return py::convert(self->obj.Resolved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_remove_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Resolved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSource[] = {
        { "create_from_stream", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStreamWithIndex), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUri), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUriWithIndex), METH_VARARGS | METH_STATIC, nullptr },
        { "add_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_add_Resolved), METH_O, nullptr },
        { "remove_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_remove_Resolved), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSource[] = {
        { }
    };

    static PyType_Slot _type_slots_TimedTextSource[] = 
    {
        { Py_tp_new, _new_TimedTextSource },
        { Py_tp_dealloc, _dealloc_TimedTextSource },
        { Py_tp_methods, _methods_TimedTextSource },
        { Py_tp_getset, _getset_TimedTextSource },
        { },
    };

    static PyType_Spec _type_spec_TimedTextSource =
    {
        "_winsdk_Windows_Media_Core.TimedTextSource",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSource
    };

    // ----- TimedTextSourceResolveResultEventArgs class --------------------
    constexpr const char* const _type_name_TimedTextSourceResolveResultEventArgs = "TimedTextSourceResolveResultEventArgs";

    static PyObject* _new_TimedTextSourceResolveResultEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TimedTextSourceResolveResultEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedTextSourceResolveResultEventArgs(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Tracks(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSourceResolveResultEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSourceResolveResultEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSourceResolveResultEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "tracks", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Tracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSourceResolveResultEventArgs[] = 
    {
        { Py_tp_new, _new_TimedTextSourceResolveResultEventArgs },
        { Py_tp_dealloc, _dealloc_TimedTextSourceResolveResultEventArgs },
        { Py_tp_methods, _methods_TimedTextSourceResolveResultEventArgs },
        { Py_tp_getset, _getset_TimedTextSourceResolveResultEventArgs },
        { },
    };

    static PyType_Spec _type_spec_TimedTextSourceResolveResultEventArgs =
    {
        "_winsdk_Windows_Media_Core.TimedTextSourceResolveResultEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSourceResolveResultEventArgs
    };

    // ----- TimedTextStyle class --------------------
    constexpr const char* const _type_name_TimedTextStyle = "TimedTextStyle";

    static PyObject* _new_TimedTextStyle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextStyle instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextStyle_get_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextLineAlignment>(arg);

            self->obj.LineAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackgroundAlwaysShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBackgroundAlwaysShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsUnderlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLineThroughEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLineThroughEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTextCombined());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextCombined(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FontAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Bouten(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bouten());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextStyle_get_Ruby(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ruby());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextStyle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextStyle[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextStyle), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextStyle[] = {
        { "line_alignment", reinterpret_cast<getter>(TimedTextStyle_get_LineAlignment), reinterpret_cast<setter>(TimedTextStyle_put_LineAlignment), nullptr, nullptr },
        { "is_background_always_shown", reinterpret_cast<getter>(TimedTextStyle_get_IsBackgroundAlwaysShown), reinterpret_cast<setter>(TimedTextStyle_put_IsBackgroundAlwaysShown), nullptr, nullptr },
        { "outline_color", reinterpret_cast<getter>(TimedTextStyle_get_OutlineColor), reinterpret_cast<setter>(TimedTextStyle_put_OutlineColor), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(TimedTextStyle_get_Foreground), reinterpret_cast<setter>(TimedTextStyle_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(TimedTextStyle_get_FontWeight), reinterpret_cast<setter>(TimedTextStyle_put_FontWeight), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextStyle_get_Background), reinterpret_cast<setter>(TimedTextStyle_put_Background), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(TimedTextStyle_get_FontSize), reinterpret_cast<setter>(TimedTextStyle_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(TimedTextStyle_get_FontFamily), reinterpret_cast<setter>(TimedTextStyle_put_FontFamily), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(TimedTextStyle_get_FlowDirection), reinterpret_cast<setter>(TimedTextStyle_put_FlowDirection), nullptr, nullptr },
        { "outline_thickness", reinterpret_cast<getter>(TimedTextStyle_get_OutlineThickness), reinterpret_cast<setter>(TimedTextStyle_put_OutlineThickness), nullptr, nullptr },
        { "outline_radius", reinterpret_cast<getter>(TimedTextStyle_get_OutlineRadius), reinterpret_cast<setter>(TimedTextStyle_put_OutlineRadius), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedTextStyle_get_Name), reinterpret_cast<setter>(TimedTextStyle_put_Name), nullptr, nullptr },
        { "is_underline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsUnderlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsUnderlineEnabled), nullptr, nullptr },
        { "is_overline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsOverlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsOverlineEnabled), nullptr, nullptr },
        { "is_line_through_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsLineThroughEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsLineThroughEnabled), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(TimedTextStyle_get_FontStyle), reinterpret_cast<setter>(TimedTextStyle_put_FontStyle), nullptr, nullptr },
        { "is_text_combined", reinterpret_cast<getter>(TimedTextStyle_get_IsTextCombined), reinterpret_cast<setter>(TimedTextStyle_put_IsTextCombined), nullptr, nullptr },
        { "font_angle_in_degrees", reinterpret_cast<getter>(TimedTextStyle_get_FontAngleInDegrees), reinterpret_cast<setter>(TimedTextStyle_put_FontAngleInDegrees), nullptr, nullptr },
        { "bouten", reinterpret_cast<getter>(TimedTextStyle_get_Bouten), nullptr, nullptr, nullptr },
        { "ruby", reinterpret_cast<getter>(TimedTextStyle_get_Ruby), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextStyle[] = 
    {
        { Py_tp_new, _new_TimedTextStyle },
        { Py_tp_dealloc, _dealloc_TimedTextStyle },
        { Py_tp_methods, _methods_TimedTextStyle },
        { Py_tp_getset, _getset_TimedTextStyle },
        { },
    };

    static PyType_Spec _type_spec_TimedTextStyle =
    {
        "_winsdk_Windows_Media_Core.TimedTextStyle",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextStyle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextStyle
    };

    // ----- TimedTextSubformat class --------------------
    constexpr const char* const _type_name_TimedTextSubformat = "TimedTextSubformat";

    static PyObject* _new_TimedTextSubformat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSubformat instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSubformat(py::wrapper::Windows::Media::Core::TimedTextSubformat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TimedTextSubformat_get_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubformatStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.SubformatStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSubformat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSubformat[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSubformat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSubformat[] = {
        { "subformat_style", reinterpret_cast<getter>(TimedTextSubformat_get_SubformatStyle), reinterpret_cast<setter>(TimedTextSubformat_put_SubformatStyle), nullptr, nullptr },
        { "start_index", reinterpret_cast<getter>(TimedTextSubformat_get_StartIndex), reinterpret_cast<setter>(TimedTextSubformat_put_StartIndex), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(TimedTextSubformat_get_Length), reinterpret_cast<setter>(TimedTextSubformat_put_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSubformat[] = 
    {
        { Py_tp_new, _new_TimedTextSubformat },
        { Py_tp_dealloc, _dealloc_TimedTextSubformat },
        { Py_tp_methods, _methods_TimedTextSubformat },
        { Py_tp_getset, _getset_TimedTextSubformat },
        { },
    };

    static PyType_Spec _type_spec_TimedTextSubformat =
    {
        "_winsdk_Windows_Media_Core.TimedTextSubformat",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSubformat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSubformat
    };

    // ----- VideoStabilizationEffect class --------------------
    constexpr const char* const _type_name_VideoStabilizationEffect = "VideoStabilizationEffect";

    static PyObject* _new_VideoStabilizationEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoStabilizationEffect);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffect(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStabilizationEffect_GetRecommendedStreamConfiguration(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoDeviceController>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 1);

                return py::convert(self->obj.GetRecommendedStreamConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_SetProperties(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_get_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStabilizationEffect_put_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStabilizationEffect_add_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoStabilizationEffect, winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.EnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_remove_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffect[] = {
        { "get_recommended_stream_configuration", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_GetRecommendedStreamConfiguration), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_add_EnabledChanged), METH_O, nullptr },
        { "remove_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_remove_EnabledChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffect[] = {
        { "enabled", reinterpret_cast<getter>(VideoStabilizationEffect_get_Enabled), reinterpret_cast<setter>(VideoStabilizationEffect_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffect[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffect },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffect },
        { Py_tp_methods, _methods_VideoStabilizationEffect },
        { Py_tp_getset, _getset_VideoStabilizationEffect },
        { },
    };

    static PyType_Spec _type_spec_VideoStabilizationEffect =
    {
        "_winsdk_Windows_Media_Core.VideoStabilizationEffect",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffect
    };

    // ----- VideoStabilizationEffectDefinition class --------------------
    constexpr const char* const _type_name_VideoStabilizationEffectDefinition = "VideoStabilizationEffectDefinition";

    static PyObject* _new_VideoStabilizationEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::VideoStabilizationEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStabilizationEffectDefinition(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStabilizationEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectDefinition[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffectDefinition },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffectDefinition },
        { Py_tp_methods, _methods_VideoStabilizationEffectDefinition },
        { Py_tp_getset, _getset_VideoStabilizationEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_VideoStabilizationEffectDefinition =
    {
        "_winsdk_Windows_Media_Core.VideoStabilizationEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectDefinition
    };

    // ----- VideoStabilizationEffectEnabledChangedEventArgs class --------------------
    constexpr const char* const _type_name_VideoStabilizationEffectEnabledChangedEventArgs = "VideoStabilizationEffectEnabledChangedEventArgs";

    static PyObject* _new_VideoStabilizationEffectEnabledChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoStabilizationEffectEnabledChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffectEnabledChangedEventArgs(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStabilizationEffectEnabledChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectEnabledChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(VideoStabilizationEffectEnabledChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectEnabledChangedEventArgs[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_methods, _methods_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_getset, _getset_VideoStabilizationEffectEnabledChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_VideoStabilizationEffectEnabledChangedEventArgs =
    {
        "_winsdk_Windows_Media_Core.VideoStabilizationEffectEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectEnabledChangedEventArgs
    };

    // ----- VideoStreamDescriptor class --------------------
    constexpr const char* const _type_name_VideoStreamDescriptor = "VideoStreamDescriptor";

    static PyObject* _new_VideoStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::VideoStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStreamDescriptor(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(VideoStreamDescriptor_get_Name), reinterpret_cast<setter>(VideoStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoStreamDescriptor_get_Language), reinterpret_cast<setter>(VideoStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(VideoStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VideoStreamDescriptor_get_Label), reinterpret_cast<setter>(VideoStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(VideoStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamDescriptor[] = 
    {
        { Py_tp_new, _new_VideoStreamDescriptor },
        { Py_tp_dealloc, _dealloc_VideoStreamDescriptor },
        { Py_tp_methods, _methods_VideoStreamDescriptor },
        { Py_tp_getset, _getset_VideoStreamDescriptor },
        { },
    };

    static PyType_Spec _type_spec_VideoStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.VideoStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::VideoStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamDescriptor
    };

    // ----- VideoTrack class --------------------
    constexpr const char* const _type_name_VideoTrack = "VideoTrack";

    static PyObject* _new_VideoTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTrack);
        return nullptr;
    }

    static void _dealloc_VideoTrack(py::wrapper::Windows::Media::Core::VideoTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTrack_put_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTrack_get_Id(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Language(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_TrackKind(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Name(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoTrack, winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(VideoTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_remove_OpenFailed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrack[] = {
        { "label", reinterpret_cast<getter>(VideoTrack_get_Label), reinterpret_cast<setter>(VideoTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VideoTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(VideoTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VideoTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(VideoTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(VideoTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrack[] = 
    {
        { Py_tp_new, _new_VideoTrack },
        { Py_tp_dealloc, _dealloc_VideoTrack },
        { Py_tp_methods, _methods_VideoTrack },
        { Py_tp_getset, _getset_VideoTrack },
        { },
    };

    static PyType_Spec _type_spec_VideoTrack =
    {
        "_winsdk_Windows_Media_Core.VideoTrack",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrack
    };

    // ----- VideoTrackOpenFailedEventArgs class --------------------
    constexpr const char* const _type_name_VideoTrackOpenFailedEventArgs = "VideoTrackOpenFailedEventArgs";

    static PyObject* _new_VideoTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackOpenFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(VideoTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, _new_VideoTrackOpenFailedEventArgs },
        { Py_tp_dealloc, _dealloc_VideoTrackOpenFailedEventArgs },
        { Py_tp_methods, _methods_VideoTrackOpenFailedEventArgs },
        { Py_tp_getset, _getset_VideoTrackOpenFailedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_VideoTrackOpenFailedEventArgs =
    {
        "_winsdk_Windows_Media_Core.VideoTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackOpenFailedEventArgs
    };

    // ----- VideoTrackSupportInfo class --------------------
    constexpr const char* const _type_name_VideoTrackSupportInfo = "VideoTrackSupportInfo";

    static PyObject* _new_VideoTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_VideoTrackSupportInfo(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackSupportInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackSupportInfo[] = 
    {
        { Py_tp_new, _new_VideoTrackSupportInfo },
        { Py_tp_dealloc, _dealloc_VideoTrackSupportInfo },
        { Py_tp_methods, _methods_VideoTrackSupportInfo },
        { Py_tp_getset, _getset_VideoTrackSupportInfo },
        { },
    };

    static PyType_Spec _type_spec_VideoTrackSupportInfo =
    {
        "_winsdk_Windows_Media_Core.VideoTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackSupportInfo
    };

    // ----- IMediaCue interface --------------------
    constexpr const char* const _type_name_IMediaCue = "IMediaCue";

    static PyObject* _new_IMediaCue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaCue);
        return nullptr;
    }

    static void _dealloc_IMediaCue(py::wrapper::Windows::Media::Core::IMediaCue* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaCue_get_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaCue[] = {
        { "duration", reinterpret_cast<getter>(IMediaCue_get_Duration), reinterpret_cast<setter>(IMediaCue_put_Duration), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IMediaCue_get_Id), reinterpret_cast<setter>(IMediaCue_put_Id), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(IMediaCue_get_StartTime), reinterpret_cast<setter>(IMediaCue_put_StartTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaCue[] = 
    {
        { Py_tp_new, _new_IMediaCue },
        { Py_tp_dealloc, _dealloc_IMediaCue },
        { Py_tp_methods, _methods_IMediaCue },
        { Py_tp_getset, _getset_IMediaCue },
        { },
    };

    static PyType_Spec _type_spec_IMediaCue =
    {
        "_winsdk_Windows_Media_Core.IMediaCue",
        sizeof(py::wrapper::Windows::Media::Core::IMediaCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaCue
    };

    // ----- IMediaSource interface --------------------
    constexpr const char* const _type_name_IMediaSource = "IMediaSource";

    static PyObject* _new_IMediaSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaSource);
        return nullptr;
    }

    static void _dealloc_IMediaSource(py::wrapper::Windows::Media::Core::IMediaSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaSource[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaSource[] = 
    {
        { Py_tp_new, _new_IMediaSource },
        { Py_tp_dealloc, _dealloc_IMediaSource },
        { Py_tp_methods, _methods_IMediaSource },
        { Py_tp_getset, _getset_IMediaSource },
        { },
    };

    static PyType_Spec _type_spec_IMediaSource =
    {
        "_winsdk_Windows_Media_Core.IMediaSource",
        sizeof(py::wrapper::Windows::Media::Core::IMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaSource
    };

    // ----- IMediaStreamDescriptor interface --------------------
    constexpr const char* const _type_name_IMediaStreamDescriptor = "IMediaStreamDescriptor";

    static PyObject* _new_IMediaStreamDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaStreamDescriptor);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor[] = {
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor[] = 
    {
        { Py_tp_new, _new_IMediaStreamDescriptor },
        { Py_tp_dealloc, _dealloc_IMediaStreamDescriptor },
        { Py_tp_methods, _methods_IMediaStreamDescriptor },
        { Py_tp_getset, _getset_IMediaStreamDescriptor },
        { },
    };

    static PyType_Spec _type_spec_IMediaStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.IMediaStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor
    };

    // ----- IMediaStreamDescriptor2 interface --------------------
    constexpr const char* const _type_name_IMediaStreamDescriptor2 = "IMediaStreamDescriptor2";

    static PyObject* _new_IMediaStreamDescriptor2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaStreamDescriptor2);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor2(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaStreamDescriptor2_get_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor2[] = {
        { "label", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Label), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor2[] = 
    {
        { Py_tp_new, _new_IMediaStreamDescriptor2 },
        { Py_tp_dealloc, _dealloc_IMediaStreamDescriptor2 },
        { Py_tp_methods, _methods_IMediaStreamDescriptor2 },
        { Py_tp_getset, _getset_IMediaStreamDescriptor2 },
        { },
    };

    static PyType_Spec _type_spec_IMediaStreamDescriptor2 =
    {
        "_winsdk_Windows_Media_Core.IMediaStreamDescriptor2",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor2
    };

    // ----- IMediaTrack interface --------------------
    constexpr const char* const _type_name_IMediaTrack = "IMediaTrack";

    static PyObject* _new_IMediaTrack(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaTrack);
        return nullptr;
    }

    static void _dealloc_IMediaTrack(py::wrapper::Windows::Media::Core::IMediaTrack* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaTrack_get_Id(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaTrack_put_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaTrack_get_Language(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_TrackKind(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaTrack[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaTrack[] = {
        { "id", reinterpret_cast<getter>(IMediaTrack_get_Id), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IMediaTrack_get_Label), reinterpret_cast<setter>(IMediaTrack_put_Label), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(IMediaTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaTrack[] = 
    {
        { Py_tp_new, _new_IMediaTrack },
        { Py_tp_dealloc, _dealloc_IMediaTrack },
        { Py_tp_methods, _methods_IMediaTrack },
        { Py_tp_getset, _getset_IMediaTrack },
        { },
    };

    static PyType_Spec _type_spec_IMediaTrack =
    {
        "_winsdk_Windows_Media_Core.IMediaTrack",
        sizeof(py::wrapper::Windows::Media::Core::IMediaTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaTrack
    };

    // ----- ISingleSelectMediaTrackList interface --------------------
    constexpr const char* const _type_name_ISingleSelectMediaTrackList = "ISingleSelectMediaTrackList";

    static PyObject* _new_ISingleSelectMediaTrackList(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISingleSelectMediaTrackList);
        return nullptr;
    }

    static void _dealloc_ISingleSelectMediaTrackList(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISingleSelectMediaTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISingleSelectMediaTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISingleSelectMediaTrackList[] = {
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISingleSelectMediaTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISingleSelectMediaTrackList[] = {
        { "selected_index", reinterpret_cast<getter>(ISingleSelectMediaTrackList_get_SelectedIndex), reinterpret_cast<setter>(ISingleSelectMediaTrackList_put_SelectedIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISingleSelectMediaTrackList[] = 
    {
        { Py_tp_new, _new_ISingleSelectMediaTrackList },
        { Py_tp_dealloc, _dealloc_ISingleSelectMediaTrackList },
        { Py_tp_methods, _methods_ISingleSelectMediaTrackList },
        { Py_tp_getset, _getset_ISingleSelectMediaTrackList },
        { },
    };

    static PyType_Spec _type_spec_ISingleSelectMediaTrackList =
    {
        "_winsdk_Windows_Media_Core.ISingleSelectMediaTrackList",
        sizeof(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISingleSelectMediaTrackList
    };

    // ----- ITimedMetadataTrackProvider interface --------------------
    constexpr const char* const _type_name_ITimedMetadataTrackProvider = "ITimedMetadataTrackProvider";

    static PyObject* _new_ITimedMetadataTrackProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ITimedMetadataTrackProvider);
        return nullptr;
    }

    static void _dealloc_ITimedMetadataTrackProvider(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ITimedMetadataTrackProvider_get_TimedMetadataTracks(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITimedMetadataTrackProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ITimedMetadataTrackProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITimedMetadataTrackProvider[] = {
        { "timed_metadata_tracks", reinterpret_cast<getter>(ITimedMetadataTrackProvider_get_TimedMetadataTracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITimedMetadataTrackProvider[] = 
    {
        { Py_tp_new, _new_ITimedMetadataTrackProvider },
        { Py_tp_dealloc, _dealloc_ITimedMetadataTrackProvider },
        { Py_tp_methods, _methods_ITimedMetadataTrackProvider },
        { Py_tp_getset, _getset_ITimedMetadataTrackProvider },
        { },
    };

    static PyType_Spec _type_spec_ITimedMetadataTrackProvider =
    {
        "_winsdk_Windows_Media_Core.ITimedMetadataTrackProvider",
        sizeof(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITimedMetadataTrackProvider
    };

    // ----- MseTimeRange struct --------------------
    constexpr const char* const _type_name_MseTimeRange = "MseTimeRange";

    PyObject* _new_MseTimeRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::MseTimeRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::MseTimeRange>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::MseTimeRange return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MseTimeRange(py::wrapper::Windows::Media::Core::MseTimeRange* self)
    {
    }

    static PyObject* MseTimeRange_get_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseTimeRange_get_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MseTimeRange[] = {
        { "start", reinterpret_cast<getter>(MseTimeRange_get_Start), reinterpret_cast<setter>(MseTimeRange_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(MseTimeRange_get_End), reinterpret_cast<setter>(MseTimeRange_set_End), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseTimeRange[] = 
    {
        { Py_tp_new, _new_MseTimeRange },
        { Py_tp_dealloc, _dealloc_MseTimeRange },
        { Py_tp_getset, _getset_MseTimeRange },
        { },
    };

    static PyType_Spec _type_spec_MseTimeRange =
    {
        "_winsdk_Windows_Media_Core.MseTimeRange",
        sizeof(py::wrapper::Windows::Media::Core::MseTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseTimeRange
    };

    // ----- TimedTextDouble struct --------------------
    constexpr const char* const _type_name_TimedTextDouble = "TimedTextDouble";

    PyObject* _new_TimedTextDouble(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextDouble return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Value{};
        int32_t _Unit{};

        static const char* kwlist[] = {"value", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "di", const_cast<char**>(kwlist), &_Value, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextDouble return_value{ _Value, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextDouble(py::wrapper::Windows::Media::Core::TimedTextDouble* self)
    {
    }

    static PyObject* TimedTextDouble_get_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextDouble_get_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextDouble[] = {
        { "value", reinterpret_cast<getter>(TimedTextDouble_get_Value), reinterpret_cast<setter>(TimedTextDouble_set_Value), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextDouble_get_Unit), reinterpret_cast<setter>(TimedTextDouble_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextDouble[] = 
    {
        { Py_tp_new, _new_TimedTextDouble },
        { Py_tp_dealloc, _dealloc_TimedTextDouble },
        { Py_tp_getset, _getset_TimedTextDouble },
        { },
    };

    static PyType_Spec _type_spec_TimedTextDouble =
    {
        "_winsdk_Windows_Media_Core.TimedTextDouble",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextDouble
    };

    // ----- TimedTextPadding struct --------------------
    constexpr const char* const _type_name_TimedTextPadding = "TimedTextPadding";

    PyObject* _new_TimedTextPadding(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPadding return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Before{};
        double _After{};
        double _Start{};
        double _End{};
        int32_t _Unit{};

        static const char* kwlist[] = {"before", "after", "start", "end", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddddi", const_cast<char**>(kwlist), &_Before, &_After, &_Start, &_End, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPadding return_value{ _Before, _After, _Start, _End, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPadding(py::wrapper::Windows::Media::Core::TimedTextPadding* self)
    {
    }

    static PyObject* TimedTextPadding_get_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Before);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Before = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.After);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.After = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPadding[] = {
        { "before", reinterpret_cast<getter>(TimedTextPadding_get_Before), reinterpret_cast<setter>(TimedTextPadding_set_Before), nullptr, nullptr },
        { "after", reinterpret_cast<getter>(TimedTextPadding_get_After), reinterpret_cast<setter>(TimedTextPadding_set_After), nullptr, nullptr },
        { "start", reinterpret_cast<getter>(TimedTextPadding_get_Start), reinterpret_cast<setter>(TimedTextPadding_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(TimedTextPadding_get_End), reinterpret_cast<setter>(TimedTextPadding_set_End), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPadding_get_Unit), reinterpret_cast<setter>(TimedTextPadding_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextPadding[] = 
    {
        { Py_tp_new, _new_TimedTextPadding },
        { Py_tp_dealloc, _dealloc_TimedTextPadding },
        { Py_tp_getset, _getset_TimedTextPadding },
        { },
    };

    static PyType_Spec _type_spec_TimedTextPadding =
    {
        "_winsdk_Windows_Media_Core.TimedTextPadding",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPadding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPadding
    };

    // ----- TimedTextPoint struct --------------------
    constexpr const char* const _type_name_TimedTextPoint = "TimedTextPoint";

    PyObject* _new_TimedTextPoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPoint return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _X{};
        double _Y{};
        int32_t _Unit{};

        static const char* kwlist[] = {"x", "y", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_X, &_Y, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPoint return_value{ _X, _Y, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPoint(py::wrapper::Windows::Media::Core::TimedTextPoint* self)
    {
    }

    static PyObject* TimedTextPoint_get_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPoint[] = {
        { "x", reinterpret_cast<getter>(TimedTextPoint_get_X), reinterpret_cast<setter>(TimedTextPoint_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(TimedTextPoint_get_Y), reinterpret_cast<setter>(TimedTextPoint_set_Y), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPoint_get_Unit), reinterpret_cast<setter>(TimedTextPoint_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextPoint[] = 
    {
        { Py_tp_new, _new_TimedTextPoint },
        { Py_tp_dealloc, _dealloc_TimedTextPoint },
        { Py_tp_getset, _getset_TimedTextPoint },
        { },
    };

    static PyType_Spec _type_spec_TimedTextPoint =
    {
        "_winsdk_Windows_Media_Core.TimedTextPoint",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPoint
    };

    // ----- TimedTextSize struct --------------------
    constexpr const char* const _type_name_TimedTextSize = "TimedTextSize";

    PyObject* _new_TimedTextSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Height{};
        double _Width{};
        int32_t _Unit{};

        static const char* kwlist[] = {"height", "width", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_Height, &_Width, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextSize return_value{ _Height, _Width, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSize(py::wrapper::Windows::Media::Core::TimedTextSize* self)
    {
    }

    static PyObject* TimedTextSize_get_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextSize[] = {
        { "height", reinterpret_cast<getter>(TimedTextSize_get_Height), reinterpret_cast<setter>(TimedTextSize_set_Height), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(TimedTextSize_get_Width), reinterpret_cast<setter>(TimedTextSize_set_Width), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextSize_get_Unit), reinterpret_cast<setter>(TimedTextSize_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSize[] = 
    {
        { Py_tp_new, _new_TimedTextSize },
        { Py_tp_dealloc, _dealloc_TimedTextSize },
        { Py_tp_getset, _getset_TimedTextSize },
        { },
    };

    static PyType_Spec _type_spec_TimedTextSize =
    {
        "_winsdk_Windows_Media_Core.TimedTextSize",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSize
    };

    // ----- Windows.Media.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::Core::AudioStreamDescriptor>::python_type = py::register_python_type(module, _type_name_AudioStreamDescriptor, &_type_spec_AudioStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::AudioTrack>::python_type = py::register_python_type(module, _type_name_AudioTrack, &_type_spec_AudioTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::python_type = py::register_python_type(module, _type_name_AudioTrackOpenFailedEventArgs, &_type_spec_AudioTrackOpenFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::python_type = py::register_python_type(module, _type_name_AudioTrackSupportInfo, &_type_spec_AudioTrackSupportInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ChapterCue>::python_type = py::register_python_type(module, _type_name_ChapterCue, &_type_spec_ChapterCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::CodecInfo>::python_type = py::register_python_type(module, _type_name_CodecInfo, &_type_spec_CodecInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::CodecQuery>::python_type = py::register_python_type(module, _type_name_CodecQuery, &_type_spec_CodecQuery, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::CodecSubtypes>::python_type = py::register_python_type(module, _type_name_CodecSubtypes, &_type_spec_CodecSubtypes, nullptr);
            py::winrt_type<winrt::Windows::Media::Core::DataCue>::python_type = py::register_python_type(module, _type_name_DataCue, &_type_spec_DataCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::python_type = py::register_python_type(module, _type_name_FaceDetectedEventArgs, &_type_spec_FaceDetectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffect>::python_type = py::register_python_type(module, _type_name_FaceDetectionEffect, &_type_spec_FaceDetectionEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>::python_type = py::register_python_type(module, _type_name_FaceDetectionEffectDefinition, &_type_spec_FaceDetectionEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::python_type = py::register_python_type(module, _type_name_FaceDetectionEffectFrame, &_type_spec_FaceDetectionEffectFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::python_type = py::register_python_type(module, _type_name_HighDynamicRangeControl, &_type_spec_HighDynamicRangeControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::python_type = py::register_python_type(module, _type_name_HighDynamicRangeOutput, &_type_spec_HighDynamicRangeOutput, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ImageCue>::python_type = py::register_python_type(module, _type_name_ImageCue, &_type_spec_ImageCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_InitializeMediaStreamSourceRequestedEventArgs, &_type_spec_InitializeMediaStreamSourceRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::LowLightFusion>::python_type = py::register_python_type(module, _type_name_LowLightFusion, &_type_spec_LowLightFusion, nullptr);
            py::winrt_type<winrt::Windows::Media::Core::LowLightFusionResult>::python_type = py::register_python_type(module, _type_name_LowLightFusionResult, &_type_spec_LowLightFusionResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaBinder>::python_type = py::register_python_type(module, _type_name_MediaBinder, &_type_spec_MediaBinder, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::python_type = py::register_python_type(module, _type_name_MediaBindingEventArgs, &_type_spec_MediaBindingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaCueEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCueEventArgs, &_type_spec_MediaCueEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSource>::python_type = py::register_python_type(module, _type_name_MediaSource, &_type_spec_MediaSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>::python_type = py::register_python_type(module, _type_name_MediaSourceAppServiceConnection, &_type_spec_MediaSourceAppServiceConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceError>::python_type = py::register_python_type(module, _type_name_MediaSourceError, &_type_spec_MediaSourceError, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaSourceOpenOperationCompletedEventArgs, &_type_spec_MediaSourceOpenOperationCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaSourceStateChangedEventArgs, &_type_spec_MediaSourceStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSample>::python_type = py::register_python_type(module, _type_name_MediaStreamSample, &_type_spec_MediaStreamSample, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::python_type = py::register_python_type(module, _type_name_MediaStreamSamplePropertySet, &_type_spec_MediaStreamSamplePropertySet, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::python_type = py::register_python_type(module, _type_name_MediaStreamSampleProtectionProperties, &_type_spec_MediaStreamSampleProtectionProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSource>::python_type = py::register_python_type(module, _type_name_MediaStreamSource, &_type_spec_MediaStreamSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceClosedEventArgs, &_type_spec_MediaStreamSourceClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceClosedRequest, &_type_spec_MediaStreamSourceClosedRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRenderedEventArgs, &_type_spec_MediaStreamSourceSampleRenderedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRequest, &_type_spec_MediaStreamSourceSampleRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRequestDeferral, &_type_spec_MediaStreamSourceSampleRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSampleRequestedEventArgs, &_type_spec_MediaStreamSourceSampleRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceStartingEventArgs, &_type_spec_MediaStreamSourceStartingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceStartingRequest, &_type_spec_MediaStreamSourceStartingRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceStartingRequestDeferral, &_type_spec_MediaStreamSourceStartingRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSwitchStreamsRequest, &_type_spec_MediaStreamSourceSwitchStreamsRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSwitchStreamsRequestDeferral, &_type_spec_MediaStreamSourceSwitchStreamsRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs, &_type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseSourceBuffer>::python_type = py::register_python_type(module, _type_name_MseSourceBuffer, &_type_spec_MseSourceBuffer, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseSourceBufferList>::python_type = py::register_python_type(module, _type_name_MseSourceBufferList, &_type_spec_MseSourceBufferList, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseStreamSource>::python_type = py::register_python_type(module, _type_name_MseStreamSource, &_type_spec_MseStreamSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::python_type = py::register_python_type(module, _type_name_SceneAnalysisEffect, &_type_spec_SceneAnalysisEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>::python_type = py::register_python_type(module, _type_name_SceneAnalysisEffectDefinition, &_type_spec_SceneAnalysisEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::python_type = py::register_python_type(module, _type_name_SceneAnalysisEffectFrame, &_type_spec_SceneAnalysisEffectFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::python_type = py::register_python_type(module, _type_name_SceneAnalyzedEventArgs, &_type_spec_SceneAnalyzedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::SpeechCue>::python_type = py::register_python_type(module, _type_name_SpeechCue, &_type_spec_SpeechCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>::python_type = py::register_python_type(module, _type_name_TimedMetadataStreamDescriptor, &_type_spec_TimedMetadataStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrack>::python_type = py::register_python_type(module, _type_name_TimedMetadataTrack, &_type_spec_TimedMetadataTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::python_type = py::register_python_type(module, _type_name_TimedMetadataTrackError, &_type_spec_TimedMetadataTrackError, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::python_type = py::register_python_type(module, _type_name_TimedMetadataTrackFailedEventArgs, &_type_spec_TimedMetadataTrackFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextBouten>::python_type = py::register_python_type(module, _type_name_TimedTextBouten, &_type_spec_TimedTextBouten, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextCue>::python_type = py::register_python_type(module, _type_name_TimedTextCue, &_type_spec_TimedTextCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextLine>::python_type = py::register_python_type(module, _type_name_TimedTextLine, &_type_spec_TimedTextLine, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextRegion>::python_type = py::register_python_type(module, _type_name_TimedTextRegion, &_type_spec_TimedTextRegion, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextRuby>::python_type = py::register_python_type(module, _type_name_TimedTextRuby, &_type_spec_TimedTextRuby, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSource>::python_type = py::register_python_type(module, _type_name_TimedTextSource, &_type_spec_TimedTextSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::python_type = py::register_python_type(module, _type_name_TimedTextSourceResolveResultEventArgs, &_type_spec_TimedTextSourceResolveResultEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextStyle>::python_type = py::register_python_type(module, _type_name_TimedTextStyle, &_type_spec_TimedTextStyle, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSubformat>::python_type = py::register_python_type(module, _type_name_TimedTextSubformat, &_type_spec_TimedTextSubformat, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::python_type = py::register_python_type(module, _type_name_VideoStabilizationEffect, &_type_spec_VideoStabilizationEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>::python_type = py::register_python_type(module, _type_name_VideoStabilizationEffectDefinition, &_type_spec_VideoStabilizationEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::python_type = py::register_python_type(module, _type_name_VideoStabilizationEffectEnabledChangedEventArgs, &_type_spec_VideoStabilizationEffectEnabledChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoStreamDescriptor>::python_type = py::register_python_type(module, _type_name_VideoStreamDescriptor, &_type_spec_VideoStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoTrack>::python_type = py::register_python_type(module, _type_name_VideoTrack, &_type_spec_VideoTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::python_type = py::register_python_type(module, _type_name_VideoTrackOpenFailedEventArgs, &_type_spec_VideoTrackOpenFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::python_type = py::register_python_type(module, _type_name_VideoTrackSupportInfo, &_type_spec_VideoTrackSupportInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaCue>::python_type = py::register_python_type(module, _type_name_IMediaCue, &_type_spec_IMediaCue, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaSource>::python_type = py::register_python_type(module, _type_name_IMediaSource, &_type_spec_IMediaSource, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::python_type = py::register_python_type(module, _type_name_IMediaStreamDescriptor, &_type_spec_IMediaStreamDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::python_type = py::register_python_type(module, _type_name_IMediaStreamDescriptor2, &_type_spec_IMediaStreamDescriptor2, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::IMediaTrack>::python_type = py::register_python_type(module, _type_name_IMediaTrack, &_type_spec_IMediaTrack, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::python_type = py::register_python_type(module, _type_name_ISingleSelectMediaTrackList, &_type_spec_ISingleSelectMediaTrackList, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::python_type = py::register_python_type(module, _type_name_ITimedMetadataTrackProvider, &_type_spec_ITimedMetadataTrackProvider, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::MseTimeRange>::python_type = py::register_python_type(module, _type_name_MseTimeRange, &_type_spec_MseTimeRange, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextDouble>::python_type = py::register_python_type(module, _type_name_TimedTextDouble, &_type_spec_TimedTextDouble, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextPadding>::python_type = py::register_python_type(module, _type_name_TimedTextPadding, &_type_spec_TimedTextPadding, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextPoint>::python_type = py::register_python_type(module, _type_name_TimedTextPoint, &_type_spec_TimedTextPoint, bases.get());
            py::winrt_type<winrt::Windows::Media::Core::TimedTextSize>::python_type = py::register_python_type(module, _type_name_TimedTextSize, &_type_spec_TimedTextSize, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.Core");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Core",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::Core

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Core::module_def);
}
