// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

#include "pybase.h"
#include "py.Windows.Devices.PointOfService.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplay>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::PointOfService::SizeUInt32>::python_type;

PyObject* py::converter<winrt::Windows::Devices::PointOfService::SizeUInt32>::convert(winrt::Windows::Devices::PointOfService::SizeUInt32 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::PointOfService::SizeUInt32>());
}
winrt::Windows::Devices::PointOfService::SizeUInt32 py::converter<winrt::Windows::Devices::PointOfService::SizeUInt32>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::PointOfService::SizeUInt32>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::PointOfService::SizeUInt32>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{};

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<uint32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<uint32_t>::convert_to(py_Height);

    return return_value;
}

namespace py::cpp::Windows::Devices::PointOfService
{
    // ----- BarcodeScanner class --------------------
    constexpr const char* const _type_name_BarcodeScanner = "BarcodeScanner";

    static PyObject* _new_BarcodeScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScanner);
        return nullptr;
    }

    static void _dealloc_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScanner_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_ClaimScannerAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimScannerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedProfiles(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSymbologiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsProfileSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsSymbologySupportedAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsSymbologySupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_VideoDeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::BarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScanner[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(BarcodeScanner_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_scanner_async", reinterpret_cast<PyCFunction>(BarcodeScanner_ClaimScannerAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(BarcodeScanner_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(BarcodeScanner_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(BarcodeScanner_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BarcodeScanner_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_profiles", reinterpret_cast<PyCFunction>(BarcodeScanner_GetSupportedProfiles), METH_VARARGS, nullptr },
        { "get_supported_symbologies_async", reinterpret_cast<PyCFunction>(BarcodeScanner_GetSupportedSymbologiesAsync), METH_VARARGS, nullptr },
        { "is_profile_supported", reinterpret_cast<PyCFunction>(BarcodeScanner_IsProfileSupported), METH_VARARGS, nullptr },
        { "is_symbology_supported_async", reinterpret_cast<PyCFunction>(BarcodeScanner_IsSymbologySupportedAsync), METH_VARARGS, nullptr },
        { "retrieve_statistics_async", reinterpret_cast<PyCFunction>(BarcodeScanner_RetrieveStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(BarcodeScanner_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(BarcodeScanner_remove_StatusUpdated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScanner), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BarcodeScanner), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BarcodeScanner), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScanner[] = {
        { "capabilities", reinterpret_cast<getter>(BarcodeScanner_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BarcodeScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(BarcodeScanner_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScanner[] = 
    {
        { Py_tp_new, _new_BarcodeScanner },
        { Py_tp_dealloc, _dealloc_BarcodeScanner },
        { Py_tp_methods, _methods_BarcodeScanner },
        { Py_tp_getset, _getset_BarcodeScanner },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScanner =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScanner
    };

    // ----- BarcodeScannerCapabilities class --------------------
    constexpr const char* const _type_name_BarcodeScannerCapabilities = "BarcodeScannerCapabilities";

    static PyObject* _new_BarcodeScannerCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerCapabilities);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerCapabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerCapabilities_get_IsImagePreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsImagePreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSoftwareTriggerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsVideoPreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoPreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerCapabilities[] = {
        { "is_image_preview_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsImagePreviewSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "is_software_trigger_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported), nullptr, nullptr, nullptr },
        { "is_video_preview_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsVideoPreviewSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerCapabilities[] = 
    {
        { Py_tp_new, _new_BarcodeScannerCapabilities },
        { Py_tp_dealloc, _dealloc_BarcodeScannerCapabilities },
        { Py_tp_methods, _methods_BarcodeScannerCapabilities },
        { Py_tp_getset, _getset_BarcodeScannerCapabilities },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScannerCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerCapabilities
    };

    // ----- BarcodeScannerDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerDataReceivedEventArgs = "BarcodeScannerDataReceivedEventArgs";

    static PyObject* _new_BarcodeScannerDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerDataReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerDataReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(BarcodeScannerDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerDataReceivedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerDataReceivedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerDataReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScannerDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerDataReceivedEventArgs
    };

    // ----- BarcodeScannerErrorOccurredEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerErrorOccurredEventArgs = "BarcodeScannerErrorOccurredEventArgs";

    static PyObject* _new_BarcodeScannerErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_IsRetriable(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRetriable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerErrorOccurredEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerErrorOccurredEventArgs[] = {
        { "error_data", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_ErrorData), nullptr, nullptr, nullptr },
        { "is_retriable", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_IsRetriable), nullptr, nullptr, nullptr },
        { "partial_input_data", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_PartialInputData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerErrorOccurredEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerErrorOccurredEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerErrorOccurredEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerErrorOccurredEventArgs },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScannerErrorOccurredEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerErrorOccurredEventArgs
    };

    // ----- BarcodeScannerImagePreviewReceivedEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerImagePreviewReceivedEventArgs = "BarcodeScannerImagePreviewReceivedEventArgs";

    static PyObject* _new_BarcodeScannerImagePreviewReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerImagePreviewReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerImagePreviewReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerImagePreviewReceivedEventArgs_get_Preview(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerImagePreviewReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerImagePreviewReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "preview", reinterpret_cast<getter>(BarcodeScannerImagePreviewReceivedEventArgs_get_Preview), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerImagePreviewReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerImagePreviewReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerImagePreviewReceivedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerImagePreviewReceivedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerImagePreviewReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScannerImagePreviewReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerImagePreviewReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerImagePreviewReceivedEventArgs
    };

    // ----- BarcodeScannerReport class --------------------
    constexpr const char* const _type_name_BarcodeScannerReport = "BarcodeScannerReport";

    static PyObject* _new_BarcodeScannerReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                winrt::Windows::Devices::PointOfService::BarcodeScannerReport instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BarcodeScannerReport(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerReport_get_ScanData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataLabel(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanDataLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanDataType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerReport[] = {
        { "scan_data", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanData), nullptr, nullptr, nullptr },
        { "scan_data_label", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanDataLabel), nullptr, nullptr, nullptr },
        { "scan_data_type", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanDataType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerReport[] = 
    {
        { Py_tp_new, _new_BarcodeScannerReport },
        { Py_tp_dealloc, _dealloc_BarcodeScannerReport },
        { Py_tp_methods, _methods_BarcodeScannerReport },
        { Py_tp_getset, _getset_BarcodeScannerReport },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScannerReport =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerReport
    };

    // ----- BarcodeScannerStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_BarcodeScannerStatusUpdatedEventArgs = "BarcodeScannerStatusUpdatedEventArgs";

    static PyObject* _new_BarcodeScannerStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeScannerStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "extended_status", reinterpret_cast<getter>(BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BarcodeScannerStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerStatusUpdatedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_BarcodeScannerStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeScannerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerStatusUpdatedEventArgs
    };

    // ----- BarcodeSymbologies class --------------------
    constexpr const char* const _type_name_BarcodeSymbologies = "BarcodeSymbologies";

    static PyObject* _new_BarcodeSymbologies(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeSymbologies);
        return nullptr;
    }

    static PyObject* BarcodeSymbologies_GetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::GetName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code11(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_AusPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::AusPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Aztec(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Aztec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccab(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ChinaPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ChinaPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codabar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codabar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codablock128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codablock128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DutchKix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DutchKix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code16k(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code16k());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code49(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code49());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataMatrix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPostNet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPostNet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Eanv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Eanv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128Coupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128Coupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_HanXin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::HanXin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_InfoMail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::InfoMail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsbnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsbnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ismn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ismn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Issn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Issn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_JapanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::JapanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_KoreanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::KoreanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Maxicode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Maxicode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Micr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Micr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroPdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroPdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroQr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroQr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MsTag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MsTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Msi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Msi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Plessey(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Plessey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pzn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pzn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Qr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Qr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Sisac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Sisac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_SwedenPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::SwedenPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Telepen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Telepen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfDis(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfDis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfIata(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfIata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfMat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfMat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfStd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfStd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Tlc39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Tlc39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Trioptic39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Trioptic39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UccEan128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UccEan128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UkPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UkPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcCoupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcCoupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upca(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upca());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upce(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Us4StateFics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Us4StateFics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligentPkg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligentPkg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPlanet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPlanet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DWCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DWCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologies[] = {
        { "get_name", reinterpret_cast<PyCFunction>(BarcodeSymbologies_GetName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_code11", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code11), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aus_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_AusPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aztec", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Aztec), METH_NOARGS | METH_STATIC, nullptr },
        { "get_can_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_CanPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ccab", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ccab), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ccc", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ccc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_china_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_ChinaPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_codabar", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Codabar), METH_NOARGS | METH_STATIC, nullptr },
        { "get_codablock128", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Codablock128), METH_NOARGS | METH_STATIC, nullptr },
        { "get_codablock_a", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_CodablockA), METH_NOARGS | METH_STATIC, nullptr },
        { "get_codablock_f", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_CodablockF), METH_NOARGS | METH_STATIC, nullptr },
        { "get_dutch_kix", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_DutchKix), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code128", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code128), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code16k", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code16k), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code32", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code32), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code39", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code39), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code39_ex", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code39Ex), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code49", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code49), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code93", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code93), METH_NOARGS | METH_STATIC, nullptr },
        { "get_code93_ex", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Code93Ex), METH_NOARGS | METH_STATIC, nullptr },
        { "get_data_code", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_DataCode), METH_NOARGS | METH_STATIC, nullptr },
        { "get_data_matrix", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_DataMatrix), METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_post_net", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UsPostNet), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean13", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean13), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean13_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean13Add2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean13_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean13Add5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean8", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean8), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean8_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean8Add2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean8_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean8Add5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean99", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean99), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean99_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean99Add2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ean99_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ean99Add5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_eanv", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Eanv), METH_NOARGS | METH_STATIC, nullptr },
        { "get_eanv_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_EanvAdd2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_eanv_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_EanvAdd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_extended_base", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_ExtendedBase), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1128", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Gs1128), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1128_coupon", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Gs1128Coupon), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_databar_type1", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Gs1DatabarType1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_databar_type2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Gs1DatabarType2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_databar_type3", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Gs1DatabarType3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_han_xin", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_HanXin), METH_NOARGS | METH_STATIC, nullptr },
        { "get_info_mail", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_InfoMail), METH_NOARGS | METH_STATIC, nullptr },
        { "get_isbn", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Isbn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_isbn_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_IsbnAdd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_isbt", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Isbt), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ismn", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Ismn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ismn_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_IsmnAdd2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ismn_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_IsmnAdd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_issn", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Issn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_issn_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_IssnAdd2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_issn_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_IssnAdd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_italian_post25", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_ItalianPost25), METH_NOARGS | METH_STATIC, nullptr },
        { "get_italian_post39", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_ItalianPost39), METH_NOARGS | METH_STATIC, nullptr },
        { "get_japan_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_JapanPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_korean_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_KoreanPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_maxicode", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Maxicode), METH_NOARGS | METH_STATIC, nullptr },
        { "get_micr", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Micr), METH_NOARGS | METH_STATIC, nullptr },
        { "get_micro_pdf417", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_MicroPdf417), METH_NOARGS | METH_STATIC, nullptr },
        { "get_micro_qr", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_MicroQr), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ms_tag", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_MsTag), METH_NOARGS | METH_STATIC, nullptr },
        { "get_msi", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Msi), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ocr_a", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_OcrA), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ocr_b", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_OcrB), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pdf417", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Pdf417), METH_NOARGS | METH_STATIC, nullptr },
        { "get_plessey", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Plessey), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pzn", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Pzn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_qr", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Qr), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sisac", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Sisac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sweden_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_SwedenPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_telepen", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Telepen), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_dis", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_TfDis), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_iata", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_TfIata), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_ind", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_TfInd), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_int", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_TfInt), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_mat", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_TfMat), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tf_std", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_TfStd), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tlc39", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Tlc39), METH_NOARGS | METH_STATIC, nullptr },
        { "get_trioptic39", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Trioptic39), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ucc_ean128", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UccEan128), METH_NOARGS | METH_STATIC, nullptr },
        { "get_uk_post", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UkPost), METH_NOARGS | METH_STATIC, nullptr },
        { "get_unknown", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Unknown), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upc_coupon", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UpcCoupon), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upca", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Upca), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upca_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UpcaAdd2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upca_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UpcaAdd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upce", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Upce), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upce_add2", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UpceAdd2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_upce_add5", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UpceAdd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_us4_state_fics", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Us4StateFics), METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_intelligent", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UsIntelligent), METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_intelligent_pkg", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UsIntelligentPkg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_us_planet", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_UsPlanet), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gs1_d_w_code", reinterpret_cast<PyCFunction>(BarcodeSymbologies_get_Gs1DWCode), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeSymbologies[] = {
        { }
    };

    static PyType_Slot _type_slots_BarcodeSymbologies[] = 
    {
        { Py_tp_new, _new_BarcodeSymbologies },
        { Py_tp_methods, _methods_BarcodeSymbologies },
        { Py_tp_getset, _getset_BarcodeSymbologies },
        { },
    };

    static PyType_Spec _type_spec_BarcodeSymbologies =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeSymbologies",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologies
    };

    // ----- BarcodeSymbologyAttributes class --------------------
    constexpr const char* const _type_name_BarcodeSymbologyAttributes = "BarcodeSymbologyAttributes";

    static PyObject* _new_BarcodeSymbologyAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_BarcodeSymbologyAttributes);
        return nullptr;
    }

    static void _dealloc_BarcodeSymbologyAttributes(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitTransmissionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitTransmissionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeLengthKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyDecodeLengthKind>(arg);

            self->obj.DecodeLengthKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeLength2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeLength1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitTransmissionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCheckDigitValidationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsDecodeLengthSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDecodeLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeSymbologyAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologyAttributes[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeSymbologyAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeSymbologyAttributes[] = {
        { "is_check_digit_validation_enabled", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled), nullptr, nullptr },
        { "is_check_digit_transmission_enabled", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled), nullptr, nullptr },
        { "decode_length_kind", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLengthKind), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLengthKind), nullptr, nullptr },
        { "decode_length2", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLength2), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLength2), nullptr, nullptr },
        { "decode_length1", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLength1), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLength1), nullptr, nullptr },
        { "is_check_digit_transmission_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported), nullptr, nullptr, nullptr },
        { "is_check_digit_validation_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported), nullptr, nullptr, nullptr },
        { "is_decode_length_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsDecodeLengthSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeSymbologyAttributes[] = 
    {
        { Py_tp_new, _new_BarcodeSymbologyAttributes },
        { Py_tp_dealloc, _dealloc_BarcodeSymbologyAttributes },
        { Py_tp_methods, _methods_BarcodeSymbologyAttributes },
        { Py_tp_getset, _getset_BarcodeSymbologyAttributes },
        { },
    };

    static PyType_Spec _type_spec_BarcodeSymbologyAttributes =
    {
        "_winsdk_Windows_Devices_PointOfService.BarcodeSymbologyAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologyAttributes
    };

    // ----- CashDrawer class --------------------
    constexpr const char* const _type_name_CashDrawer = "CashDrawer";

    static PyObject* _new_CashDrawer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawer);
        return nullptr;
    }

    static void _dealloc_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawer_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_ClaimDrawerAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DrawerEventSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawer, winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawer[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(CashDrawer_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_drawer_async", reinterpret_cast<PyCFunction>(CashDrawer_ClaimDrawerAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CashDrawer_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(CashDrawer_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(CashDrawer_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(CashDrawer_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(CashDrawer_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(CashDrawer_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(CashDrawer_remove_StatusUpdated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CashDrawer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_CashDrawer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawer[] = {
        { "capabilities", reinterpret_cast<getter>(CashDrawer_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(CashDrawer_get_DeviceId), nullptr, nullptr, nullptr },
        { "drawer_event_source", reinterpret_cast<getter>(CashDrawer_get_DrawerEventSource), nullptr, nullptr, nullptr },
        { "is_drawer_open", reinterpret_cast<getter>(CashDrawer_get_IsDrawerOpen), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CashDrawer_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawer[] = 
    {
        { Py_tp_new, _new_CashDrawer },
        { Py_tp_dealloc, _dealloc_CashDrawer },
        { Py_tp_methods, _methods_CashDrawer },
        { Py_tp_getset, _getset_CashDrawer },
        { },
    };

    static PyType_Spec _type_spec_CashDrawer =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawer
    };

    // ----- CashDrawerCapabilities class --------------------
    constexpr const char* const _type_name_CashDrawerCapabilities = "CashDrawerCapabilities";

    static PyObject* _new_CashDrawerCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerCapabilities);
        return nullptr;
    }

    static void _dealloc_CashDrawerCapabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDrawerOpenSensorAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatusMultiDrawerDetectSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatusReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerCapabilities[] = {
        { "is_drawer_open_sensor_available", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_status_multi_drawer_detect_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported), nullptr, nullptr, nullptr },
        { "is_status_reporting_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatusReportingSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(CashDrawerCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerCapabilities[] = 
    {
        { Py_tp_new, _new_CashDrawerCapabilities },
        { Py_tp_dealloc, _dealloc_CashDrawerCapabilities },
        { Py_tp_methods, _methods_CashDrawerCapabilities },
        { Py_tp_getset, _getset_CashDrawerCapabilities },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCapabilities
    };

    // ----- CashDrawerCloseAlarm class --------------------
    constexpr const char* const _type_name_CashDrawerCloseAlarm = "CashDrawerCloseAlarm";

    static PyObject* _new_CashDrawerCloseAlarm(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerCloseAlarm);
        return nullptr;
    }

    static void _dealloc_CashDrawerCloseAlarm(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerCloseAlarm_StartAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BeepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BeepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BeepDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BeepDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlarmTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AlarmTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_add_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AlarmTimeoutExpired(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_remove_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AlarmTimeoutExpired(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerCloseAlarm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCloseAlarm[] = {
        { "start_async", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_StartAsync), METH_VARARGS, nullptr },
        { "add_alarm_timeout_expired", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_add_AlarmTimeoutExpired), METH_O, nullptr },
        { "remove_alarm_timeout_expired", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_remove_AlarmTimeoutExpired), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerCloseAlarm), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerCloseAlarm[] = {
        { "beep_frequency", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepFrequency), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepFrequency), nullptr, nullptr },
        { "beep_duration", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepDuration), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepDuration), nullptr, nullptr },
        { "beep_delay", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepDelay), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepDelay), nullptr, nullptr },
        { "alarm_timeout", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_AlarmTimeout), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_AlarmTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerCloseAlarm[] = 
    {
        { Py_tp_new, _new_CashDrawerCloseAlarm },
        { Py_tp_dealloc, _dealloc_CashDrawerCloseAlarm },
        { Py_tp_methods, _methods_CashDrawerCloseAlarm },
        { Py_tp_getset, _getset_CashDrawerCloseAlarm },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerCloseAlarm =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerCloseAlarm",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCloseAlarm
    };

    // ----- CashDrawerClosedEventArgs class --------------------
    constexpr const char* const _type_name_CashDrawerClosedEventArgs = "CashDrawerClosedEventArgs";

    static PyObject* _new_CashDrawerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerClosedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerClosedEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(CashDrawerClosedEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerClosedEventArgs[] = 
    {
        { Py_tp_new, _new_CashDrawerClosedEventArgs },
        { Py_tp_dealloc, _dealloc_CashDrawerClosedEventArgs },
        { Py_tp_methods, _methods_CashDrawerClosedEventArgs },
        { Py_tp_getset, _getset_CashDrawerClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerClosedEventArgs
    };

    // ----- CashDrawerEventSource class --------------------
    constexpr const char* const _type_name_CashDrawerEventSource = "CashDrawerEventSource";

    static PyObject* _new_CashDrawerEventSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerEventSource);
        return nullptr;
    }

    static void _dealloc_CashDrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerEventSource_add_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.DrawerClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_add_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>>(arg);

            return py::convert(self->obj.DrawerOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerEventSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerEventSource[] = {
        { "add_drawer_closed", reinterpret_cast<PyCFunction>(CashDrawerEventSource_add_DrawerClosed), METH_O, nullptr },
        { "remove_drawer_closed", reinterpret_cast<PyCFunction>(CashDrawerEventSource_remove_DrawerClosed), METH_O, nullptr },
        { "add_drawer_opened", reinterpret_cast<PyCFunction>(CashDrawerEventSource_add_DrawerOpened), METH_O, nullptr },
        { "remove_drawer_opened", reinterpret_cast<PyCFunction>(CashDrawerEventSource_remove_DrawerOpened), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerEventSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerEventSource[] = {
        { }
    };

    static PyType_Slot _type_slots_CashDrawerEventSource[] = 
    {
        { Py_tp_new, _new_CashDrawerEventSource },
        { Py_tp_dealloc, _dealloc_CashDrawerEventSource },
        { Py_tp_methods, _methods_CashDrawerEventSource },
        { Py_tp_getset, _getset_CashDrawerEventSource },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerEventSource =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerEventSource",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerEventSource
    };

    // ----- CashDrawerOpenedEventArgs class --------------------
    constexpr const char* const _type_name_CashDrawerOpenedEventArgs = "CashDrawerOpenedEventArgs";

    static PyObject* _new_CashDrawerOpenedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerOpenedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerOpenedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerOpenedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerOpenedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerOpenedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerOpenedEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(CashDrawerOpenedEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerOpenedEventArgs[] = 
    {
        { Py_tp_new, _new_CashDrawerOpenedEventArgs },
        { Py_tp_dealloc, _dealloc_CashDrawerOpenedEventArgs },
        { Py_tp_methods, _methods_CashDrawerOpenedEventArgs },
        { Py_tp_getset, _getset_CashDrawerOpenedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerOpenedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerOpenedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerOpenedEventArgs
    };

    // ----- CashDrawerStatus class --------------------
    constexpr const char* const _type_name_CashDrawerStatus = "CashDrawerStatus";

    static PyObject* _new_CashDrawerStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerStatus);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatus[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerStatus[] = {
        { "extended_status", reinterpret_cast<getter>(CashDrawerStatus_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status_kind", reinterpret_cast<getter>(CashDrawerStatus_get_StatusKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerStatus[] = 
    {
        { Py_tp_new, _new_CashDrawerStatus },
        { Py_tp_dealloc, _dealloc_CashDrawerStatus },
        { Py_tp_methods, _methods_CashDrawerStatus },
        { Py_tp_getset, _getset_CashDrawerStatus },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerStatus =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatus
    };

    // ----- CashDrawerStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_CashDrawerStatusUpdatedEventArgs = "CashDrawerStatusUpdatedEventArgs";

    static PyObject* _new_CashDrawerStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CashDrawerStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CashDrawerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CashDrawerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatusUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(CashDrawerStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_CashDrawerStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_CashDrawerStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_CashDrawerStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_CashDrawerStatusUpdatedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_CashDrawerStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.CashDrawerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatusUpdatedEventArgs
    };

    // ----- ClaimedBarcodeScanner class --------------------
    constexpr const char* const _type_name_ClaimedBarcodeScanner = "ClaimedBarcodeScanner";

    static PyObject* _new_ClaimedBarcodeScanner(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedBarcodeScanner);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedBarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_GetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetSymbologyAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_HideVideoPreview(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.HideVideoPreview();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveProfileAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetActiveProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.SetActiveSymbologiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>(args, 1);

                return py::convert(self->obj.SetSymbologyAttributesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ShowVideoPreviewAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ShowVideoPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StartSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StopSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoPreviewShownOnEnable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVideoPreviewShownOnEnable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>>(arg);

            return py::convert(self->obj.ImagePreviewReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImagePreviewReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedBarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScanner[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_EnableAsync), METH_VARARGS, nullptr },
        { "get_symbology_attributes_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_GetSymbologyAttributesAsync), METH_VARARGS, nullptr },
        { "hide_video_preview", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_HideVideoPreview), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_RetainDevice), METH_VARARGS, nullptr },
        { "set_active_profile_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetActiveProfileAsync), METH_VARARGS, nullptr },
        { "set_active_symbologies_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetActiveSymbologiesAsync), METH_VARARGS, nullptr },
        { "set_symbology_attributes_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetSymbologyAttributesAsync), METH_VARARGS, nullptr },
        { "show_video_preview_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_ShowVideoPreviewAsync), METH_VARARGS, nullptr },
        { "start_software_trigger_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_StartSoftwareTriggerAsync), METH_VARARGS, nullptr },
        { "stop_software_trigger_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_StopSoftwareTriggerAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_DataReceived), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ErrorOccurred), METH_O, nullptr },
        { "add_image_preview_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ImagePreviewReceived), METH_O, nullptr },
        { "remove_image_preview_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ImagePreviewReceived), METH_O, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_trigger_pressed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_TriggerPressed), METH_O, nullptr },
        { "remove_trigger_pressed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_TriggerPressed), METH_O, nullptr },
        { "add_trigger_released", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_TriggerReleased), METH_O, nullptr },
        { "remove_trigger_released", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_TriggerReleased), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedBarcodeScanner), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedBarcodeScanner), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedBarcodeScanner), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScanner[] = {
        { "is_disabled_on_data_received", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsDisabledOnDataReceived), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsDisabledOnDataReceived), nullptr, nullptr },
        { "is_decode_data_enabled", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsDecodeDataEnabled), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsDecodeDataEnabled), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_video_preview_shown_on_enable", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScanner[] = 
    {
        { Py_tp_new, _new_ClaimedBarcodeScanner },
        { Py_tp_dealloc, _dealloc_ClaimedBarcodeScanner },
        { Py_tp_methods, _methods_ClaimedBarcodeScanner },
        { Py_tp_getset, _getset_ClaimedBarcodeScanner },
        { },
    };

    static PyType_Spec _type_spec_ClaimedBarcodeScanner =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedBarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScanner
    };

    // ----- ClaimedBarcodeScannerClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedBarcodeScannerClosedEventArgs = "ClaimedBarcodeScannerClosedEventArgs";

    static PyObject* _new_ClaimedBarcodeScannerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedBarcodeScannerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScannerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedBarcodeScannerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScannerClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedBarcodeScannerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScannerClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScannerClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedBarcodeScannerClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedBarcodeScannerClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedBarcodeScannerClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedBarcodeScannerClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ClaimedBarcodeScannerClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedBarcodeScannerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScannerClosedEventArgs
    };

    // ----- ClaimedCashDrawer class --------------------
    constexpr const char* const _type_name_ClaimedCashDrawer = "ClaimedCashDrawer";

    static PyObject* _new_ClaimedCashDrawer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedCashDrawer);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedCashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_OpenDrawerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_CloseAlarm(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CloseAlarm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedCashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawer[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_EnableAsync), METH_VARARGS, nullptr },
        { "open_drawer_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_OpenDrawerAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_RetainDeviceAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedCashDrawer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedCashDrawer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedCashDrawer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedCashDrawer[] = {
        { "close_alarm", reinterpret_cast<getter>(ClaimedCashDrawer_get_CloseAlarm), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedCashDrawer_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_drawer_open", reinterpret_cast<getter>(ClaimedCashDrawer_get_IsDrawerOpen), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedCashDrawer_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawer[] = 
    {
        { Py_tp_new, _new_ClaimedCashDrawer },
        { Py_tp_dealloc, _dealloc_ClaimedCashDrawer },
        { Py_tp_methods, _methods_ClaimedCashDrawer },
        { Py_tp_getset, _getset_ClaimedCashDrawer },
        { },
    };

    static PyType_Spec _type_spec_ClaimedCashDrawer =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedCashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawer
    };

    // ----- ClaimedCashDrawerClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedCashDrawerClosedEventArgs = "ClaimedCashDrawerClosedEventArgs";

    static PyObject* _new_ClaimedCashDrawerClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedCashDrawerClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedCashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawerClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedCashDrawerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedCashDrawerClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawerClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedCashDrawerClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedCashDrawerClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedCashDrawerClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedCashDrawerClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ClaimedCashDrawerClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedCashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawerClosedEventArgs
    };

    // ----- ClaimedJournalPrinter class --------------------
    constexpr const char* const _type_name_ClaimedJournalPrinter = "ClaimedJournalPrinter";

    static PyObject* _new_ClaimedJournalPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedJournalPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedJournalPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedJournalPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedJournalPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedJournalPrinter[] = {
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedJournalPrinter_CreateJob), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedJournalPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedJournalPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedJournalPrinter[] = {
        { "line_spacing", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedJournalPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedJournalPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedJournalPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedJournalPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedJournalPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedJournalPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedJournalPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedJournalPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedJournalPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedJournalPrinter },
        { Py_tp_methods, _methods_ClaimedJournalPrinter },
        { Py_tp_getset, _getset_ClaimedJournalPrinter },
        { },
    };

    static PyType_Spec _type_spec_ClaimedJournalPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedJournalPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedJournalPrinter
    };

    // ----- ClaimedLineDisplay class --------------------
    constexpr const char* const _type_name_ClaimedLineDisplay = "ClaimedLineDisplay";

    static PyObject* _new_ClaimedLineDisplay(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedLineDisplay);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedLineDisplay_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetAttributes(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryClearDescriptorsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryClearDescriptorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryCreateWindowAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(self->obj.TryCreateWindowAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TrySetDescriptorAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayDescriptorState>(args, 1);

                return py::convert(self->obj.TrySetDescriptorAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryStoreStorageFileBitmapAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DefaultWindow(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_CustomGlyphs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_MaxBitmapSizeInPixels(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxBitmapSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedScreenSizesInCharacters(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedScreenSizesInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedLineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplay[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_CheckHealthAsync), METH_VARARGS, nullptr },
        { "check_power_status_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_CheckPowerStatusAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_attributes", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetAttributes), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_RetainDevice), METH_VARARGS, nullptr },
        { "try_clear_descriptors_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryClearDescriptorsAsync), METH_VARARGS, nullptr },
        { "try_create_window_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryCreateWindowAsync), METH_VARARGS, nullptr },
        { "try_set_descriptor_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TrySetDescriptorAsync), METH_VARARGS, nullptr },
        { "try_store_storage_file_bitmap_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryStoreStorageFileBitmapAsync), METH_VARARGS, nullptr },
        { "try_update_attributes_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryUpdateAttributesAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_StatusUpdated), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedLineDisplay), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedLineDisplay), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedLineDisplay), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedLineDisplay[] = {
        { "capabilities", reinterpret_cast<getter>(ClaimedLineDisplay_get_Capabilities), nullptr, nullptr, nullptr },
        { "default_window", reinterpret_cast<getter>(ClaimedLineDisplay_get_DefaultWindow), nullptr, nullptr, nullptr },
        { "device_control_description", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceControlDescription), nullptr, nullptr, nullptr },
        { "device_control_version", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceControlVersion), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_version", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceServiceVersion), nullptr, nullptr, nullptr },
        { "physical_device_description", reinterpret_cast<getter>(ClaimedLineDisplay_get_PhysicalDeviceDescription), nullptr, nullptr, nullptr },
        { "physical_device_name", reinterpret_cast<getter>(ClaimedLineDisplay_get_PhysicalDeviceName), nullptr, nullptr, nullptr },
        { "custom_glyphs", reinterpret_cast<getter>(ClaimedLineDisplay_get_CustomGlyphs), nullptr, nullptr, nullptr },
        { "max_bitmap_size_in_pixels", reinterpret_cast<getter>(ClaimedLineDisplay_get_MaxBitmapSizeInPixels), nullptr, nullptr, nullptr },
        { "supported_character_sets", reinterpret_cast<getter>(ClaimedLineDisplay_get_SupportedCharacterSets), nullptr, nullptr, nullptr },
        { "supported_screen_sizes_in_characters", reinterpret_cast<getter>(ClaimedLineDisplay_get_SupportedScreenSizesInCharacters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplay[] = 
    {
        { Py_tp_new, _new_ClaimedLineDisplay },
        { Py_tp_dealloc, _dealloc_ClaimedLineDisplay },
        { Py_tp_methods, _methods_ClaimedLineDisplay },
        { Py_tp_getset, _getset_ClaimedLineDisplay },
        { },
    };

    static PyType_Spec _type_spec_ClaimedLineDisplay =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedLineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplay
    };

    // ----- ClaimedLineDisplayClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedLineDisplayClosedEventArgs = "ClaimedLineDisplayClosedEventArgs";

    static PyObject* _new_ClaimedLineDisplayClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedLineDisplayClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplayClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedLineDisplayClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplayClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedLineDisplayClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedLineDisplayClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplayClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedLineDisplayClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedLineDisplayClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedLineDisplayClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedLineDisplayClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ClaimedLineDisplayClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedLineDisplayClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplayClosedEventArgs
    };

    // ----- ClaimedMagneticStripeReader class --------------------
    constexpr const char* const _type_name_ClaimedMagneticStripeReader = "ClaimedMagneticStripeReader";

    static PyObject* _new_ClaimedMagneticStripeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedMagneticStripeReader);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedMagneticStripeReader_AuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.AuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.DeAuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetrieveDeviceAuthenticationDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_SetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorReportingType>(args, 0);

                self->obj.SetErrorReportingType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateKeyAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UpdateKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TracksToRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackIds>(arg);

            self->obj.TracksToRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransmitSentinelsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransmitSentinelsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataEncryptionAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DataEncryptionAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDeviceAuthenticated(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeviceAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.AamvaCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AamvaCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.BankCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BankCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.VendorSpecificDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VendorSpecificDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedMagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReader[] = {
        { "authenticate_device_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_AuthenticateDeviceAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_Close), METH_VARARGS, nullptr },
        { "de_authenticate_device_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_EnableAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_RetainDevice), METH_VARARGS, nullptr },
        { "retrieve_device_authentication_data_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync), METH_VARARGS, nullptr },
        { "set_error_reporting_type", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_SetErrorReportingType), METH_VARARGS, nullptr },
        { "update_key_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_UpdateKeyAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_aamva_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_AamvaCardDataReceived), METH_O, nullptr },
        { "remove_aamva_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_AamvaCardDataReceived), METH_O, nullptr },
        { "add_bank_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_BankCardDataReceived), METH_O, nullptr },
        { "remove_bank_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_BankCardDataReceived), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_ErrorOccurred), METH_O, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_vendor_specific_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_VendorSpecificDataReceived), METH_O, nullptr },
        { "remove_vendor_specific_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedMagneticStripeReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedMagneticStripeReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedMagneticStripeReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReader[] = {
        { "tracks_to_read", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_TracksToRead), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_TracksToRead), nullptr, nullptr },
        { "is_transmit_sentinels_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled), nullptr, nullptr },
        { "is_disabled_on_data_received", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived), nullptr, nullptr },
        { "is_decode_data_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDecodeDataEnabled), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsDecodeDataEnabled), nullptr, nullptr },
        { "data_encryption_algorithm", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_device_authenticated", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDeviceAuthenticated), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReader[] = 
    {
        { Py_tp_new, _new_ClaimedMagneticStripeReader },
        { Py_tp_dealloc, _dealloc_ClaimedMagneticStripeReader },
        { Py_tp_methods, _methods_ClaimedMagneticStripeReader },
        { Py_tp_getset, _getset_ClaimedMagneticStripeReader },
        { },
    };

    static PyType_Spec _type_spec_ClaimedMagneticStripeReader =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedMagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReader
    };

    // ----- ClaimedMagneticStripeReaderClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedMagneticStripeReaderClosedEventArgs = "ClaimedMagneticStripeReaderClosedEventArgs";

    static PyObject* _new_ClaimedMagneticStripeReaderClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedMagneticStripeReaderClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReaderClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedMagneticStripeReaderClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedMagneticStripeReaderClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReaderClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedMagneticStripeReaderClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedMagneticStripeReaderClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedMagneticStripeReaderClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedMagneticStripeReaderClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ClaimedMagneticStripeReaderClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedMagneticStripeReaderClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReaderClosedEventArgs
    };

    // ----- ClaimedPosPrinter class --------------------
    constexpr const char* const _type_name_ClaimedPosPrinter = "ClaimedPosPrinter";

    static PyObject* _new_ClaimedPosPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedPosPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedPosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MapMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMapMode>(arg);

            self->obj.MapMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Journal(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Receipt(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Slip(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedPosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinter[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_EnableAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_RetainDeviceAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedPosPrinter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedPosPrinter), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ClaimedPosPrinter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedPosPrinter[] = {
        { "map_mode", reinterpret_cast<getter>(ClaimedPosPrinter_get_MapMode), reinterpret_cast<setter>(ClaimedPosPrinter_put_MapMode), nullptr, nullptr },
        { "is_character_set_mapping_enabled", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsCharacterSetMappingEnabled), reinterpret_cast<setter>(ClaimedPosPrinter_put_IsCharacterSetMappingEnabled), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(ClaimedPosPrinter_get_CharacterSet), reinterpret_cast<setter>(ClaimedPosPrinter_put_CharacterSet), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedPosPrinter_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsEnabled), nullptr, nullptr, nullptr },
        { "journal", reinterpret_cast<getter>(ClaimedPosPrinter_get_Journal), nullptr, nullptr, nullptr },
        { "receipt", reinterpret_cast<getter>(ClaimedPosPrinter_get_Receipt), nullptr, nullptr, nullptr },
        { "slip", reinterpret_cast<getter>(ClaimedPosPrinter_get_Slip), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedPosPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedPosPrinter },
        { Py_tp_methods, _methods_ClaimedPosPrinter },
        { Py_tp_getset, _getset_ClaimedPosPrinter },
        { },
    };

    static PyType_Spec _type_spec_ClaimedPosPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedPosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinter
    };

    // ----- ClaimedPosPrinterClosedEventArgs class --------------------
    constexpr const char* const _type_name_ClaimedPosPrinterClosedEventArgs = "ClaimedPosPrinterClosedEventArgs";

    static PyObject* _new_ClaimedPosPrinterClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedPosPrinterClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinterClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClaimedPosPrinterClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinterClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedPosPrinterClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedPosPrinterClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinterClosedEventArgs[] = 
    {
        { Py_tp_new, _new_ClaimedPosPrinterClosedEventArgs },
        { Py_tp_dealloc, _dealloc_ClaimedPosPrinterClosedEventArgs },
        { Py_tp_methods, _methods_ClaimedPosPrinterClosedEventArgs },
        { Py_tp_getset, _getset_ClaimedPosPrinterClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ClaimedPosPrinterClosedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedPosPrinterClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinterClosedEventArgs
    };

    // ----- ClaimedReceiptPrinter class --------------------
    constexpr const char* const _type_name_ClaimedReceiptPrinter = "ClaimedReceiptPrinter";

    static PyObject* _new_ClaimedReceiptPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedReceiptPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedReceiptPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedReceiptPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LinesToPaperCut(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinesToPaperCut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedReceiptPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedReceiptPrinter[] = {
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedReceiptPrinter_CreateJob), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedReceiptPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedReceiptPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedReceiptPrinter[] = {
        { "lines_to_paper_cut", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LinesToPaperCut), nullptr, nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_PageSize), nullptr, nullptr, nullptr },
        { "print_area", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_PrintArea), nullptr, nullptr, nullptr },
        { "sideways_max_chars", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_SidewaysMaxChars), nullptr, nullptr, nullptr },
        { "sideways_max_lines", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_SidewaysMaxLines), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedReceiptPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedReceiptPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedReceiptPrinter },
        { Py_tp_methods, _methods_ClaimedReceiptPrinter },
        { Py_tp_getset, _getset_ClaimedReceiptPrinter },
        { },
    };

    static PyType_Spec _type_spec_ClaimedReceiptPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedReceiptPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedReceiptPrinter
    };

    // ----- ClaimedSlipPrinter class --------------------
    constexpr const char* const _type_name_ClaimedSlipPrinter = "ClaimedSlipPrinter";

    static PyObject* _new_ClaimedSlipPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClaimedSlipPrinter);
        return nullptr;
    }

    static void _dealloc_ClaimedSlipPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClaimedSlipPrinter_ChangePrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintSide>(args, 0);

                self->obj.ChangePrintSide(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CloseJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CloseJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_InsertSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.InsertSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_OpenJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.OpenJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_RemoveSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.RemoveSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LinesNearEndToEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinesNearEndToEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_MaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrintSide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClaimedSlipPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedSlipPrinter[] = {
        { "change_print_side", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_ChangePrintSide), METH_VARARGS, nullptr },
        { "close_jaws", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_CloseJaws), METH_VARARGS, nullptr },
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_CreateJob), METH_VARARGS, nullptr },
        { "insert_slip_async", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_InsertSlipAsync), METH_VARARGS, nullptr },
        { "open_jaws", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_OpenJaws), METH_VARARGS, nullptr },
        { "remove_slip_async", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_RemoveSlipAsync), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedSlipPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedSlipPrinter[] = {
        { "lines_near_end_to_end", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LinesNearEndToEnd), nullptr, nullptr, nullptr },
        { "max_lines", reinterpret_cast<getter>(ClaimedSlipPrinter_get_MaxLines), nullptr, nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PageSize), nullptr, nullptr, nullptr },
        { "print_area", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PrintArea), nullptr, nullptr, nullptr },
        { "print_side", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PrintSide), nullptr, nullptr, nullptr },
        { "sideways_max_chars", reinterpret_cast<getter>(ClaimedSlipPrinter_get_SidewaysMaxChars), nullptr, nullptr, nullptr },
        { "sideways_max_lines", reinterpret_cast<getter>(ClaimedSlipPrinter_get_SidewaysMaxLines), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedSlipPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedSlipPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedSlipPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedSlipPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedSlipPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedSlipPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedSlipPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedSlipPrinter[] = 
    {
        { Py_tp_new, _new_ClaimedSlipPrinter },
        { Py_tp_dealloc, _dealloc_ClaimedSlipPrinter },
        { Py_tp_methods, _methods_ClaimedSlipPrinter },
        { Py_tp_getset, _getset_ClaimedSlipPrinter },
        { },
    };

    static PyType_Spec _type_spec_ClaimedSlipPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.ClaimedSlipPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedSlipPrinter
    };

    // ----- JournalPrintJob class --------------------
    constexpr const char* const _type_name_JournalPrintJob = "JournalPrintJob";

    static PyObject* _new_JournalPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_JournalPrintJob);
        return nullptr;
    }

    static void _dealloc_JournalPrintJob(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* JournalPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_JournalPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrintJob[] = {
        { "execute_async", reinterpret_cast<PyCFunction>(JournalPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(JournalPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(JournalPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(JournalPrintJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(JournalPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JournalPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JournalPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_JournalPrintJob[] = 
    {
        { Py_tp_new, _new_JournalPrintJob },
        { Py_tp_dealloc, _dealloc_JournalPrintJob },
        { Py_tp_methods, _methods_JournalPrintJob },
        { Py_tp_getset, _getset_JournalPrintJob },
        { },
    };

    static PyType_Spec _type_spec_JournalPrintJob =
    {
        "_winsdk_Windows_Devices_PointOfService.JournalPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrintJob
    };

    // ----- JournalPrinterCapabilities class --------------------
    constexpr const char* const _type_name_JournalPrinterCapabilities = "JournalPrinterCapabilities";

    static PyObject* _new_JournalPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_JournalPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_JournalPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* JournalPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_JournalPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrinterCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_JournalPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JournalPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(JournalPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(JournalPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(JournalPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JournalPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_JournalPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_JournalPrinterCapabilities },
        { Py_tp_methods, _methods_JournalPrinterCapabilities },
        { Py_tp_getset, _getset_JournalPrinterCapabilities },
        { },
    };

    static PyType_Spec _type_spec_JournalPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.JournalPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrinterCapabilities
    };

    // ----- LineDisplay class --------------------
    constexpr const char* const _type_name_LineDisplay = "LineDisplay";

    static PyObject* _new_LineDisplay(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplay);
        return nullptr;
    }

    static void _dealloc_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_ClaimAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_StatisticsCategorySelector(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::StatisticsCategorySelector());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplay[] = {
        { "check_power_status_async", reinterpret_cast<PyCFunction>(LineDisplay_CheckPowerStatusAsync), METH_VARARGS, nullptr },
        { "claim_async", reinterpret_cast<PyCFunction>(LineDisplay_ClaimAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(LineDisplay_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(LineDisplay_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(LineDisplay_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(LineDisplay_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_statistics_category_selector", reinterpret_cast<PyCFunction>(LineDisplay_get_StatisticsCategorySelector), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplay), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LineDisplay), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LineDisplay), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplay[] = {
        { "capabilities", reinterpret_cast<getter>(LineDisplay_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_control_description", reinterpret_cast<getter>(LineDisplay_get_DeviceControlDescription), nullptr, nullptr, nullptr },
        { "device_control_version", reinterpret_cast<getter>(LineDisplay_get_DeviceControlVersion), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(LineDisplay_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_version", reinterpret_cast<getter>(LineDisplay_get_DeviceServiceVersion), nullptr, nullptr, nullptr },
        { "physical_device_description", reinterpret_cast<getter>(LineDisplay_get_PhysicalDeviceDescription), nullptr, nullptr, nullptr },
        { "physical_device_name", reinterpret_cast<getter>(LineDisplay_get_PhysicalDeviceName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplay[] = 
    {
        { Py_tp_new, _new_LineDisplay },
        { Py_tp_dealloc, _dealloc_LineDisplay },
        { Py_tp_methods, _methods_LineDisplay },
        { Py_tp_getset, _getset_LineDisplay },
        { },
    };

    static PyType_Spec _type_spec_LineDisplay =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplay
    };

    // ----- LineDisplayAttributes class --------------------
    constexpr const char* const _type_name_LineDisplayAttributes = "LineDisplayAttributes";

    static PyObject* _new_LineDisplayAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayAttributes);
        return nullptr;
    }

    static void _dealloc_LineDisplayAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayAttributes_get_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScreenSizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.ScreenSizeInCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPowerNotifyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPowerNotifyEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayWindow>(arg);

            self->obj.CurrentWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BlinkRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LineDisplayAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayAttributes[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayAttributes[] = {
        { "screen_size_in_characters", reinterpret_cast<getter>(LineDisplayAttributes_get_ScreenSizeInCharacters), reinterpret_cast<setter>(LineDisplayAttributes_put_ScreenSizeInCharacters), nullptr, nullptr },
        { "is_power_notify_enabled", reinterpret_cast<getter>(LineDisplayAttributes_get_IsPowerNotifyEnabled), reinterpret_cast<setter>(LineDisplayAttributes_put_IsPowerNotifyEnabled), nullptr, nullptr },
        { "is_character_set_mapping_enabled", reinterpret_cast<getter>(LineDisplayAttributes_get_IsCharacterSetMappingEnabled), reinterpret_cast<setter>(LineDisplayAttributes_put_IsCharacterSetMappingEnabled), nullptr, nullptr },
        { "current_window", reinterpret_cast<getter>(LineDisplayAttributes_get_CurrentWindow), reinterpret_cast<setter>(LineDisplayAttributes_put_CurrentWindow), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(LineDisplayAttributes_get_CharacterSet), reinterpret_cast<setter>(LineDisplayAttributes_put_CharacterSet), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(LineDisplayAttributes_get_Brightness), reinterpret_cast<setter>(LineDisplayAttributes_put_Brightness), nullptr, nullptr },
        { "blink_rate", reinterpret_cast<getter>(LineDisplayAttributes_get_BlinkRate), reinterpret_cast<setter>(LineDisplayAttributes_put_BlinkRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayAttributes[] = 
    {
        { Py_tp_new, _new_LineDisplayAttributes },
        { Py_tp_dealloc, _dealloc_LineDisplayAttributes },
        { Py_tp_methods, _methods_LineDisplayAttributes },
        { Py_tp_getset, _getset_LineDisplayAttributes },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayAttributes =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayAttributes
    };

    // ----- LineDisplayCapabilities class --------------------
    constexpr const char* const _type_name_LineDisplayCapabilities = "LineDisplayCapabilities";

    static PyObject* _new_LineDisplayCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCapabilities);
        return nullptr;
    }

    static void _dealloc_LineDisplayCapabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCapabilities_get_CanBlink(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanBlink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeBlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanChangeBlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeScreenSize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanChangeScreenSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayBitmaps(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDisplayBitmaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDisplayCustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanMapCharacterSets(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanMapCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReadCharacterAtCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanReadCharacterAtCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReverse(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanReverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsBrightnessSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBrightnessSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsCursorSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCursorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsHorizontalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHorizontalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsInterCharacterWaitSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterCharacterWaitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsVerticalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVerticalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedDescriptors(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedDescriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedWindows(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedWindows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCapabilities[] = {
        { "can_blink", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanBlink), nullptr, nullptr, nullptr },
        { "can_change_blink_rate", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanChangeBlinkRate), nullptr, nullptr, nullptr },
        { "can_change_screen_size", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanChangeScreenSize), nullptr, nullptr, nullptr },
        { "can_display_bitmaps", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanDisplayBitmaps), nullptr, nullptr, nullptr },
        { "can_display_custom_glyphs", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanDisplayCustomGlyphs), nullptr, nullptr, nullptr },
        { "can_map_character_sets", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanMapCharacterSets), nullptr, nullptr, nullptr },
        { "can_read_character_at_cursor", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanReadCharacterAtCursor), nullptr, nullptr, nullptr },
        { "can_reverse", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanReverse), nullptr, nullptr, nullptr },
        { "is_brightness_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsBrightnessSupported), nullptr, nullptr, nullptr },
        { "is_cursor_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsCursorSupported), nullptr, nullptr, nullptr },
        { "is_horizontal_marquee_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsHorizontalMarqueeSupported), nullptr, nullptr, nullptr },
        { "is_inter_character_wait_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsInterCharacterWaitSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_vertical_marquee_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsVerticalMarqueeSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(LineDisplayCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "supported_descriptors", reinterpret_cast<getter>(LineDisplayCapabilities_get_SupportedDescriptors), nullptr, nullptr, nullptr },
        { "supported_windows", reinterpret_cast<getter>(LineDisplayCapabilities_get_SupportedWindows), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCapabilities[] = 
    {
        { Py_tp_new, _new_LineDisplayCapabilities },
        { Py_tp_dealloc, _dealloc_LineDisplayCapabilities },
        { Py_tp_methods, _methods_LineDisplayCapabilities },
        { Py_tp_getset, _getset_LineDisplayCapabilities },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCapabilities
    };

    // ----- LineDisplayCursor class --------------------
    constexpr const char* const _type_name_LineDisplayCursor = "LineDisplayCursor";

    static PyObject* _new_LineDisplayCursor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCursor);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCursor_GetAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_CanCustomize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCustomize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlinkSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBlinkSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsHalfBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHalfBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsOtherSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOtherSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsReverseSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursor[] = {
        { "get_attributes", reinterpret_cast<PyCFunction>(LineDisplayCursor_GetAttributes), METH_VARARGS, nullptr },
        { "try_update_attributes_async", reinterpret_cast<PyCFunction>(LineDisplayCursor_TryUpdateAttributesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCursor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCursor[] = {
        { "can_customize", reinterpret_cast<getter>(LineDisplayCursor_get_CanCustomize), nullptr, nullptr, nullptr },
        { "is_blink_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsBlinkSupported), nullptr, nullptr, nullptr },
        { "is_block_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsBlockSupported), nullptr, nullptr, nullptr },
        { "is_half_block_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsHalfBlockSupported), nullptr, nullptr, nullptr },
        { "is_other_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsOtherSupported), nullptr, nullptr, nullptr },
        { "is_reverse_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsReverseSupported), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCursor[] = 
    {
        { Py_tp_new, _new_LineDisplayCursor },
        { Py_tp_dealloc, _dealloc_LineDisplayCursor },
        { Py_tp_methods, _methods_LineDisplayCursor },
        { Py_tp_getset, _getset_LineDisplayCursor },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayCursor =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCursor",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursor
    };

    // ----- LineDisplayCursorAttributes class --------------------
    constexpr const char* const _type_name_LineDisplayCursorAttributes = "LineDisplayCursorAttributes";

    static PyObject* _new_LineDisplayCursorAttributes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCursorAttributes);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursorAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCursorAttributes_get_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBlinkEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBlinkEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoAdvanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoAdvanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CursorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorType>(arg);

            self->obj.CursorType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LineDisplayCursorAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursorAttributes[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCursorAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCursorAttributes[] = {
        { "position", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_Position), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_Position), nullptr, nullptr },
        { "is_blink_enabled", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_IsBlinkEnabled), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_IsBlinkEnabled), nullptr, nullptr },
        { "is_auto_advance_enabled", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled), nullptr, nullptr },
        { "cursor_type", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_CursorType), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_CursorType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCursorAttributes[] = 
    {
        { Py_tp_new, _new_LineDisplayCursorAttributes },
        { Py_tp_dealloc, _dealloc_LineDisplayCursorAttributes },
        { Py_tp_methods, _methods_LineDisplayCursorAttributes },
        { Py_tp_getset, _getset_LineDisplayCursorAttributes },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayCursorAttributes =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCursorAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursorAttributes
    };

    // ----- LineDisplayCustomGlyphs class --------------------
    constexpr const char* const _type_name_LineDisplayCustomGlyphs = "LineDisplayCustomGlyphs";

    static PyObject* _new_LineDisplayCustomGlyphs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayCustomGlyphs);
        return nullptr;
    }

    static void _dealloc_LineDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayCustomGlyphs_TryRedefineAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.TryRedefineAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SizeInPixels(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SupportedGlyphCodes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedGlyphCodes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayCustomGlyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCustomGlyphs[] = {
        { "try_redefine_async", reinterpret_cast<PyCFunction>(LineDisplayCustomGlyphs_TryRedefineAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCustomGlyphs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCustomGlyphs[] = {
        { "size_in_pixels", reinterpret_cast<getter>(LineDisplayCustomGlyphs_get_SizeInPixels), nullptr, nullptr, nullptr },
        { "supported_glyph_codes", reinterpret_cast<getter>(LineDisplayCustomGlyphs_get_SupportedGlyphCodes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCustomGlyphs[] = 
    {
        { Py_tp_new, _new_LineDisplayCustomGlyphs },
        { Py_tp_dealloc, _dealloc_LineDisplayCustomGlyphs },
        { Py_tp_methods, _methods_LineDisplayCustomGlyphs },
        { Py_tp_getset, _getset_LineDisplayCustomGlyphs },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayCustomGlyphs =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayCustomGlyphs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCustomGlyphs
    };

    // ----- LineDisplayMarquee class --------------------
    constexpr const char* const _type_name_LineDisplayMarquee = "LineDisplayMarquee";

    static PyObject* _new_LineDisplayMarquee(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayMarquee);
        return nullptr;
    }

    static void _dealloc_LineDisplayMarquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayMarquee_TryStartScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);

                return py::convert(self->obj.TryStartScrollingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_TryStopScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryStopScrollingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_get_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.ScrollWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepeatWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepeatWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayMarqueeFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LineDisplayMarquee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayMarquee[] = {
        { "try_start_scrolling_async", reinterpret_cast<PyCFunction>(LineDisplayMarquee_TryStartScrollingAsync), METH_VARARGS, nullptr },
        { "try_stop_scrolling_async", reinterpret_cast<PyCFunction>(LineDisplayMarquee_TryStopScrollingAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayMarquee), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayMarquee[] = {
        { "scroll_wait_interval", reinterpret_cast<getter>(LineDisplayMarquee_get_ScrollWaitInterval), reinterpret_cast<setter>(LineDisplayMarquee_put_ScrollWaitInterval), nullptr, nullptr },
        { "repeat_wait_interval", reinterpret_cast<getter>(LineDisplayMarquee_get_RepeatWaitInterval), reinterpret_cast<setter>(LineDisplayMarquee_put_RepeatWaitInterval), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(LineDisplayMarquee_get_Format), reinterpret_cast<setter>(LineDisplayMarquee_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayMarquee[] = 
    {
        { Py_tp_new, _new_LineDisplayMarquee },
        { Py_tp_dealloc, _dealloc_LineDisplayMarquee },
        { Py_tp_methods, _methods_LineDisplayMarquee },
        { Py_tp_getset, _getset_LineDisplayMarquee },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayMarquee =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayMarquee",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayMarquee
    };

    // ----- LineDisplayStatisticsCategorySelector class --------------------
    constexpr const char* const _type_name_LineDisplayStatisticsCategorySelector = "LineDisplayStatisticsCategorySelector";

    static PyObject* _new_LineDisplayStatisticsCategorySelector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayStatisticsCategorySelector);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatisticsCategorySelector(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_AllStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ManufacturerStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnifiedPosStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayStatisticsCategorySelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatisticsCategorySelector[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStatisticsCategorySelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStatisticsCategorySelector[] = {
        { "all_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_AllStatistics), nullptr, nullptr, nullptr },
        { "manufacturer_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics), nullptr, nullptr, nullptr },
        { "unified_pos_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStatisticsCategorySelector[] = 
    {
        { Py_tp_new, _new_LineDisplayStatisticsCategorySelector },
        { Py_tp_dealloc, _dealloc_LineDisplayStatisticsCategorySelector },
        { Py_tp_methods, _methods_LineDisplayStatisticsCategorySelector },
        { Py_tp_getset, _getset_LineDisplayStatisticsCategorySelector },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayStatisticsCategorySelector =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayStatisticsCategorySelector",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatisticsCategorySelector
    };

    // ----- LineDisplayStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_LineDisplayStatusUpdatedEventArgs = "LineDisplayStatusUpdatedEventArgs";

    static PyObject* _new_LineDisplayStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatusUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(LineDisplayStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_LineDisplayStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_LineDisplayStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_LineDisplayStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_LineDisplayStatusUpdatedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatusUpdatedEventArgs
    };

    // ----- LineDisplayStoredBitmap class --------------------
    constexpr const char* const _type_name_LineDisplayStoredBitmap = "LineDisplayStoredBitmap";

    static PyObject* _new_LineDisplayStoredBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayStoredBitmap);
        return nullptr;
    }

    static void _dealloc_LineDisplayStoredBitmap(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayStoredBitmap_TryDeleteAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayStoredBitmap_get_EscapeSequence(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EscapeSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayStoredBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStoredBitmap[] = {
        { "try_delete_async", reinterpret_cast<PyCFunction>(LineDisplayStoredBitmap_TryDeleteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStoredBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStoredBitmap[] = {
        { "escape_sequence", reinterpret_cast<getter>(LineDisplayStoredBitmap_get_EscapeSequence), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStoredBitmap[] = 
    {
        { Py_tp_new, _new_LineDisplayStoredBitmap },
        { Py_tp_dealloc, _dealloc_LineDisplayStoredBitmap },
        { Py_tp_methods, _methods_LineDisplayStoredBitmap },
        { Py_tp_getset, _getset_LineDisplayStoredBitmap },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayStoredBitmap =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayStoredBitmap",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStoredBitmap
    };

    // ----- LineDisplayWindow class --------------------
    constexpr const char* const _type_name_LineDisplayWindow = "LineDisplayWindow";

    static PyObject* _new_LineDisplayWindow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LineDisplayWindow);
        return nullptr;
    }

    static void _dealloc_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LineDisplayWindow_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_ReadCharacterAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadCharacterAtCursorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryClearTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryClearTextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>(args, 0);

                return py::convert(self->obj.TryDisplayStoredBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDisplayTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Point>(args, 2);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryRefreshAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryRefreshAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryScrollTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.TryScrollTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterCharacterWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayWindow_put_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InterCharacterWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayWindow_get_SizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Cursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Marquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Marquee());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LineDisplayWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayWindow[] = {
        { "close", reinterpret_cast<PyCFunction>(LineDisplayWindow_Close), METH_VARARGS, nullptr },
        { "read_character_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_ReadCharacterAtCursorAsync), METH_VARARGS, nullptr },
        { "try_clear_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryClearTextAsync), METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync), METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_point_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync), METH_VARARGS, nullptr },
        { "try_display_stored_bitmap_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync), METH_VARARGS, nullptr },
        { "try_display_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayTextAsync), METH_VARARGS, nullptr },
        { "try_refresh_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryRefreshAsync), METH_VARARGS, nullptr },
        { "try_scroll_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryScrollTextAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayWindow), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LineDisplayWindow), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LineDisplayWindow), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayWindow[] = {
        { "inter_character_wait_interval", reinterpret_cast<getter>(LineDisplayWindow_get_InterCharacterWaitInterval), reinterpret_cast<setter>(LineDisplayWindow_put_InterCharacterWaitInterval), nullptr, nullptr },
        { "size_in_characters", reinterpret_cast<getter>(LineDisplayWindow_get_SizeInCharacters), nullptr, nullptr, nullptr },
        { "cursor", reinterpret_cast<getter>(LineDisplayWindow_get_Cursor), nullptr, nullptr, nullptr },
        { "marquee", reinterpret_cast<getter>(LineDisplayWindow_get_Marquee), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayWindow[] = 
    {
        { Py_tp_new, _new_LineDisplayWindow },
        { Py_tp_dealloc, _dealloc_LineDisplayWindow },
        { Py_tp_methods, _methods_LineDisplayWindow },
        { Py_tp_getset, _getset_LineDisplayWindow },
        { },
    };

    static PyType_Spec _type_spec_LineDisplayWindow =
    {
        "_winsdk_Windows_Devices_PointOfService.LineDisplayWindow",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayWindow
    };

    // ----- MagneticStripeReader class --------------------
    constexpr const char* const _type_name_MagneticStripeReader = "MagneticStripeReader";

    static PyObject* _new_MagneticStripeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReader);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReader_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_ClaimReaderAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimReaderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetErrorReportingType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceAuthenticationProtocol(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAuthenticationProtocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_SupportedCardTypes(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCardTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::MagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReader[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_reader_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_ClaimReaderAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MagneticStripeReader_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_error_reporting_type", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetErrorReportingType), METH_VARARGS, nullptr },
        { "retrieve_statistics_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_RetrieveStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(MagneticStripeReader_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(MagneticStripeReader_remove_StatusUpdated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MagneticStripeReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MagneticStripeReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReader[] = {
        { "capabilities", reinterpret_cast<getter>(MagneticStripeReader_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_authentication_protocol", reinterpret_cast<getter>(MagneticStripeReader_get_DeviceAuthenticationProtocol), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MagneticStripeReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "supported_card_types", reinterpret_cast<getter>(MagneticStripeReader_get_SupportedCardTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReader[] = 
    {
        { Py_tp_new, _new_MagneticStripeReader },
        { Py_tp_dealloc, _dealloc_MagneticStripeReader },
        { Py_tp_methods, _methods_MagneticStripeReader },
        { Py_tp_getset, _getset_MagneticStripeReader },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReader =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReader
    };

    // ----- MagneticStripeReaderAamvaCardDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs = "MagneticStripeReaderAamvaCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BirthDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Endorsements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EyeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HairColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Restrictions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderAamvaCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "address", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "birth_date", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate), nullptr, nullptr, nullptr },
        { "city", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City), nullptr, nullptr, nullptr },
        { "class", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class), nullptr, nullptr, nullptr },
        { "endorsements", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "eye_color", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName), nullptr, nullptr, nullptr },
        { "gender", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender), nullptr, nullptr, nullptr },
        { "hair_color", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height), nullptr, nullptr, nullptr },
        { "license_number", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { "restrictions", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State), nullptr, nullptr, nullptr },
        { "suffix", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix), nullptr, nullptr, nullptr },
        { "surname", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname), nullptr, nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs
    };

    // ----- MagneticStripeReaderBankCardDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderBankCardDataReceivedEventArgs = "MagneticStripeReaderBankCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderBankCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderBankCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MiddleInitial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderBankCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderBankCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "account_number", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName), nullptr, nullptr, nullptr },
        { "middle_initial", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { "service_code", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode), nullptr, nullptr, nullptr },
        { "suffix", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix), nullptr, nullptr, nullptr },
        { "surname", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderBankCardDataReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs
    };

    // ----- MagneticStripeReaderCapabilities class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderCapabilities = "MagneticStripeReaderCapabilities";

    static PyObject* _new_MagneticStripeReaderCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderCapabilities);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderCapabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderCapabilities_get_AuthenticationLevel(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_CardAuthentication(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardAuthentication());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsIsoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIsoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisOneSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsJisOneSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisTwoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsJisTwoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrackDataMaskingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransmitSentinelsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedEncryptionAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCapabilities[] = {
        { "authentication_level", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_AuthenticationLevel), nullptr, nullptr, nullptr },
        { "card_authentication", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_CardAuthentication), nullptr, nullptr, nullptr },
        { "is_iso_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsIsoSupported), nullptr, nullptr, nullptr },
        { "is_jis_one_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsJisOneSupported), nullptr, nullptr, nullptr },
        { "is_jis_two_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsJisTwoSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_track_data_masking_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported), nullptr, nullptr, nullptr },
        { "is_transmit_sentinels_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "supported_encryption_algorithms", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCapabilities[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderCapabilities },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderCapabilities },
        { Py_tp_methods, _methods_MagneticStripeReaderCapabilities },
        { Py_tp_getset, _getset_MagneticStripeReaderCapabilities },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCapabilities
    };

    // ----- MagneticStripeReaderCardTypes class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderCardTypes = "MagneticStripeReaderCardTypes";

    static PyObject* _new_MagneticStripeReaderCardTypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderCardTypes);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Aamva(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Aamva());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Bank(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Bank());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCardTypes[] = {
        { "get_aamva", reinterpret_cast<PyCFunction>(MagneticStripeReaderCardTypes_get_Aamva), METH_NOARGS | METH_STATIC, nullptr },
        { "get_bank", reinterpret_cast<PyCFunction>(MagneticStripeReaderCardTypes_get_Bank), METH_NOARGS | METH_STATIC, nullptr },
        { "get_extended_base", reinterpret_cast<PyCFunction>(MagneticStripeReaderCardTypes_get_ExtendedBase), METH_NOARGS | METH_STATIC, nullptr },
        { "get_unknown", reinterpret_cast<PyCFunction>(MagneticStripeReaderCardTypes_get_Unknown), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCardTypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCardTypes[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderCardTypes },
        { Py_tp_methods, _methods_MagneticStripeReaderCardTypes },
        { Py_tp_getset, _getset_MagneticStripeReaderCardTypes },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderCardTypes =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderCardTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCardTypes
    };

    // ----- MagneticStripeReaderEncryptionAlgorithms class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderEncryptionAlgorithms = "MagneticStripeReaderEncryptionAlgorithms";

    static PyObject* _new_MagneticStripeReaderEncryptionAlgorithms(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderEncryptionAlgorithms);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_None(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::None());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::TripleDesDukpt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderEncryptionAlgorithms[] = {
        { "get_extended_base", reinterpret_cast<PyCFunction>(MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase), METH_NOARGS | METH_STATIC, nullptr },
        { "get_none", reinterpret_cast<PyCFunction>(MagneticStripeReaderEncryptionAlgorithms_get_None), METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_dukpt", reinterpret_cast<PyCFunction>(MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderEncryptionAlgorithms[] = {
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderEncryptionAlgorithms[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderEncryptionAlgorithms },
        { Py_tp_methods, _methods_MagneticStripeReaderEncryptionAlgorithms },
        { Py_tp_getset, _getset_MagneticStripeReaderEncryptionAlgorithms },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderEncryptionAlgorithms =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderEncryptionAlgorithms",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderEncryptionAlgorithms
    };

    // ----- MagneticStripeReaderErrorOccurredEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderErrorOccurredEventArgs = "MagneticStripeReaderErrorOccurredEventArgs";

    static PyObject* _new_MagneticStripeReaderErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track1Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track2Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track3Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track4Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "error_data", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData), nullptr, nullptr, nullptr },
        { "partial_input_data", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData), nullptr, nullptr, nullptr },
        { "track1_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status), nullptr, nullptr, nullptr },
        { "track2_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status), nullptr, nullptr, nullptr },
        { "track3_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status), nullptr, nullptr, nullptr },
        { "track4_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderErrorOccurredEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderErrorOccurredEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderErrorOccurredEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderErrorOccurredEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderErrorOccurredEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderErrorOccurredEventArgs
    };

    // ----- MagneticStripeReaderReport class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderReport = "MagneticStripeReaderReport";

    static PyObject* _new_MagneticStripeReaderReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderReport);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderReport(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderReport_get_AdditionalSecurityInformation(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdditionalSecurityInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardAuthenticationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationDataLength(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardAuthenticationDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CardType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Properties(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track1(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track2(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track3(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track4(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Track4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderReport[] = {
        { "additional_security_information", reinterpret_cast<getter>(MagneticStripeReaderReport_get_AdditionalSecurityInformation), nullptr, nullptr, nullptr },
        { "card_authentication_data", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardAuthenticationData), nullptr, nullptr, nullptr },
        { "card_authentication_data_length", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardAuthenticationDataLength), nullptr, nullptr, nullptr },
        { "card_type", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardType), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Properties), nullptr, nullptr, nullptr },
        { "track1", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track1), nullptr, nullptr, nullptr },
        { "track2", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track2), nullptr, nullptr, nullptr },
        { "track3", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track3), nullptr, nullptr, nullptr },
        { "track4", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track4), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderReport[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderReport },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderReport },
        { Py_tp_methods, _methods_MagneticStripeReaderReport },
        { Py_tp_getset, _getset_MagneticStripeReaderReport },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderReport =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderReport
    };

    // ----- MagneticStripeReaderStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderStatusUpdatedEventArgs = "MagneticStripeReaderStatusUpdatedEventArgs";

    static PyObject* _new_MagneticStripeReaderStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "extended_status", reinterpret_cast<getter>(MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MagneticStripeReaderStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderStatusUpdatedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderStatusUpdatedEventArgs
    };

    // ----- MagneticStripeReaderTrackData class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderTrackData = "MagneticStripeReaderTrackData";

    static PyObject* _new_MagneticStripeReaderTrackData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderTrackData);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderTrackData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderTrackData_get_Data(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_DiscretionaryData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DiscretionaryData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_EncryptedData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderTrackData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderTrackData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderTrackData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderTrackData[] = {
        { "data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_Data), nullptr, nullptr, nullptr },
        { "discretionary_data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_DiscretionaryData), nullptr, nullptr, nullptr },
        { "encrypted_data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_EncryptedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderTrackData[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderTrackData },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderTrackData },
        { Py_tp_methods, _methods_MagneticStripeReaderTrackData },
        { Py_tp_getset, _getset_MagneticStripeReaderTrackData },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderTrackData =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderTrackData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderTrackData
    };

    // ----- MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs = "MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs";

    static PyObject* _new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { Py_tp_methods, _methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { Py_tp_getset, _getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs
    };

    // ----- PosPrinter class --------------------
    constexpr const char* const _type_name_PosPrinter = "PosPrinter";

    static PyObject* _new_PosPrinter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinter);
        return nullptr;
    }

    static void _dealloc_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinter_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_ClaimPrinterAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClaimPrinterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFontProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedTypeFaces(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedTypeFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedBarcodeSymbologies(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeSymbologies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::PosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinter[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(PosPrinter_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_printer_async", reinterpret_cast<PyCFunction>(PosPrinter_ClaimPrinterAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(PosPrinter_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PosPrinter_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(PosPrinter_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(PosPrinter_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_font_property", reinterpret_cast<PyCFunction>(PosPrinter_GetFontProperty), METH_VARARGS, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(PosPrinter_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(PosPrinter_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(PosPrinter_remove_StatusUpdated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PosPrinter), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PosPrinter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinter[] = {
        { "capabilities", reinterpret_cast<getter>(PosPrinter_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PosPrinter_get_DeviceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PosPrinter_get_Status), nullptr, nullptr, nullptr },
        { "supported_character_sets", reinterpret_cast<getter>(PosPrinter_get_SupportedCharacterSets), nullptr, nullptr, nullptr },
        { "supported_type_faces", reinterpret_cast<getter>(PosPrinter_get_SupportedTypeFaces), nullptr, nullptr, nullptr },
        { "supported_barcode_symbologies", reinterpret_cast<getter>(PosPrinter_get_SupportedBarcodeSymbologies), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinter[] = 
    {
        { Py_tp_new, _new_PosPrinter },
        { Py_tp_dealloc, _dealloc_PosPrinter },
        { Py_tp_methods, _methods_PosPrinter },
        { Py_tp_getset, _getset_PosPrinter },
        { },
    };

    static PyType_Spec _type_spec_PosPrinter =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinter
    };

    // ----- PosPrinterCapabilities class --------------------
    constexpr const char* const _type_name_PosPrinterCapabilities = "PosPrinterCapabilities";

    static PyObject* _new_PosPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_PosPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterCapabilities_get_CanMapCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanMapCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_DefaultCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_HasCoverSensor(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasCoverSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsTransactionSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransactionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Journal(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Receipt(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Slip(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterCapabilities[] = {
        { "can_map_character_set", reinterpret_cast<getter>(PosPrinterCapabilities_get_CanMapCharacterSet), nullptr, nullptr, nullptr },
        { "default_character_set", reinterpret_cast<getter>(PosPrinterCapabilities_get_DefaultCharacterSet), nullptr, nullptr, nullptr },
        { "has_cover_sensor", reinterpret_cast<getter>(PosPrinterCapabilities_get_HasCoverSensor), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_transaction_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsTransactionSupported), nullptr, nullptr, nullptr },
        { "journal", reinterpret_cast<getter>(PosPrinterCapabilities_get_Journal), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(PosPrinterCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "receipt", reinterpret_cast<getter>(PosPrinterCapabilities_get_Receipt), nullptr, nullptr, nullptr },
        { "slip", reinterpret_cast<getter>(PosPrinterCapabilities_get_Slip), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_PosPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_PosPrinterCapabilities },
        { Py_tp_methods, _methods_PosPrinterCapabilities },
        { Py_tp_getset, _getset_PosPrinterCapabilities },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCapabilities
    };

    // ----- PosPrinterCharacterSetIds class --------------------
    constexpr const char* const _type_name_PosPrinterCharacterSetIds = "PosPrinterCharacterSetIds";

    static PyObject* _new_PosPrinterCharacterSetIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterCharacterSetIds);
        return nullptr;
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ansi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ansi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ascii(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ascii());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Utf16LE(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Utf16LE());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCharacterSetIds[] = {
        { "get_ansi", reinterpret_cast<PyCFunction>(PosPrinterCharacterSetIds_get_Ansi), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ascii", reinterpret_cast<PyCFunction>(PosPrinterCharacterSetIds_get_Ascii), METH_NOARGS | METH_STATIC, nullptr },
        { "get_utf16_l_e", reinterpret_cast<PyCFunction>(PosPrinterCharacterSetIds_get_Utf16LE), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterCharacterSetIds[] = {
        { }
    };

    static PyType_Slot _type_slots_PosPrinterCharacterSetIds[] = 
    {
        { Py_tp_new, _new_PosPrinterCharacterSetIds },
        { Py_tp_methods, _methods_PosPrinterCharacterSetIds },
        { Py_tp_getset, _getset_PosPrinterCharacterSetIds },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterCharacterSetIds =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterCharacterSetIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCharacterSetIds
    };

    // ----- PosPrinterFontProperty class --------------------
    constexpr const char* const _type_name_PosPrinterFontProperty = "PosPrinterFontProperty";

    static PyObject* _new_PosPrinterFontProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterFontProperty);
        return nullptr;
    }

    static void _dealloc_PosPrinterFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterFontProperty_get_CharacterSizes(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSizes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_IsScalableToAnySize(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScalableToAnySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterFontProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterFontProperty[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterFontProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterFontProperty[] = {
        { "character_sizes", reinterpret_cast<getter>(PosPrinterFontProperty_get_CharacterSizes), nullptr, nullptr, nullptr },
        { "is_scalable_to_any_size", reinterpret_cast<getter>(PosPrinterFontProperty_get_IsScalableToAnySize), nullptr, nullptr, nullptr },
        { "type_face", reinterpret_cast<getter>(PosPrinterFontProperty_get_TypeFace), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterFontProperty[] = 
    {
        { Py_tp_new, _new_PosPrinterFontProperty },
        { Py_tp_dealloc, _dealloc_PosPrinterFontProperty },
        { Py_tp_methods, _methods_PosPrinterFontProperty },
        { Py_tp_getset, _getset_PosPrinterFontProperty },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterFontProperty =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterFontProperty",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterFontProperty
    };

    // ----- PosPrinterPrintOptions class --------------------
    constexpr const char* const _type_name_PosPrinterPrintOptions = "PosPrinterPrintOptions";

    static PyObject* _new_PosPrinterPrintOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PosPrinterPrintOptions(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterPrintOptions_get_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Underline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Underline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TypeFace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Superscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Superscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Subscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Strikethrough());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Strikethrough(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReverseVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ReverseVideo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Italic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Italic(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DoubleWide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleWide(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DoubleHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(arg);

            self->obj.Alignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PosPrinterPrintOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterPrintOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterPrintOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterPrintOptions[] = {
        { "underline", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Underline), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Underline), nullptr, nullptr },
        { "type_face", reinterpret_cast<getter>(PosPrinterPrintOptions_get_TypeFace), reinterpret_cast<setter>(PosPrinterPrintOptions_put_TypeFace), nullptr, nullptr },
        { "superscript", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Superscript), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Superscript), nullptr, nullptr },
        { "subscript", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Subscript), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Subscript), nullptr, nullptr },
        { "strikethrough", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Strikethrough), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Strikethrough), nullptr, nullptr },
        { "reverse_video", reinterpret_cast<getter>(PosPrinterPrintOptions_get_ReverseVideo), reinterpret_cast<setter>(PosPrinterPrintOptions_put_ReverseVideo), nullptr, nullptr },
        { "italic", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Italic), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Italic), nullptr, nullptr },
        { "double_wide", reinterpret_cast<getter>(PosPrinterPrintOptions_get_DoubleWide), reinterpret_cast<setter>(PosPrinterPrintOptions_put_DoubleWide), nullptr, nullptr },
        { "double_high", reinterpret_cast<getter>(PosPrinterPrintOptions_get_DoubleHigh), reinterpret_cast<setter>(PosPrinterPrintOptions_put_DoubleHigh), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(PosPrinterPrintOptions_get_CharacterSet), reinterpret_cast<setter>(PosPrinterPrintOptions_put_CharacterSet), nullptr, nullptr },
        { "character_height", reinterpret_cast<getter>(PosPrinterPrintOptions_get_CharacterHeight), reinterpret_cast<setter>(PosPrinterPrintOptions_put_CharacterHeight), nullptr, nullptr },
        { "bold", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Bold), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Bold), nullptr, nullptr },
        { "alignment", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Alignment), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Alignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterPrintOptions[] = 
    {
        { Py_tp_new, _new_PosPrinterPrintOptions },
        { Py_tp_dealloc, _dealloc_PosPrinterPrintOptions },
        { Py_tp_methods, _methods_PosPrinterPrintOptions },
        { Py_tp_getset, _getset_PosPrinterPrintOptions },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterPrintOptions =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterPrintOptions",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterPrintOptions
    };

    // ----- PosPrinterReleaseDeviceRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PosPrinterReleaseDeviceRequestedEventArgs = "PosPrinterReleaseDeviceRequestedEventArgs";

    static PyObject* _new_PosPrinterReleaseDeviceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterReleaseDeviceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PosPrinterReleaseDeviceRequestedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_PosPrinterReleaseDeviceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterReleaseDeviceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PosPrinterReleaseDeviceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PosPrinterReleaseDeviceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PosPrinterReleaseDeviceRequestedEventArgs },
        { Py_tp_methods, _methods_PosPrinterReleaseDeviceRequestedEventArgs },
        { Py_tp_getset, _getset_PosPrinterReleaseDeviceRequestedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterReleaseDeviceRequestedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterReleaseDeviceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterReleaseDeviceRequestedEventArgs
    };

    // ----- PosPrinterStatus class --------------------
    constexpr const char* const _type_name_PosPrinterStatus = "PosPrinterStatus";

    static PyObject* _new_PosPrinterStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterStatus);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatus[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterStatus[] = {
        { "extended_status", reinterpret_cast<getter>(PosPrinterStatus_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status_kind", reinterpret_cast<getter>(PosPrinterStatus_get_StatusKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterStatus[] = 
    {
        { Py_tp_new, _new_PosPrinterStatus },
        { Py_tp_dealloc, _dealloc_PosPrinterStatus },
        { Py_tp_methods, _methods_PosPrinterStatus },
        { Py_tp_getset, _getset_PosPrinterStatus },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterStatus =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatus
    };

    // ----- PosPrinterStatusUpdatedEventArgs class --------------------
    constexpr const char* const _type_name_PosPrinterStatusUpdatedEventArgs = "PosPrinterStatusUpdatedEventArgs";

    static PyObject* _new_PosPrinterStatusUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PosPrinterStatusUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PosPrinterStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PosPrinterStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatusUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(PosPrinterStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterStatusUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_PosPrinterStatusUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_PosPrinterStatusUpdatedEventArgs },
        { Py_tp_methods, _methods_PosPrinterStatusUpdatedEventArgs },
        { Py_tp_getset, _getset_PosPrinterStatusUpdatedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_PosPrinterStatusUpdatedEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.PosPrinterStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatusUpdatedEventArgs
    };

    // ----- ReceiptPrintJob class --------------------
    constexpr const char* const _type_name_ReceiptPrintJob = "ReceiptPrintJob";

    static PyObject* _new_ReceiptPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ReceiptPrintJob);
        return nullptr;
    }

    static void _dealloc_ReceiptPrintJob(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ReceiptPrintJob_CutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CutPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.CutPaper(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_MarkFeed(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedKind>(args, 0);

                self->obj.MarkFeed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_StampPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StampPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ReceiptPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrintJob[] = {
        { "cut_paper", reinterpret_cast<PyCFunction>(ReceiptPrintJob_CutPaper), METH_VARARGS, nullptr },
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(ReceiptPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(ReceiptPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "mark_feed", reinterpret_cast<PyCFunction>(ReceiptPrintJob_MarkFeed), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(ReceiptPrintJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "stamp_paper", reinterpret_cast<PyCFunction>(ReceiptPrintJob_StampPaper), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReceiptPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReceiptPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_ReceiptPrintJob[] = 
    {
        { Py_tp_new, _new_ReceiptPrintJob },
        { Py_tp_dealloc, _dealloc_ReceiptPrintJob },
        { Py_tp_methods, _methods_ReceiptPrintJob },
        { Py_tp_getset, _getset_ReceiptPrintJob },
        { },
    };

    static PyType_Spec _type_spec_ReceiptPrintJob =
    {
        "_winsdk_Windows_Devices_PointOfService.ReceiptPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrintJob
    };

    // ----- ReceiptPrinterCapabilities class --------------------
    constexpr const char* const _type_name_ReceiptPrinterCapabilities = "ReceiptPrinterCapabilities";

    static PyObject* _new_ReceiptPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ReceiptPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_ReceiptPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ReceiptPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_CanCutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCutPaper());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStampSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStampSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_MarkFeedCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MarkFeedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ReceiptPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrinterCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ReceiptPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReceiptPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is180_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "can_cut_paper", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_CanCutPaper), nullptr, nullptr, nullptr },
        { "is_stamp_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsStampSupported), nullptr, nullptr, nullptr },
        { "mark_feed_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_MarkFeedCapabilities), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReceiptPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_ReceiptPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_ReceiptPrinterCapabilities },
        { Py_tp_methods, _methods_ReceiptPrinterCapabilities },
        { Py_tp_getset, _getset_ReceiptPrinterCapabilities },
        { },
    };

    static PyType_Spec _type_spec_ReceiptPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.ReceiptPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrinterCapabilities
    };

    // ----- SlipPrintJob class --------------------
    constexpr const char* const _type_name_SlipPrintJob = "SlipPrintJob";

    static PyObject* _new_SlipPrintJob(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SlipPrintJob);
        return nullptr;
    }

    static void _dealloc_SlipPrintJob(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SlipPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SlipPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrintJob[] = {
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(SlipPrintJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(SlipPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(SlipPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(SlipPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(SlipPrintJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(SlipPrintJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(SlipPrintJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(SlipPrintJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlipPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlipPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_SlipPrintJob[] = 
    {
        { Py_tp_new, _new_SlipPrintJob },
        { Py_tp_dealloc, _dealloc_SlipPrintJob },
        { Py_tp_methods, _methods_SlipPrintJob },
        { Py_tp_getset, _getset_SlipPrintJob },
        { },
    };

    static PyType_Spec _type_spec_SlipPrintJob =
    {
        "_winsdk_Windows_Devices_PointOfService.SlipPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrintJob
    };

    // ----- SlipPrinterCapabilities class --------------------
    constexpr const char* const _type_name_SlipPrinterCapabilities = "SlipPrinterCapabilities";

    static PyObject* _new_SlipPrinterCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SlipPrinterCapabilities);
        return nullptr;
    }

    static void _dealloc_SlipPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SlipPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBothSidesPrintingSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBothSidesPrintingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsFullLengthSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFullLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SlipPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrinterCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SlipPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlipPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(SlipPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(SlipPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is180_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(SlipPrinterCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "is_both_sides_printing_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBothSidesPrintingSupported), nullptr, nullptr, nullptr },
        { "is_full_length_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsFullLengthSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SlipPrinterCapabilities[] = 
    {
        { Py_tp_new, _new_SlipPrinterCapabilities },
        { Py_tp_dealloc, _dealloc_SlipPrinterCapabilities },
        { Py_tp_methods, _methods_SlipPrinterCapabilities },
        { Py_tp_getset, _getset_SlipPrinterCapabilities },
        { },
    };

    static PyType_Spec _type_spec_SlipPrinterCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.SlipPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrinterCapabilities
    };

    // ----- UnifiedPosErrorData class --------------------
    constexpr const char* const _type_name_UnifiedPosErrorData = "UnifiedPosErrorData";

    static PyObject* _new_UnifiedPosErrorData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorSeverity>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorReason>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::PointOfService::UnifiedPosErrorData instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UnifiedPosErrorData(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UnifiedPosErrorData_get_ExtendedReason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Message(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Reason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Severity(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Severity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UnifiedPosErrorData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnifiedPosErrorData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UnifiedPosErrorData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnifiedPosErrorData[] = {
        { "extended_reason", reinterpret_cast<getter>(UnifiedPosErrorData_get_ExtendedReason), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(UnifiedPosErrorData_get_Message), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(UnifiedPosErrorData_get_Reason), nullptr, nullptr, nullptr },
        { "severity", reinterpret_cast<getter>(UnifiedPosErrorData_get_Severity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnifiedPosErrorData[] = 
    {
        { Py_tp_new, _new_UnifiedPosErrorData },
        { Py_tp_dealloc, _dealloc_UnifiedPosErrorData },
        { Py_tp_methods, _methods_UnifiedPosErrorData },
        { Py_tp_getset, _getset_UnifiedPosErrorData },
        { },
    };

    static PyType_Spec _type_spec_UnifiedPosErrorData =
    {
        "_winsdk_Windows_Devices_PointOfService.UnifiedPosErrorData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnifiedPosErrorData
    };

    // ----- ICashDrawerEventSourceEventArgs interface --------------------
    constexpr const char* const _type_name_ICashDrawerEventSourceEventArgs = "ICashDrawerEventSourceEventArgs";

    static PyObject* _new_ICashDrawerEventSourceEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICashDrawerEventSourceEventArgs);
        return nullptr;
    }

    static void _dealloc_ICashDrawerEventSourceEventArgs(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICashDrawerEventSourceEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICashDrawerEventSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICashDrawerEventSourceEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICashDrawerEventSourceEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICashDrawerEventSourceEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(ICashDrawerEventSourceEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICashDrawerEventSourceEventArgs[] = 
    {
        { Py_tp_new, _new_ICashDrawerEventSourceEventArgs },
        { Py_tp_dealloc, _dealloc_ICashDrawerEventSourceEventArgs },
        { Py_tp_methods, _methods_ICashDrawerEventSourceEventArgs },
        { Py_tp_getset, _getset_ICashDrawerEventSourceEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ICashDrawerEventSourceEventArgs =
    {
        "_winsdk_Windows_Devices_PointOfService.ICashDrawerEventSourceEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICashDrawerEventSourceEventArgs
    };

    // ----- ICommonClaimedPosPrinterStation interface --------------------
    constexpr const char* const _type_name_ICommonClaimedPosPrinterStation = "ICommonClaimedPosPrinterStation";

    static PyObject* _new_ICommonClaimedPosPrinterStation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICommonClaimedPosPrinterStation);
        return nullptr;
    }

    static void _dealloc_ICommonClaimedPosPrinterStation(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICommonClaimedPosPrinterStation_ValidateData(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommonClaimedPosPrinterStation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonClaimedPosPrinterStation[] = {
        { "validate_data", reinterpret_cast<PyCFunction>(ICommonClaimedPosPrinterStation_ValidateData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonClaimedPosPrinterStation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonClaimedPosPrinterStation[] = {
        { "characters_per_line", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_CharactersPerLine), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_CharactersPerLine), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_ColorCartridge), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_ColorCartridge), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsLetterQuality), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_IsLetterQuality), nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineHeight), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_LineHeight), nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineSpacing), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_LineSpacing), nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonClaimedPosPrinterStation[] = 
    {
        { Py_tp_new, _new_ICommonClaimedPosPrinterStation },
        { Py_tp_dealloc, _dealloc_ICommonClaimedPosPrinterStation },
        { Py_tp_methods, _methods_ICommonClaimedPosPrinterStation },
        { Py_tp_getset, _getset_ICommonClaimedPosPrinterStation },
        { },
    };

    static PyType_Spec _type_spec_ICommonClaimedPosPrinterStation =
    {
        "_winsdk_Windows_Devices_PointOfService.ICommonClaimedPosPrinterStation",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonClaimedPosPrinterStation
    };

    // ----- ICommonPosPrintStationCapabilities interface --------------------
    constexpr const char* const _type_name_ICommonPosPrintStationCapabilities = "ICommonPosPrintStationCapabilities";

    static PyObject* _new_ICommonPosPrintStationCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICommonPosPrintStationCapabilities);
        return nullptr;
    }

    static void _dealloc_ICommonPosPrintStationCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommonPosPrintStationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonPosPrintStationCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonPosPrintStationCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonPosPrintStationCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonPosPrintStationCapabilities[] = 
    {
        { Py_tp_new, _new_ICommonPosPrintStationCapabilities },
        { Py_tp_dealloc, _dealloc_ICommonPosPrintStationCapabilities },
        { Py_tp_methods, _methods_ICommonPosPrintStationCapabilities },
        { Py_tp_getset, _getset_ICommonPosPrintStationCapabilities },
        { },
    };

    static PyType_Spec _type_spec_ICommonPosPrintStationCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.ICommonPosPrintStationCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonPosPrintStationCapabilities
    };

    // ----- ICommonReceiptSlipCapabilities interface --------------------
    constexpr const char* const _type_name_ICommonReceiptSlipCapabilities = "ICommonReceiptSlipCapabilities";

    static PyObject* _new_ICommonReceiptSlipCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICommonReceiptSlipCapabilities);
        return nullptr;
    }

    static void _dealloc_ICommonReceiptSlipCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommonReceiptSlipCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonReceiptSlipCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonReceiptSlipCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonReceiptSlipCapabilities[] = {
        { "is180_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "cartridge_sensors", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonReceiptSlipCapabilities[] = 
    {
        { Py_tp_new, _new_ICommonReceiptSlipCapabilities },
        { Py_tp_dealloc, _dealloc_ICommonReceiptSlipCapabilities },
        { Py_tp_methods, _methods_ICommonReceiptSlipCapabilities },
        { Py_tp_getset, _getset_ICommonReceiptSlipCapabilities },
        { },
    };

    static PyType_Spec _type_spec_ICommonReceiptSlipCapabilities =
    {
        "_winsdk_Windows_Devices_PointOfService.ICommonReceiptSlipCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonReceiptSlipCapabilities
    };

    // ----- IPosPrinterJob interface --------------------
    constexpr const char* const _type_name_IPosPrinterJob = "IPosPrinterJob";

    static PyObject* _new_IPosPrinterJob(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IPosPrinterJob);
        return nullptr;
    }

    static void _dealloc_IPosPrinterJob(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPosPrinterJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_Print(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IPosPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IPosPrinterJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPosPrinterJob[] = {
        { "execute_async", reinterpret_cast<PyCFunction>(IPosPrinterJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(IPosPrinterJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(IPosPrinterJob_PrintLine), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPosPrinterJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPosPrinterJob[] = {
        { }
    };

    static PyType_Slot _type_slots_IPosPrinterJob[] = 
    {
        { Py_tp_new, _new_IPosPrinterJob },
        { Py_tp_dealloc, _dealloc_IPosPrinterJob },
        { Py_tp_methods, _methods_IPosPrinterJob },
        { Py_tp_getset, _getset_IPosPrinterJob },
        { },
    };

    static PyType_Spec _type_spec_IPosPrinterJob =
    {
        "_winsdk_Windows_Devices_PointOfService.IPosPrinterJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPosPrinterJob
    };

    // ----- IReceiptOrSlipJob interface --------------------
    constexpr const char* const _type_name_IReceiptOrSlipJob = "IReceiptOrSlipJob";

    static PyObject* _new_IReceiptOrSlipJob(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IReceiptOrSlipJob);
        return nullptr;
    }

    static void _dealloc_IReceiptOrSlipJob(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IReceiptOrSlipJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_Print(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IReceiptOrSlipJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReceiptOrSlipJob[] = {
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintLine), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IReceiptOrSlipJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IReceiptOrSlipJob[] = {
        { }
    };

    static PyType_Slot _type_slots_IReceiptOrSlipJob[] = 
    {
        { Py_tp_new, _new_IReceiptOrSlipJob },
        { Py_tp_dealloc, _dealloc_IReceiptOrSlipJob },
        { Py_tp_methods, _methods_IReceiptOrSlipJob },
        { Py_tp_getset, _getset_IReceiptOrSlipJob },
        { },
    };

    static PyType_Spec _type_spec_IReceiptOrSlipJob =
    {
        "_winsdk_Windows_Devices_PointOfService.IReceiptOrSlipJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReceiptOrSlipJob
    };

    // ----- SizeUInt32 struct --------------------
    constexpr const char* const _type_name_SizeUInt32 = "SizeUInt32";

    PyObject* _new_SizeUInt32(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::PointOfService::SizeUInt32>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::PointOfService::SizeUInt32 return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SizeUInt32(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self)
    {
    }

    static PyObject* SizeUInt32_get_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SizeUInt32_get_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SizeUInt32[] = {
        { "width", reinterpret_cast<getter>(SizeUInt32_get_Width), reinterpret_cast<setter>(SizeUInt32_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(SizeUInt32_get_Height), reinterpret_cast<setter>(SizeUInt32_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SizeUInt32[] = 
    {
        { Py_tp_new, _new_SizeUInt32 },
        { Py_tp_dealloc, _dealloc_SizeUInt32 },
        { Py_tp_getset, _getset_SizeUInt32 },
        { },
    };

    static PyType_Spec _type_spec_SizeUInt32 =
    {
        "_winsdk_Windows_Devices_PointOfService.SizeUInt32",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SizeUInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeUInt32
    };

    // ----- Windows.Devices.PointOfService Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::python_type = py::register_python_type(module, _type_name_BarcodeScanner, &_type_spec_BarcodeScanner, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::python_type = py::register_python_type(module, _type_name_BarcodeScannerCapabilities, &_type_spec_BarcodeScannerCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerDataReceivedEventArgs, &_type_spec_BarcodeScannerDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerErrorOccurredEventArgs, &_type_spec_BarcodeScannerErrorOccurredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerImagePreviewReceivedEventArgs, &_type_spec_BarcodeScannerImagePreviewReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>::python_type = py::register_python_type(module, _type_name_BarcodeScannerReport, &_type_spec_BarcodeScannerReport, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_BarcodeScannerStatusUpdatedEventArgs, &_type_spec_BarcodeScannerStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::python_type = py::register_python_type(module, _type_name_BarcodeSymbologies, &_type_spec_BarcodeSymbologies, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::python_type = py::register_python_type(module, _type_name_BarcodeSymbologyAttributes, &_type_spec_BarcodeSymbologyAttributes, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawer>::python_type = py::register_python_type(module, _type_name_CashDrawer, &_type_spec_CashDrawer, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::python_type = py::register_python_type(module, _type_name_CashDrawerCapabilities, &_type_spec_CashDrawerCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::python_type = py::register_python_type(module, _type_name_CashDrawerCloseAlarm, &_type_spec_CashDrawerCloseAlarm, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::python_type = py::register_python_type(module, _type_name_CashDrawerClosedEventArgs, &_type_spec_CashDrawerClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::python_type = py::register_python_type(module, _type_name_CashDrawerEventSource, &_type_spec_CashDrawerEventSource, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::python_type = py::register_python_type(module, _type_name_CashDrawerOpenedEventArgs, &_type_spec_CashDrawerOpenedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::python_type = py::register_python_type(module, _type_name_CashDrawerStatus, &_type_spec_CashDrawerStatus, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_CashDrawerStatusUpdatedEventArgs, &_type_spec_CashDrawerStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::python_type = py::register_python_type(module, _type_name_ClaimedBarcodeScanner, &_type_spec_ClaimedBarcodeScanner, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedBarcodeScannerClosedEventArgs, &_type_spec_ClaimedBarcodeScannerClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::python_type = py::register_python_type(module, _type_name_ClaimedCashDrawer, &_type_spec_ClaimedCashDrawer, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedCashDrawerClosedEventArgs, &_type_spec_ClaimedCashDrawerClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedJournalPrinter, &_type_spec_ClaimedJournalPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::python_type = py::register_python_type(module, _type_name_ClaimedLineDisplay, &_type_spec_ClaimedLineDisplay, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedLineDisplayClosedEventArgs, &_type_spec_ClaimedLineDisplayClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::python_type = py::register_python_type(module, _type_name_ClaimedMagneticStripeReader, &_type_spec_ClaimedMagneticStripeReader, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedMagneticStripeReaderClosedEventArgs, &_type_spec_ClaimedMagneticStripeReaderClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedPosPrinter, &_type_spec_ClaimedPosPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::python_type = py::register_python_type(module, _type_name_ClaimedPosPrinterClosedEventArgs, &_type_spec_ClaimedPosPrinterClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedReceiptPrinter, &_type_spec_ClaimedReceiptPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::python_type = py::register_python_type(module, _type_name_ClaimedSlipPrinter, &_type_spec_ClaimedSlipPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::python_type = py::register_python_type(module, _type_name_JournalPrintJob, &_type_spec_JournalPrintJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_JournalPrinterCapabilities, &_type_spec_JournalPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplay>::python_type = py::register_python_type(module, _type_name_LineDisplay, &_type_spec_LineDisplay, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::python_type = py::register_python_type(module, _type_name_LineDisplayAttributes, &_type_spec_LineDisplayAttributes, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::python_type = py::register_python_type(module, _type_name_LineDisplayCapabilities, &_type_spec_LineDisplayCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::python_type = py::register_python_type(module, _type_name_LineDisplayCursor, &_type_spec_LineDisplayCursor, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::python_type = py::register_python_type(module, _type_name_LineDisplayCursorAttributes, &_type_spec_LineDisplayCursorAttributes, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::python_type = py::register_python_type(module, _type_name_LineDisplayCustomGlyphs, &_type_spec_LineDisplayCustomGlyphs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::python_type = py::register_python_type(module, _type_name_LineDisplayMarquee, &_type_spec_LineDisplayMarquee, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::python_type = py::register_python_type(module, _type_name_LineDisplayStatisticsCategorySelector, &_type_spec_LineDisplayStatisticsCategorySelector, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_LineDisplayStatusUpdatedEventArgs, &_type_spec_LineDisplayStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::python_type = py::register_python_type(module, _type_name_LineDisplayStoredBitmap, &_type_spec_LineDisplayStoredBitmap, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::python_type = py::register_python_type(module, _type_name_LineDisplayWindow, &_type_spec_LineDisplayWindow, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::python_type = py::register_python_type(module, _type_name_MagneticStripeReader, &_type_spec_MagneticStripeReader, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderAamvaCardDataReceivedEventArgs, &_type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderBankCardDataReceivedEventArgs, &_type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderCapabilities, &_type_spec_MagneticStripeReaderCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderCardTypes, &_type_spec_MagneticStripeReaderCardTypes, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderEncryptionAlgorithms, &_type_spec_MagneticStripeReaderEncryptionAlgorithms, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderErrorOccurredEventArgs, &_type_spec_MagneticStripeReaderErrorOccurredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderReport, &_type_spec_MagneticStripeReaderReport, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderStatusUpdatedEventArgs, &_type_spec_MagneticStripeReaderStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderTrackData, &_type_spec_MagneticStripeReaderTrackData, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, &_type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinter>::python_type = py::register_python_type(module, _type_name_PosPrinter, &_type_spec_PosPrinter, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_PosPrinterCapabilities, &_type_spec_PosPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::python_type = py::register_python_type(module, _type_name_PosPrinterCharacterSetIds, &_type_spec_PosPrinterCharacterSetIds, nullptr);
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::python_type = py::register_python_type(module, _type_name_PosPrinterFontProperty, &_type_spec_PosPrinterFontProperty, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>::python_type = py::register_python_type(module, _type_name_PosPrinterPrintOptions, &_type_spec_PosPrinterPrintOptions, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PosPrinterReleaseDeviceRequestedEventArgs, &_type_spec_PosPrinterReleaseDeviceRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::python_type = py::register_python_type(module, _type_name_PosPrinterStatus, &_type_spec_PosPrinterStatus, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::python_type = py::register_python_type(module, _type_name_PosPrinterStatusUpdatedEventArgs, &_type_spec_PosPrinterStatusUpdatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::python_type = py::register_python_type(module, _type_name_ReceiptPrintJob, &_type_spec_ReceiptPrintJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_ReceiptPrinterCapabilities, &_type_spec_ReceiptPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::python_type = py::register_python_type(module, _type_name_SlipPrintJob, &_type_spec_SlipPrintJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::python_type = py::register_python_type(module, _type_name_SlipPrinterCapabilities, &_type_spec_SlipPrinterCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>::python_type = py::register_python_type(module, _type_name_UnifiedPosErrorData, &_type_spec_UnifiedPosErrorData, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::python_type = py::register_python_type(module, _type_name_ICashDrawerEventSourceEventArgs, &_type_spec_ICashDrawerEventSourceEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::python_type = py::register_python_type(module, _type_name_ICommonClaimedPosPrinterStation, &_type_spec_ICommonClaimedPosPrinterStation, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::python_type = py::register_python_type(module, _type_name_ICommonPosPrintStationCapabilities, &_type_spec_ICommonPosPrintStationCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::python_type = py::register_python_type(module, _type_name_ICommonReceiptSlipCapabilities, &_type_spec_ICommonReceiptSlipCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::python_type = py::register_python_type(module, _type_name_IPosPrinterJob, &_type_spec_IPosPrinterJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::python_type = py::register_python_type(module, _type_name_IReceiptOrSlipJob, &_type_spec_IReceiptOrSlipJob, bases.get());
            py::winrt_type<winrt::Windows::Devices::PointOfService::SizeUInt32>::python_type = py::register_python_type(module, _type_name_SizeUInt32, &_type_spec_SizeUInt32, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Devices.PointOfService");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_PointOfService",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Devices::PointOfService

PyMODINIT_FUNC
PyInit__winsdk_Windows_Devices_PointOfService (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::PointOfService::module_def);
}
